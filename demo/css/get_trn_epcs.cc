#!/usr/local/bin/css -f
// this line allows it to be run directly.  put in the correct path to css

// this is example css/C++ code that can be run directly in css or 
// compiled into hard code via c++.  it was developed in css.  the
// detailed steps of how to do this are covered in the manual in the
// chapter on css.

// this code processes a log file generated by pdp++ and computes the
// number of training epochs required to reach a specified training
// criterion over multiple batches of runs, saving the results in another
// file, which is then run through a utility program called 'dtsem' (C
// source code included in this directory), which computes means and
// standard-error-of means on columns of numbers.

// this is header file allows a C++ compiler to know about all the things
// css uses in its run-time environment (and is not included when run in css)
#ifndef __CSS__
#include <css/hard_of_css.h>
#endif

// call with arg 1 = training cutoff, arg 2.. = file names

float	trn_thresh = 5;		//  = argv[1];	training sse threshold for counting gen
int 	se_col = -1;		// column that se is in
int 	epc_col = -1;		// column that epc is in

void GetCols(String_Array& col) {
  if(se_col < 0) {
    se_col = col.Find("sum_sum_se");
    if(se_col >= 0)
      cerr << "using column: " << se_col << " for se\n";
    else
      cerr << "warning: se column not found!\n";
  }

  if(epc_col < 0) {
    epc_col = col.Find("|epoch");
    if(epc_col >= 0)
      cerr << "using column: " << epc_col << " for epoch\n";
    else
      cerr << "warning: epoch column not found!\n";
  }
}

void SkipRestofBatch(istream& epc_strm) {
  int cur_batch = -1;
  while(!epc_strm.eof()) {
    String_Array& col = ReadLine(epc_strm);
    if(epc_strm.eof())      return;
    if(col[0].contains("_H:")) {
      GetCols(col);
      continue; // skip headers
    }

    int batch = col[1];
    if(cur_batch < 0)
      cur_batch = batch;
    if(batch != cur_batch)
      break;
  }
}

int FindStartEpoch(istream& epc_strm) {
  int cur_batch = -1;
  while(!epc_strm.eof()) {
    String_Array& col = ReadLine(epc_strm);
    if(epc_strm.eof())      return -1;
    if(col[0].contains("_H:")) {
      GetCols(col);
      continue; // skip headers
    }

    int batch = col[1];
    if(cur_batch < 0)
      cur_batch = batch;
    if(batch != cur_batch)
      return -1;
    float sse = col[se_col];
    if(sse  <= trn_thresh) {
      int epc = col[epc_col];
      SkipRestofBatch(epc_strm);
      return epc;
    }
  }
}  

void GetTrn(String file_nm) {
  String stub_nm;		// base name of file
  if(file_nm.contains(".epc.log"))
    stub_nm = file_nm.before(".epc.log");
  else
    stub_nm = file_nm.before(".bat.log");

  String out_fnm = stub_nm + ".trn";

  fstream epc_strm, tst_strm, out_strm;
  epc_strm.open(stub_nm + ".epc.log", ios::in);
  out_strm.open(out_fnm, ios::out);
  
  out_strm.width(6);
  
  out_strm << "batch\tst_epc\tthresh:\t" << trn_thresh << "\n";
  
  int bat;
  for(bat=0;bat<100; bat++) {
    int st_epc = FindStartEpoch(epc_strm);
    if(st_epc < 0) {
      cout << bat << "\t" << "did not learn to threshold: " << trn_thresh << "\n";
    }
    out_strm << bat << "\t" << st_epc << "\n";

    if(epc_strm.eof())
      break;
  }
  epc_strm.close();
  out_strm.close();
  // you can do some post-processing with unix commands too..
  String cmd = (String)"tail -" + (String)(bat+1) + " " + out_fnm + " | dtsem l d 2 >> " + out_fnm;
  system(cmd);
  cout << "file: " << out_fnm << "\n";
  cmd = (String)"more " + out_fnm;
  system(cmd);
}

// the main function *must* be called s_main, and take these args
void s_main(int ac, String* av) {
  if(ac < 3) {
    cerr << "Need at least 2 args:\n"
	 << "\tsse threshold for counting training as complete\n"
	 << "log file names..\n";
    return;
  }
  trn_thresh = (float)av[1];

  int i;
  for(i=2; i<ac; i++)
    GetTrn(av[i]);
}

// in CSS, we simply call this function with the global args
// in C++, hard_of_css.h defines a main() function which does this
#ifdef __CSS__
s_main(argc, argv);
#endif
