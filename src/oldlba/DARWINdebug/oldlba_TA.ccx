// File Automatically Generated by MakeTA
// DO NOT EDIT


#include <ta/typea.h>
#include <ta/typea_constr.h>
#include <css/basic_types.h>
#include <css/c_ptr_types.h>
#include <css/ta_css.h>
#include <oldlba.h>
#include "oldlba_TA_type.h"
#include "oldlba_TA_inst.h"


// Types

TypeDef TA_LeabraCon("LeabraCon", " Leabra connection", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(LeabraCon), (void**)&TAI_LeabraCon, 0, 0, 0,1);
TypeDef TA_LeabraConSpec("LeabraConSpec", " Leabra connection specs", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraConSpec), (void**)&TAI_LeabraConSpec, 1, 0, 0,1);
TypeDef TA_LeabraBiasSpec("LeabraBiasSpec", " Leabra bias-weight connection specs (bias wts are a little bit special)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraBiasSpec), (void**)&TAI_LeabraBiasSpec, 1, 0, 0,1);
TypeDef TA_LeabraCon_Group("LeabraCon_Group", " Leabra connection group", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(LeabraCon_Group), (void**)&TAI_LeabraCon_Group, 0, 0, 0,1);
TypeDef TA_LeabraUnitSpec("LeabraUnitSpec", " Leabra unit specifications, point-neuron approximation", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraUnitSpec), (void**)&TAI_LeabraUnitSpec, 1, 0, 0,1);
TypeDef TA_LeabraUnit("LeabraUnit", " Leabra unit, point-neuron approximation", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "", sizeof(LeabraUnit), (void**)&TAI_LeabraUnit, 0, 0, 0,1);
TypeDef TA_LeabraInhib("LeabraInhib", " holds threshold-computation values, used as a parent class for layers, etc", 
	"", "", "", sizeof(LeabraInhib), (void**)&TAI_LeabraInhib, 1, 0, 0,1);
TypeDef TA_LeabraLayerSpec("LeabraLayerSpec", " Leabra layer specs, computes inhibitory input for all units in layer", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraLayerSpec), (void**)&TAI_LeabraLayerSpec, 1, 0, 0,1);
TypeDef TA_LeabraUnit_Group("LeabraUnit_Group", " for independent subgroups of competing units within a single layer", 
	"", "MULT_INHERIT ", "", sizeof(LeabraUnit_Group), (void**)&TAI_LeabraUnit_Group, 0, 0, 0,1);
TypeDef TA_LeabraLayer("LeabraLayer", " Leabra Layer: implicit inhibition for soft kWTA behavior", 
	"EXT_lay COMPRESS ", "EXT_lay COMPRESS MULT_INHERIT ", "", sizeof(LeabraLayer), (void**)&TAI_LeabraLayer, 1, 0, 0,1);
TypeDef TA_LeabraCycle("LeabraCycle", " one Leabra cycle of activation updating", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(LeabraCycle), (void**)&TAI_LeabraCycle, 1, 0, 0,1);
TypeDef TA_LeabraSettle("LeabraSettle", " Leabra settling phase of activation updating", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(LeabraSettle), (void**)&TAI_LeabraSettle, 1, 0, 0,1);
TypeDef TA_LeabraTrial("LeabraTrial", " Leabra trial process, iterates over phases", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(LeabraTrial), (void**)&TAI_LeabraTrial, 1, 0, 0,1);
TypeDef TA_LeabraMaxDa("LeabraMaxDa", " _ stat that computes when equilibrium is", 
	"EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "", sizeof(LeabraMaxDa), (void**)&TAI_LeabraMaxDa, 1, 0, 0,1);
TypeDef TA_const_LeabraCon("const_LeabraCon", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraCon_ref("const_LeabraCon_ref", 1, 0, 1, 0,1);
TypeDef TA_WtScaleSpec("WtScaleSpec", " weight scaling specification", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(WtScaleSpec), (void**)&TAI_WtScaleSpec, 0, 0, 0,1);
TypeDef TA_const_WtScaleSpec("const_WtScaleSpec", 1, 0, 0, 0,1);
TypeDef TA_WtSigSpec("WtSigSpec", " sigmoidal weight function specification", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(WtSigSpec), (void**)&TAI_WtSigSpec, 0, 0, 0,1);
TypeDef TA_const_WtScaleSpec_ref("const_WtScaleSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_WtSigSpec("const_WtSigSpec", 1, 0, 0, 0,1);
TypeDef TA_const_WtSigSpec_ref("const_WtSigSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LearnMixSpec("LearnMixSpec", " mixture of learning factors (hebbian vs. error-driven) specification", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(LearnMixSpec), (void**)&TAI_LearnMixSpec, 0, 0, 0,1);
TypeDef TA_const_LearnMixSpec("const_LearnMixSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LearnMixSpec_ref("const_LearnMixSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_FixedSAvg("FixedSAvg", " provide fixed sending avg activity level for netin computation (and SAvgCor)", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(FixedSAvg), (void**)&TAI_FixedSAvg, 0, 0, 0,1);
TypeDef TA_const_FixedSAvg("const_FixedSAvg", 1, 0, 0, 0,1);
TypeDef TA_const_FixedSAvg_ref("const_FixedSAvg_ref", 1, 0, 1, 0,1);
TypeDef TA_SAvgCorSpec("SAvgCorSpec", " sending average activation correction specifications", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SAvgCorSpec), (void**)&TAI_SAvgCorSpec, 0, 0, 0,1);
TypeDef TA_LeabraCon_Group_ptr("LeabraCon_Group_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_SAvgCorSpec("const_SAvgCorSpec", 1, 0, 0, 0,1);
TypeDef TA_LeabraCon_ptr("LeabraCon_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_SAvgCorSpec_ref("const_SAvgCorSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraUnit_ptr("LeabraUnit_ptr", 1, 1, 0, 0,1);
TypeDef TA_LeabraUnitSpec_ptr("LeabraUnitSpec_ptr", 1, 1, 0, 0,1);
TypeDef TA_LeabraTrial_ptr("LeabraTrial_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_LeabraConSpec("const_LeabraConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraConSpec_ref("const_LeabraConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraBiasSpec("const_LeabraBiasSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraBiasSpec_ref("const_LeabraBiasSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraCon_Group("const_LeabraCon_Group", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraCon_Group_ref("const_LeabraCon_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_ActFunSpec("ActFunSpec", " activation function specifications", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ActFunSpec), (void**)&TAI_ActFunSpec, 0, 0, 0,1);
TypeDef TA_const_ActFunSpec("const_ActFunSpec", 1, 0, 0, 0,1);
TypeDef TA_SpikeFunSpec("SpikeFunSpec", " spiking activation function specs", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SpikeFunSpec), (void**)&TAI_SpikeFunSpec, 0, 0, 0,1);
TypeDef TA_const_ActFunSpec_ref("const_ActFunSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_SpikeFunSpec("const_SpikeFunSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SpikeFunSpec_ref("const_SpikeFunSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_DepressSpec("DepressSpec", " depressing synapses activation function specs", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(DepressSpec), (void**)&TAI_DepressSpec, 0, 0, 0,1);
TypeDef TA_const_DepressSpec("const_DepressSpec", 1, 0, 0, 0,1);
TypeDef TA_const_DepressSpec_ref("const_DepressSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_OptThreshSpec("OptThreshSpec", " optimization thresholds for faster processing", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(OptThreshSpec), (void**)&TAI_OptThreshSpec, 0, 0, 0,1);
TypeDef TA_const_OptThreshSpec("const_OptThreshSpec", 1, 0, 0, 0,1);
TypeDef TA_const_OptThreshSpec_ref("const_OptThreshSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_DtSpec("DtSpec", " time constants", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(DtSpec), (void**)&TAI_DtSpec, 0, 0, 0,1);
TypeDef TA_const_DtSpec("const_DtSpec", 1, 0, 0, 0,1);
TypeDef TA_const_DtSpec_ref("const_DtSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraChannels("LeabraChannels", " channels used in Leabra", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(LeabraChannels), (void**)&TAI_LeabraChannels, 0, 0, 0,1);
TypeDef TA_const_LeabraChannels("const_LeabraChannels", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraChannels_ref("const_LeabraChannels_ref", 1, 0, 1, 0,1);
TypeDef TA_VChanSpec("VChanSpec", " voltage gated channel specs", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(VChanSpec), (void**)&TAI_VChanSpec, 0, 0, 0,1);
TypeDef TA_const_VChanSpec("const_VChanSpec", 1, 0, 0, 0,1);
TypeDef TA_PhaseSharpSpec("PhaseSharpSpec", " phase-based sharpening specification: activations are sharper in plus phase", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(PhaseSharpSpec), (void**)&TAI_PhaseSharpSpec, 0, 0, 0,1);
TypeDef TA_const_VChanSpec_ref("const_VChanSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_PhaseSharpSpec("const_PhaseSharpSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PhaseSharpSpec_ref("const_PhaseSharpSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ActRegSpec("ActRegSpec", " activity regulation via weight adjustment", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ActRegSpec), (void**)&TAI_ActRegSpec, 0, 0, 0,1);
TypeDef TA_LeabraLayer_ptr("LeabraLayer_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_ActRegSpec("const_ActRegSpec", 1, 0, 0, 0,1);
TypeDef TA_LeabraInhib_ptr("LeabraInhib_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_ActRegSpec_ref("const_ActRegSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraUnitSpec("const_LeabraUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraUnitSpec_ref("const_LeabraUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_VChanBasis("VChanBasis", " basis variables for vchannels", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(VChanBasis), (void**)&TAI_VChanBasis, 0, 0, 0,1);
TypeDef TA_const_VChanBasis("const_VChanBasis", 1, 0, 0, 0,1);
TypeDef TA_LeabraUnitChans("LeabraUnitChans", " channels used in Leabra units", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(LeabraUnitChans), (void**)&TAI_LeabraUnitChans, 0, 0, 0,1);
TypeDef TA_const_VChanBasis_ref("const_VChanBasis_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraUnit("const_LeabraUnit", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraUnitChans("const_LeabraUnitChans", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraUnit_ref("const_LeabraUnit_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraUnitChans_ref("const_LeabraUnitChans_ref", 1, 0, 1, 0,1);
TypeDef TA_taPtrList_LeabraUnit_("taPtrList_LeabraUnit_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taPtrList<LeabraUnit>), (void**)&TAI_taPtrList_LeabraUnit_, 0, 0, 0,1);
TypeDef TA_LeabraSort("LeabraSort", " used for sorting units in kwta computation", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(LeabraSort), (void**)&TAI_LeabraSort, 0, 0, 0,1);
TypeDef TA_KWTASpec("KWTASpec", " specifies k-winner-take-all parameters", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(KWTASpec), (void**)&TAI_KWTASpec, 0, 0, 0,1);
TypeDef TA_const_KWTASpec("const_KWTASpec", 1, 0, 0, 0,1);
TypeDef TA_AdaptISpec("AdaptISpec", " specifies adaptive kwta specs (esp for avg-based)", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(AdaptISpec), (void**)&TAI_AdaptISpec, 0, 0, 0,1);
TypeDef TA_const_KWTASpec_ref("const_KWTASpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_AdaptISpec("const_AdaptISpec", 1, 0, 0, 0,1);
TypeDef TA_const_AdaptISpec_ref("const_AdaptISpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ClampSpec("ClampSpec", " specs for clamping ", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(ClampSpec), (void**)&TAI_ClampSpec, 0, 0, 0,1);
TypeDef TA_const_ClampSpec("const_ClampSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ClampSpec_ref("const_ClampSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_DecaySpec("DecaySpec", " holds decay values", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(DecaySpec), (void**)&TAI_DecaySpec, 0, 0, 0,1);
TypeDef TA_const_DecaySpec("const_DecaySpec", 1, 0, 0, 0,1);
TypeDef TA_const_DecaySpec_ref("const_DecaySpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LayerLinkSpec("LayerLinkSpec", " specs for linking inhibition across layers", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(LayerLinkSpec), (void**)&TAI_LayerLinkSpec, 0, 0, 0,1);
TypeDef TA_const_LayerLinkSpec("const_LayerLinkSpec", 1, 0, 0, 0,1);
TypeDef TA_KWTASpec_ref("KWTASpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LayerLinkSpec_ref("const_LayerLinkSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraLayerSpec("const_LeabraLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_ref("const_LeabraLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_SpecPtr_LeabraLayerSpec_("SpecPtr_LeabraLayerSpec_", "", 
	"INLINE NO_UPDATE_AFTER ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SpecPtr<LeabraLayerSpec>), (void**)&TAI_SpecPtr_LeabraLayerSpec_, 0, 0, 0,1);
TypeDef TA_LeabraLayerSpec_SPtr("LeabraLayerSpec_SPtr", "", 
	"INLINE NO_UPDATE_AFTER ", "INLINE NO_UPDATE_AFTER ", "", sizeof(LeabraLayerSpec_SPtr), (void**)&TAI_LeabraLayerSpec_SPtr, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_SPtr("const_LeabraLayerSpec_SPtr", 1, 0, 0, 0,1);
TypeDef TA_AvgMaxVals("AvgMaxVals", " holds average and max statistics", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(AvgMaxVals), (void**)&TAI_AvgMaxVals, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_SPtr_ref("const_LeabraLayerSpec_SPtr_ref", 1, 0, 1, 0,1);
TypeDef TA_const_AvgMaxVals("const_AvgMaxVals", 1, 0, 0, 0,1);
TypeDef TA_const_AvgMaxVals_ref("const_AvgMaxVals_ref", 1, 0, 1, 0,1);
TypeDef TA_KWTAVals("KWTAVals", " holds values for kwta stuff", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(KWTAVals), (void**)&TAI_KWTAVals, 0, 0, 0,1);
TypeDef TA_const_KWTAVals("const_KWTAVals", 1, 0, 0, 0,1);
TypeDef TA_const_KWTAVals_ref("const_KWTAVals_ref", 1, 0, 1, 0,1);
TypeDef TA_AdaptIVals("AdaptIVals", " holds values for adapting kwta stuff", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(AdaptIVals), (void**)&TAI_AdaptIVals, 0, 0, 0,1);
TypeDef TA_const_AdaptIVals("const_AdaptIVals", 1, 0, 0, 0,1);
TypeDef TA_const_AdaptIVals_ref("const_AdaptIVals_ref", 1, 0, 1, 0,1);
TypeDef TA_InhibVals("InhibVals", " holds values for inhibition", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(InhibVals), (void**)&TAI_InhibVals, 0, 0, 0,1);
TypeDef TA_const_InhibVals("const_InhibVals", 1, 0, 0, 0,1);
TypeDef TA_const_InhibVals_ref("const_InhibVals_ref", 1, 0, 1, 0,1);
TypeDef TA_LayerLink("LayerLink", " Link strength between layers, affects threshold", 
	"", "NO_UPDATE_AFTER ", "", sizeof(LayerLink), (void**)&TAI_LayerLink, 0, 0, 0,1);
TypeDef TA_taList_LayerLink_("taList_LayerLink_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taList<LayerLink>), (void**)&TAI_taList_LayerLink_, 0, 0, 0,1);
TypeDef TA_const_LayerLink("const_LayerLink", 1, 0, 0, 0,1);
TypeDef TA_const_LayerLink_ref("const_LayerLink_ref", 1, 0, 1, 0,1);
TypeDef TA_LayerLink_List("LayerLink_List", " list of LayerLink objects", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(LayerLink_List), (void**)&TAI_LayerLink_List, 0, 0, 0,1);
TypeDef TA_LeabraLayerSpec_ptr("LeabraLayerSpec_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_LayerLink_List("const_LayerLink_List", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraInhib("const_LeabraInhib", 1, 0, 0, 0,1);
TypeDef TA_const_LayerLink_List_ref("const_LayerLink_List_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraInhib_ref("const_LeabraInhib_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraLayer("const_LeabraLayer", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraLayer_ref("const_LeabraLayer_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraUnit_Group("const_LeabraUnit_Group", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraUnit_Group_ref("const_LeabraUnit_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraSettle_ptr("LeabraSettle_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_LeabraCycle("const_LeabraCycle", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraCycle_ref("const_LeabraCycle_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraSettle("const_LeabraSettle", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraSettle_ref("const_LeabraSettle_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraTrial("const_LeabraTrial", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraTrial_ref("const_LeabraTrial_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraMaxDa("const_LeabraMaxDa", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraMaxDa_ref("const_LeabraMaxDa_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraSE_Stat("LeabraSE_Stat", " squared error for leabra, controls when to compute SE ", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraSE_Stat), (void**)&TAI_LeabraSE_Stat, 1, 0, 0,1);
TypeDef TA_const_LeabraSE_Stat("const_LeabraSE_Stat", 1, 0, 0, 0,1);
TypeDef TA_LeabraAeSE_Stat("LeabraAeSE_Stat", " squared error for leabra auto-encoder: legacy object does same thing as LeabraSE_Stat", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraAeSE_Stat), (void**)&TAI_LeabraAeSE_Stat, 1, 0, 0,1);
TypeDef TA_const_LeabraSE_Stat_ref("const_LeabraSE_Stat_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraAeSE_Stat("const_LeabraAeSE_Stat", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraAeSE_Stat_ref("const_LeabraAeSE_Stat_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraGoodStat("LeabraGoodStat", " constraint satisfaction goodness statistic", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraGoodStat), (void**)&TAI_LeabraGoodStat, 1, 0, 0,1);
TypeDef TA_const_LeabraGoodStat("const_LeabraGoodStat", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraGoodStat_ref("const_LeabraGoodStat_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraSharpStat("LeabraSharpStat", " layer sharpness statistic: just max / avg", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraSharpStat), (void**)&TAI_LeabraSharpStat, 1, 0, 0,1);
TypeDef TA_const_LeabraSharpStat("const_LeabraSharpStat", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraSharpStat_ref("const_LeabraSharpStat_ref", 1, 0, 1, 0,1);
TypeDef TA_WrongOnStat("WrongOnStat", " Reports an error if a unit is on when it shouldn't have been (for multiple output cases)", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(WrongOnStat), (void**)&TAI_WrongOnStat, 1, 0, 0,1);
TypeDef TA_const_WrongOnStat("const_WrongOnStat", 1, 0, 0, 0,1);
TypeDef TA_const_WrongOnStat_ref("const_WrongOnStat_ref", 1, 0, 1, 0,1);
TypeDef TA_ACRewSpec("ACRewSpec", " specs for reward computing stuff", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(ACRewSpec), (void**)&TAI_ACRewSpec, 0, 0, 0,1);
TypeDef TA_const_ACRewSpec("const_ACRewSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ACRewSpec_ref("const_ACRewSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraACLayerSpec("LeabraACLayerSpec", " Layer with 1 unit as the AC (Adaptive Critic) for Reinforcement Learning", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraACLayerSpec), (void**)&TAI_LeabraACLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraACLayerSpec("const_LeabraACLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraACLayerSpec_ref("const_LeabraACLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraLinUnitSpec("LeabraLinUnitSpec", " a pure linear unit (suitable for an AC unit spec unit)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraLinUnitSpec), (void**)&TAI_LeabraLinUnitSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraLinUnitSpec("const_LeabraLinUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraLinUnitSpec_ref("const_LeabraLinUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_CtxtUpdateSpec("CtxtUpdateSpec", " context updating specifications", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(CtxtUpdateSpec), (void**)&TAI_CtxtUpdateSpec, 0, 0, 0,1);
TypeDef TA_const_CtxtUpdateSpec("const_CtxtUpdateSpec", 1, 0, 0, 0,1);
TypeDef TA_const_CtxtUpdateSpec_ref("const_CtxtUpdateSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraContextLayerSpec("LeabraContextLayerSpec", " context layer that copies from its recv projection (like an input layer)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraContextLayerSpec), (void**)&TAI_LeabraContextLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraContextLayerSpec("const_LeabraContextLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraContextLayerSpec_ref("const_LeabraContextLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_GateSpec("GateSpec", " gating parameters", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(GateSpec), (void**)&TAI_GateSpec, 0, 0, 0,1);
TypeDef TA_const_GateSpec("const_GateSpec", 1, 0, 0, 0,1);
TypeDef TA_const_GateSpec_ref("const_GateSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_GateNoiseSpec("GateNoiseSpec", " noise in the gating signal parameters", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(GateNoiseSpec), (void**)&TAI_GateNoiseSpec, 0, 0, 0,1);
TypeDef TA_LeabraConSpec_ptr("LeabraConSpec_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_GateNoiseSpec("const_GateNoiseSpec", 1, 0, 0, 0,1);
TypeDef TA_const_GateNoiseSpec_ref("const_GateNoiseSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraGatedCtxLayerSpec("LeabraGatedCtxLayerSpec", " gated context layer: gate based on AC unit, need a different spec (& assoc con specs) for each such layer, also set LeabraTrial phase_order = MINUS_PLUS_PLUS", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraGatedCtxLayerSpec), (void**)&TAI_LeabraGatedCtxLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraGatedCtxLayerSpec("const_LeabraGatedCtxLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraGatedCtxLayerSpec_ref("const_LeabraGatedCtxLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraACMaintLayerSpec("LeabraACMaintLayerSpec", " intrinsic maintenance (gc.h) driven by AC TD signals: must receive from AC Layer", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraACMaintLayerSpec), (void**)&TAI_LeabraACMaintLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraACMaintLayerSpec("const_LeabraACMaintLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraACMaintLayerSpec_ref("const_LeabraACMaintLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PhaseOrderEventSpec("PhaseOrderEventSpec", " event specification including order of phases", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Environment IMMEDIATE_UPDATE ", "EXT_spec MEMB_IN_GPMENU SCOPE_Environment IMMEDIATE_UPDATE ", "", sizeof(PhaseOrderEventSpec), (void**)&TAI_PhaseOrderEventSpec, 1, 0, 0,1);
TypeDef TA_LeabraTimeUnit("LeabraTimeUnit", " Leabra unit with an single step activation history", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "", sizeof(LeabraTimeUnit), (void**)&TAI_LeabraTimeUnit, 0, 0, 0,1);
TypeDef TA_const_PhaseOrderEventSpec("const_PhaseOrderEventSpec", 1, 0, 0, 0,1);
TypeDef TA_LeabraTimeUnitSpec("LeabraTimeUnitSpec", " adapts weights based on one step of activation history ", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraTimeUnitSpec), (void**)&TAI_LeabraTimeUnitSpec, 1, 0, 0,1);
TypeDef TA_const_PhaseOrderEventSpec_ref("const_PhaseOrderEventSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraTimeCon_Group("LeabraTimeCon_Group", " Leabra time connection group: just for backwards compatibility -- everything is in the base group now!", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(LeabraTimeCon_Group), (void**)&TAI_LeabraTimeCon_Group, 0, 0, 0,1);
TypeDef TA_const_LeabraTimeUnit("const_LeabraTimeUnit", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraTimeCon_Group("const_LeabraTimeCon_Group", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraTimeUnit_ref("const_LeabraTimeUnit_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraTimeCon_Group_ref("const_LeabraTimeCon_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraTimeUnitSpec("const_LeabraTimeUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraTimeUnitSpec_ref("const_LeabraTimeUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_TimeMixSpec("TimeMixSpec", " how much each point in time contributes", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(TimeMixSpec), (void**)&TAI_TimeMixSpec, 0, 0, 0,1);
TypeDef TA_const_TimeMixSpec("const_TimeMixSpec", 1, 0, 0, 0,1);
TypeDef TA_LeabraTimeConSpec("LeabraTimeConSpec", " computes weight change based on recv current and send previous acts: It is essential to set UnitSpec->opt_thresh.learn to -1 to get proper p_savg, p_max_cor values!", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraTimeConSpec), (void**)&TAI_LeabraTimeConSpec, 1, 0, 0,1);
TypeDef TA_const_TimeMixSpec_ref("const_TimeMixSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_LeabraTimeConSpec("const_LeabraTimeConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraTimeConSpec_ref("const_LeabraTimeConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraNegBiasSpec("LeabraNegBiasSpec", " only learns negative bias changes, not positive ones (decay restores back to zero)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraNegBiasSpec), (void**)&TAI_LeabraNegBiasSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraNegBiasSpec("const_LeabraNegBiasSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraNegBiasSpec_ref("const_LeabraNegBiasSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraMaintConSpec("LeabraMaintConSpec", " switches on hysteresis for sending act > maint_thresh, recv must have input = prjn[0] using NetConSpec", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraMaintConSpec), (void**)&TAI_LeabraMaintConSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraMaintConSpec("const_LeabraMaintConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraMaintConSpec_ref("const_LeabraMaintConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraNetConSpec("LeabraNetConSpec", " Saves the net-input value on a per-congroup basis", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraNetConSpec), (void**)&TAI_LeabraNetConSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraNetConSpec("const_LeabraNetConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraNetConSpec_ref("const_LeabraNetConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PhaseDWtConSpec("PhaseDWtConSpec", " specifies that weight changes should only take place for certain plus-phases (in multi-plus phase cases): only works with PhaseDWtUnitSpec", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PhaseDWtConSpec), (void**)&TAI_PhaseDWtConSpec, 1, 0, 0,1);
TypeDef TA_const_PhaseDWtConSpec("const_PhaseDWtConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PhaseDWtConSpec_ref("const_PhaseDWtConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PhaseDWtUnitSpec("PhaseDWtUnitSpec", " looks for phase dwt con specs and applies their dwt preferences", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PhaseDWtUnitSpec), (void**)&TAI_PhaseDWtUnitSpec, 1, 0, 0,1);
TypeDef TA_const_PhaseDWtUnitSpec("const_PhaseDWtUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PhaseDWtUnitSpec_ref("const_PhaseDWtUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraTabledConSpec("LeabraTabledConSpec", " Leabra connection spec with table driven learning, supporting one and two phase learning rules", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraTabledConSpec), (void**)&TAI_LeabraTabledConSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraTabledConSpec("const_LeabraTabledConSpec", 1, 0, 0, 0,1);
TypeDef TA_TrialSynDepCon("TrialSynDepCon", " synaptic depression connection at the trial level (as opposed to cycle level)", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(TrialSynDepCon), (void**)&TAI_TrialSynDepCon, 0, 0, 0,1);
TypeDef TA_const_LeabraTabledConSpec_ref("const_LeabraTabledConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_TrialSynDepCon("const_TrialSynDepCon", 1, 0, 0, 0,1);
TypeDef TA_const_TrialSynDepCon_ref("const_TrialSynDepCon_ref", 1, 0, 1, 0,1);
TypeDef TA_SynDepSpec("SynDepSpec", " specs for synaptic depression", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(SynDepSpec), (void**)&TAI_SynDepSpec, 0, 0, 0,1);
TypeDef TA_TrialSynDepCon_ptr("TrialSynDepCon_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_SynDepSpec("const_SynDepSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SynDepSpec_ref("const_SynDepSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_TrialSynDepConSpec("TrialSynDepConSpec", " synaptic depression connection at the trial level (as opposed to cycle level)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(TrialSynDepConSpec), (void**)&TAI_TrialSynDepConSpec, 1, 0, 0,1);
TypeDef TA_const_TrialSynDepConSpec("const_TrialSynDepConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_TrialSynDepConSpec_ref("const_TrialSynDepConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_FastWtCon("FastWtCon", " fast weight connection: standard wt learns fast, but decays toward slow weight value", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(FastWtCon), (void**)&TAI_FastWtCon, 0, 0, 0,1);
TypeDef TA_const_FastWtCon("const_FastWtCon", 1, 0, 0, 0,1);
TypeDef TA_const_FastWtCon_ref("const_FastWtCon_ref", 1, 0, 1, 0,1);
TypeDef TA_FastWtSpec("FastWtSpec", " specificiations for fast weights", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(FastWtSpec), (void**)&TAI_FastWtSpec, 0, 0, 0,1);
TypeDef TA_FastWtCon_ptr("FastWtCon_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_FastWtSpec("const_FastWtSpec", 1, 0, 0, 0,1);
TypeDef TA_const_FastWtSpec_ref("const_FastWtSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_FastWtConSpec("FastWtConSpec", " fast weight connection: standard wt learns fast, but decays toward slow weight value", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(FastWtConSpec), (void**)&TAI_FastWtConSpec, 1, 0, 0,1);
TypeDef TA_const_FastWtConSpec("const_FastWtConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_FastWtConSpec_ref("const_FastWtConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraNewHebbConSpec("LeabraNewHebbConSpec", " Leabra connection spec with new version of hebbian learning rule", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraNewHebbConSpec), (void**)&TAI_LeabraNewHebbConSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraNewHebbConSpec("const_LeabraNewHebbConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraNewHebbConSpec_ref("const_LeabraNewHebbConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_SigAmpSpec("SigAmpSpec", " Specifies a Sigmoid with amplitude: amp / [1 + exp(-(x - off) * gain)]", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(SigAmpSpec), (void**)&TAI_SigAmpSpec, 0, 0, 0,1);
TypeDef TA_const_SigAmpSpec("const_SigAmpSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SigAmpSpec_ref("const_SigAmpSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraSigHebbConSpec("LeabraSigHebbConSpec", " Leabra connection spec with mixture-of-sigmoids hebbian learning rule", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LeabraSigHebbConSpec), (void**)&TAI_LeabraSigHebbConSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraSigHebbConSpec("const_LeabraSigHebbConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraSigHebbConSpec_ref("const_LeabraSigHebbConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ScalarValSpec("ScalarValSpec", " specs for scalar values", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(ScalarValSpec), (void**)&TAI_ScalarValSpec, 0, 0, 0,1);
TypeDef TA_const_ScalarValSpec("const_ScalarValSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ScalarValSpec_ref("const_ScalarValSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ScalarValBias("ScalarValBias", " initial bias for given activation value for scalar value units", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(ScalarValBias), (void**)&TAI_ScalarValBias, 0, 0, 0,1);
TypeDef TA_const_ScalarValBias("const_ScalarValBias", 1, 0, 0, 0,1);
TypeDef TA_const_ScalarValBias_ref("const_ScalarValBias_ref", 1, 0, 1, 0,1);
TypeDef TA_ScalarValLayerSpec("ScalarValLayerSpec", " represents a scalar value using a coarse-coded distributed code over units. first unit represents scalar value.", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(ScalarValLayerSpec), (void**)&TAI_ScalarValLayerSpec, 1, 0, 0,1);
TypeDef TA_const_ScalarValLayerSpec("const_ScalarValLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ScalarValLayerSpec_ref("const_ScalarValLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ScalarValSelfPrjnSpec("ScalarValSelfPrjnSpec", " special projection for making self-connection that establishes neighbor similarity in scalar val", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(ScalarValSelfPrjnSpec), (void**)&TAI_ScalarValSelfPrjnSpec, 1, 0, 0,1);
TypeDef TA_const_ScalarValSelfPrjnSpec("const_ScalarValSelfPrjnSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ScalarValSelfPrjnSpec_ref("const_ScalarValSelfPrjnSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MarkerConSpec("MarkerConSpec", " connection spec that marks special projections: doesn't send netin or adapt weights", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(MarkerConSpec), (void**)&TAI_MarkerConSpec, 1, 0, 0,1);
TypeDef TA_const_MarkerConSpec("const_MarkerConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MarkerConSpec_ref("const_MarkerConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_DaModUnit("DaModUnit", " Leabra unit with dopamine-like modulation of minus phase activation for learning", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "", sizeof(DaModUnit), (void**)&TAI_DaModUnit, 0, 0, 0,1);
TypeDef TA_const_DaModUnit("const_DaModUnit", 1, 0, 0, 0,1);
TypeDef TA_const_DaModUnit_ref("const_DaModUnit_ref", 1, 0, 1, 0,1);
TypeDef TA_DaModSpec("DaModSpec", " specs for da-based learning from dynamic da modulation of plus-phase activations", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(DaModSpec), (void**)&TAI_DaModSpec, 0, 0, 0,1);
TypeDef TA_const_DaModSpec("const_DaModSpec", 1, 0, 0, 0,1);
TypeDef TA_const_DaModSpec_ref("const_DaModSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_DaModUnitSpec("DaModUnitSpec", " Leabra unit with temporal-differences error modulation of minus phase activation for learning", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(DaModUnitSpec), (void**)&TAI_DaModUnitSpec, 1, 0, 0,1);
TypeDef TA_const_DaModUnitSpec("const_DaModUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_DaModUnitSpec_ref("const_DaModUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_AvgExtRewSpec("AvgExtRewSpec", " specs for computing average external rewards", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(AvgExtRewSpec), (void**)&TAI_AvgExtRewSpec, 0, 0, 0,1);
TypeDef TA_const_AvgExtRewSpec("const_AvgExtRewSpec", 1, 0, 0, 0,1);
TypeDef TA_const_AvgExtRewSpec_ref("const_AvgExtRewSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_OutErrSpec("OutErrSpec", " specs for computing external rewards based on output performance of network", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(OutErrSpec), (void**)&TAI_OutErrSpec, 0, 0, 0,1);
TypeDef TA_const_OutErrSpec("const_OutErrSpec", 1, 0, 0, 0,1);
TypeDef TA_const_OutErrSpec_ref("const_OutErrSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ExtRewSpec("ExtRewSpec", " specs for computing external rewards", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(ExtRewSpec), (void**)&TAI_ExtRewSpec, 0, 0, 0,1);
TypeDef TA_DaModUnit_ptr("DaModUnit_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_ExtRewSpec("const_ExtRewSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ExtRewSpec_ref("const_ExtRewSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ExtRewLayerSpec("ExtRewLayerSpec", " computes external rewards: minus phase is zero, plus phase is reward value derived from network performance or other inputs (computed at start of 1+)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(ExtRewLayerSpec), (void**)&TAI_ExtRewLayerSpec, 1, 0, 0,1);
TypeDef TA_const_ExtRewLayerSpec("const_ExtRewLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ExtRewLayerSpec_ref("const_ExtRewLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ExtRew_Stat("ExtRew_Stat", " external reward statistic", 
	"EXT_proc COMPUTE_IN_TrialProcess FINAL_STAT ", "EXT_proc COMPUTE_IN_TrialProcess FINAL_STAT ", "", sizeof(ExtRew_Stat), (void**)&TAI_ExtRew_Stat, 1, 0, 0,1);
TypeDef TA_const_ExtRew_Stat("const_ExtRew_Stat", 1, 0, 0, 0,1);
TypeDef TA_const_ExtRew_Stat_ref("const_ExtRew_Stat_ref", 1, 0, 1, 0,1);
TypeDef TA_TDRewPredConSpec("TDRewPredConSpec", " Reward Prediction connections: for TD RewPred Layer, uses TD algorithm for predicting rewards", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(TDRewPredConSpec), (void**)&TAI_TDRewPredConSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewPredConSpec("const_TDRewPredConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_TDRewPredConSpec_ref("const_TDRewPredConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_TDRewPredLayerSpec("TDRewPredLayerSpec", " simulates ABL (amygdala): predicts rewards: minus phase = clamped prior expected reward V^(t), plus = settles on expectation of future reward V^(t+1)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(TDRewPredLayerSpec), (void**)&TAI_TDRewPredLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewPredLayerSpec("const_TDRewPredLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_TDRewPredLayerSpec_ref("const_TDRewPredLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_TDRewIntegSpec("TDRewIntegSpec", " misc specs for TDRewIntegLayerSpec", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(TDRewIntegSpec), (void**)&TAI_TDRewIntegSpec, 0, 0, 0,1);
TypeDef TA_const_TDRewIntegSpec("const_TDRewIntegSpec", 1, 0, 0, 0,1);
TypeDef TA_const_TDRewIntegSpec_ref("const_TDRewIntegSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_TDRewIntegLayerSpec("TDRewIntegLayerSpec", " simulates NAc, delta over phases = DA td-like signal: integrates perceived and external rewards", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(TDRewIntegLayerSpec), (void**)&TAI_TDRewIntegLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewIntegLayerSpec("const_TDRewIntegLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_TDRewIntegLayerSpec_ref("const_TDRewIntegLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_TdLayerSpec("TdLayerSpec", " computes activation = temporal derivative (act_eq - act_m) of sending units in plus phases: note, act will go negative!", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(TdLayerSpec), (void**)&TAI_TdLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TdLayerSpec("const_TdLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_TdLayerSpec_ref("const_TdLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LVConSpec("LVConSpec", " learned value connection spec", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LVConSpec), (void**)&TAI_LVConSpec, 1, 0, 0,1);
TypeDef TA_const_LVConSpec("const_LVConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LVConSpec_ref("const_LVConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LVSpec("LVSpec", " specs for learning values", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(LVSpec), (void**)&TAI_LVSpec, 0, 0, 0,1);
TypeDef TA_const_LVSpec("const_LVSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LVSpec_ref("const_LVSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LVLayerSpec("LVLayerSpec", " simulates NAc: learns when values arise", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LVLayerSpec), (void**)&TAI_LVLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LVLayerSpec("const_LVLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_LVLayerSpec_ref("const_LVLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PVConSpec("PVConSpec", " perceived value layer: generalizes to stimuli associated with reward", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PVConSpec), (void**)&TAI_PVConSpec, 1, 0, 0,1);
TypeDef TA_const_PVConSpec("const_PVConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PVConSpec_ref("const_PVConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PVSpec("PVSpec", " specs for perceived value learning", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(PVSpec), (void**)&TAI_PVSpec, 0, 0, 0,1);
TypeDef TA_const_PVSpec("const_PVSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PVSpec_ref("const_PVSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PVLayerSpec("PVLayerSpec", " learns to perceive value based on inputs that are associated with rewards: simulates ABL (amygdala) as a fast-learning PV system", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PVLayerSpec), (void**)&TAI_PVLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PVLayerSpec("const_PVLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PVLayerSpec_ref("const_PVLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PVSLayerSpec("PVSLayerSpec", " slow version of PV layer spec: learns to perceive value (just a marker for layer; same functionality as PVLayerSpec)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PVSLayerSpec), (void**)&TAI_PVSLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PVSLayerSpec("const_PVSLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PVSLayerSpec_ref("const_PVSLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PVLVDaSpec("PVLVDaSpec", " specs for PVLV da parameters", 
	"", "INLINE NO_UPDATE_AFTER ", "", sizeof(PVLVDaSpec), (void**)&TAI_PVLVDaSpec, 0, 0, 0,1);
TypeDef TA_const_PVLVDaSpec("const_PVLVDaSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PVLVDaSpec_ref("const_PVLVDaSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PVLVDaLayerSpec("PVLVDaLayerSpec", " computes PVLV 'Da' signal: basic value is PV_fast - PV_slow, in plus_phase includes LV component (ER - LV), depending on da.mode", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PVLVDaLayerSpec), (void**)&TAI_PVLVDaLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PVLVDaLayerSpec("const_PVLVDaLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PVLVDaLayerSpec_ref("const_PVLVDaLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PatchLayerSpec("PatchLayerSpec", " simulates Patch as a cur PV layer", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PatchLayerSpec), (void**)&TAI_PatchLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PatchLayerSpec("const_PatchLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PatchLayerSpec_ref("const_PatchLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_SNcMiscSpec("SNcMiscSpec", " misc parameters for SNc layer", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SNcMiscSpec), (void**)&TAI_SNcMiscSpec, 0, 0, 0,1);
TypeDef TA_const_SNcMiscSpec("const_SNcMiscSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SNcMiscSpec_ref("const_SNcMiscSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_SNcLayerSpec("SNcLayerSpec", " computes PVLV 'Da' signal: if ExtRew: ExtRew - Cur; else Cur - Prev; modulated by Patch per-stripe Da signal. Note, act will go negative!", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(SNcLayerSpec), (void**)&TAI_SNcLayerSpec, 1, 0, 0,1);
TypeDef TA_const_SNcLayerSpec("const_SNcLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SNcLayerSpec_ref("const_SNcLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixConSpec("MatrixConSpec", " Learning of matrix input connections based on temporal-differences modulation of activation: da happens one time step later!", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(MatrixConSpec), (void**)&TAI_MatrixConSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixConSpec("const_MatrixConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixConSpec_ref("const_MatrixConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixBiasSpec("MatrixBiasSpec", " noise bias connection -- holds noise value separate from orig value", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(MatrixBiasSpec), (void**)&TAI_MatrixBiasSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixBiasSpec("const_MatrixBiasSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixBiasSpec_ref("const_MatrixBiasSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixUnitSpec("MatrixUnitSpec", " basal ganglia matrix units: fire actions or WM updates. modulated by da signals from NAc/Vta, Patch/SNc", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(MatrixUnitSpec), (void**)&TAI_MatrixUnitSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixUnitSpec("const_MatrixUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixUnitSpec_ref("const_MatrixUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ContrastSpec("ContrastSpec", " contrast enhancement of the GO units", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ContrastSpec), (void**)&TAI_ContrastSpec, 0, 0, 0,1);
TypeDef TA_const_ContrastSpec("const_ContrastSpec", 1, 0, 0, 0,1);
TypeDef TA_const_ContrastSpec_ref("const_ContrastSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixRndGoSpec("MatrixRndGoSpec", " matrix random GO firing to encourage exploration for non-productive stripes based on avg_go_da for that stripe (matrix_u->misc_1)", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(MatrixRndGoSpec), (void**)&TAI_MatrixRndGoSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoSpec("const_MatrixRndGoSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoSpec_ref("const_MatrixRndGoSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixRndGoThrSpec("MatrixRndGoThrSpec", " thresholds for matrix random Go firing to encourage exploration for non-productive stripes based on avg_go_da for that stripe (matrix_u->misc_1)", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(MatrixRndGoThrSpec), (void**)&TAI_MatrixRndGoThrSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoThrSpec("const_MatrixRndGoThrSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoThrSpec_ref("const_MatrixRndGoThrSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixMiscSpec("MatrixMiscSpec", " misc specs for the matrix layer", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(MatrixMiscSpec), (void**)&TAI_MatrixMiscSpec, 0, 0, 0,1);
TypeDef TA_LeabraUnit_Group_ptr("LeabraUnit_Group_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_MatrixMiscSpec("const_MatrixMiscSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixMiscSpec_ref("const_MatrixMiscSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MatrixLayerSpec("MatrixLayerSpec", " basal ganglia matrix layer: fire actions/WM updates, or nogo; PFC = gate in 1+ and 2+, MOTOR = gate in -", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(MatrixLayerSpec), (void**)&TAI_MatrixLayerSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixLayerSpec("const_MatrixLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MatrixLayerSpec_ref("const_MatrixLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_SNrThalLayerSpec("SNrThalLayerSpec", " computes activation = GO - NOGO from MatrixLayerSpec", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(SNrThalLayerSpec), (void**)&TAI_SNrThalLayerSpec, 1, 0, 0,1);
TypeDef TA_const_SNrThalLayerSpec("const_SNrThalLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SNrThalLayerSpec_ref("const_SNrThalLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PFCGateSpec("PFCGateSpec", " basal ganglia gating specifications", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(PFCGateSpec), (void**)&TAI_PFCGateSpec, 0, 0, 0,1);
TypeDef TA_const_PFCGateSpec("const_PFCGateSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PFCGateSpec_ref("const_PFCGateSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_PFCLayerSpec("PFCLayerSpec", " Prefrontal cortex layer: gets gating signal from matrix, gate updates before each plus phase (toggle off, toggle on)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(PFCLayerSpec), (void**)&TAI_PFCLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PFCLayerSpec("const_PFCLayerSpec", 1, 0, 0, 0,1);
TypeDef TA_const_PFCLayerSpec_ref("const_PFCLayerSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LeabraWiz("LeabraWiz", " Leabra-specific wizard for automating construction of simulation objects", 
	"BUTROWS_2 EDIT_WIDTH_60 ", "BUTROWS_2 EDIT_WIDTH_60 ", "", sizeof(LeabraWiz), (void**)&TAI_LeabraWiz, 1, 0, 0,1);
TypeDef TA_const_LeabraWiz("const_LeabraWiz", 1, 0, 0, 0,1);
TypeDef TA_const_LeabraWiz_ref("const_LeabraWiz_ref", 1, 0, 1, 0,1);

// Instances

LeabraCon*		 TAI_LeabraCon=NULL;
LeabraConSpec*		 TAI_LeabraConSpec=NULL;
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtState((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Net((LeabraCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_WtFmLin((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_WtFmLin((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_LinFmWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_LinFmWt((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_LinFmWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_LinFmWt((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtState_Post((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_SAvgCor_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_SAvgCor((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->B_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_B_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->B_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnitSpec*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->SetCurLrate((int)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_CreateWtSigFun_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->CreateWtSigFun();
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_GraphWtSigFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->GraphWtSigFun((GraphLog*)(void*)*arg[1]);
    return rval;}
LeabraBiasSpec*		 TAI_LeabraBiasSpec=NULL;
LeabraCon_Group*		 TAI_LeabraCon_Group=NULL;
  static cssEl* cssElCFun_LeabraCon_Group_Compute_LinFmWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Compute_LinFmWt();
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Compute_WtFmLin_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Compute_WtFmLin();
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->C_InitWtState_Post((Connection*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->SetCurLrate((int)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Send_ClampNet((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Send_NetDelta((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->EncodeState((LeabraUnit*)(void*)*arg[1]);
    return rval;}
LeabraUnitSpec*		 TAI_LeabraUnitSpec=NULL;
  static cssEl* cssElCFun_LeabraUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitWtState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_Net((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Act((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssInt((int)((LeabraUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssInt((int)((LeabraUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->SetCurLrate((LeabraUnit*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitDelta((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetScale((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_ClampNet((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_NetDelta((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_InhibAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_HardClamp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_HardClampNoClip_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_HardClampNoClip((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnitSpec*)ths)->Compute_SoftClamp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThresh_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThresh((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoAH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoAH((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Conduct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Conduct((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Vm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Vm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_ActFmVm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_ActFmVm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SelfReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_SelfReg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->PhaseInit((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->DecayPhase((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->DecayEvent((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->ExtToComp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->TargExtToComp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4], (bool)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_dWt_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_dWt_impl((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_WtFmLin((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->EncodeState((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_CreateNXX1Fun_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->CreateNXX1Fun();
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_GraphVmFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_GraphActFmVmFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_GraphActFmNetFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]);}
    return rval;}
LeabraUnit*		 TAI_LeabraUnit=NULL;
  static cssEl* cssElCFun_LeabraUnit_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_Net((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->SetCurLrate((LeabraTrial*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_NetDelta((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_HardClampNoClip_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_HardClampNoClip((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit*)ths)->Compute_SoftClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_IThresh_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnit*)ths)->Compute_IThresh((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_IThreshNoAH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnit*)ths)->Compute_IThreshNoAH((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->PhaseInit((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->DecayEvent((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->DecayPhase((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->ExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->TargExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      ((LeabraUnit*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);}
    if(na == 4) {
      ((LeabraUnit*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3], (bool)*arg[4]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_WtFmLin((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->EncodeState((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_GetInSubGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->GetInSubGp();
    return rval;}
LeabraInhib*		 TAI_LeabraInhib=NULL;
  static cssEl* cssElCFun_LeabraInhib_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
LeabraLayerSpec*		 TAI_LeabraLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraLayerSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitWtState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->SetCurLrate((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Active_K_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Active_K((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Active_K_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    KWTASpec& refarg_3=*(KWTASpec*)arg[4]->GetVoidPtrOfType(&TA_KWTASpec);
    ((LeabraLayerSpec*)ths)->Compute_Active_K_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], refarg_3);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Pat_K_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayerSpec*)ths)->Compute_Pat_K((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_HardClampPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_HardClampPhase2((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_Net((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_NetDelta((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Clamp_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetAvg((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_SoftClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitInhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitInhib((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA_Avg((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA_Gps((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_LinkInhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_LinkInhib((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_InhibAvg_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_InhibAvg_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActMAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActMAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActMAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActMAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActPAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActPAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActPAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActPAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->PhaseInit((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayEvent((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayPhase((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayPhase2((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->ExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->TargExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);}
    if(na == 3) {
      ((LeabraLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_AdaptGBarI_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->AdaptGBarI((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_AdaptKWTAPt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->AdaptKWTAPt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_WtFmLin((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpec((LeabraLayer*)(void*)*arg[1], refarg_1, (TypeDef*)*arg[3]), 1, &TA_LeabraLayer);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpecExact_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpecExact((LeabraLayer*)(void*)*arg[1], refarg_1, (TypeDef*)*arg[3]), 1, &TA_LeabraLayer);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpecNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpecNet((Network*)(void*)*arg[1], (TypeDef*)*arg[2]), 1, &TA_LeabraLayer);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssInt((int)((LeabraLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Defaults();
    return rval;}
LeabraUnit_Group*		 TAI_LeabraUnit_Group=NULL;
  static cssEl* cssElCFun_LeabraUnit_Group_UnSafeCopy_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UnSafeCopy((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CastCopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->CastCopyTo((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetOwner_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->GetOwner(), 1, &TA_taBase);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath());}
    if(na == 1) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindFromPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      taString refarg_0=arg[1]->GetStr();
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(refarg_0), 1, &TA_taBase);    *arg[1]=(String)refarg_0;
}
    if(na == 2) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(refarg_0, refarg_1), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    if(na == 3) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(refarg_0, refarg_1, (int)*arg[3]), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_New_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New(), 1, &TA_taBase);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New((int)*arg[1]), 1, &TA_taBase);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taBase);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InheritsFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->InheritsFrom((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetEnumString_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraUnit_Group*)ths)->GetEnumString((const char*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetEnumVal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetEnumVal((const char*)*arg[1]));}
    if(na == 2) {
      taString refarg_1=arg[2]->GetStr();
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetEnumVal((const char*)*arg[1], refarg_1));    *arg[2]=(String)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Load_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0));}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Save_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SaveAs_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Edit_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->Edit());}
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->Edit((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CloseEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CloseEdit());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Close_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Close();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CopyFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CopyFrom((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CopyTo((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DuplicateMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->DuplicateMe());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChangeMyType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ChangeMyType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SelectForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SelectForEdit((MemberDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SelectFunForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SelectFunForEdit((MethodDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Help_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Help();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CallFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->CallFun((const char*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Alloc_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Alloc((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Reset_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Reset();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_IsEmpty_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->IsEmpty());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BuildHashTable_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BuildHashTable((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Find_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Find((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Remove_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Remove((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLast_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLast());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveAll_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->RemoveAll();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Move_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Move((int)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Swap_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Swap((int)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PopAll_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->PopAll();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Permute_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Permute();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Sort_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->Sort();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->Sort((bool)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Sort__stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->Sort_();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->Sort_((bool)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAllIndicies_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAllIndicies();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Duplicate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Duplicate(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DupeUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DupeUniqNameNew(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DupeUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DupeUniqNameOld(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Stealth_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Stealth_Borrow(*(taPtrList_impl*)arg[1]->GetVoidPtrOfType(&TA_taPtrList_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Borrow(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUnique(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUniqNameNew(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUniqNameOld(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Common_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Common(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Duplicate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Duplicate(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Borrow(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_List_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->List();}
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->List(refarg_0);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddEl((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Add_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Add((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->AddUnique((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->AddUniqNameNew((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Insert_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Insert((taBase*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Replace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Replace((int)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceName((const char*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DuplicateEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->DuplicateEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Link_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Link((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->LinkUnique((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->LinkUniqNameNew((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InsertLink_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->InsertLink((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->InsertLink((taBase*)(void*)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceLink((int)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLinkEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceLinkEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLinkName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceLinkName((const char*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Push_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Push((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->MoveEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Transfer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Transfer((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->MoveBefore((Unit*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->MoveAfter((Unit*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Dump_Save_PathR_impl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultElName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultElName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultElType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultElType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceSize_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceSize((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceType_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceType();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceSameStru_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceSameStru(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChangeType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ChangeType((taBase*)(void*)*arg[1], (TypeDef*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceType((TypeDef*)*arg[1], (TypeDef*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetBaseType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->SetBaseType((TypeDef*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReturnFindMd_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraUnit_Group*)ths)->ReturnFindMd(), 1, &TA_MemberDef);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InitLeafGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->InitLeafGp();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLeaf((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeafName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLeafName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeafEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLeafEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveGp((taGroup_impl*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EditSubGps_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->EditSubGps(), 1, &TA_TALOG);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceLeaves_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceLeaves((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindLeaf((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindLeafEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeEl((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastEl((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->DefaultEl(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Edit_El((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Leaf((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->LeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FirstEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NextEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl(), 1, &TA_Unit);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl((int)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_Unit);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindName((const char*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Pop(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Peek(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->AddUniqNameOld((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->LinkUniqNameOld((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Weights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Weights((const Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_WriteWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->WriteWeights(refarg_0);}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->WriteWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReadWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraUnit_Group*)ths)->ReadWeights(refarg_0);}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraUnit_Group*)ths)->ReadWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Build_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Build());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CheckBuild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CheckBuild());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LayoutUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->LayoutUnits();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->LayoutUnits((Unit*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RecomputeGeometry_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->RecomputeGeometry();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetUnitSpec((UnitSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetConSpec((ConSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_TransformWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->TransformWeights(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddNoiseToWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddNoiseToWeights(*(Random*)arg[1]->GetVoidPtrOfType(&TA_Random));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PruneCons_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->PruneCons(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec), (CountParam::Relation)(int)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LesionCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionCons((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LesionUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionUnits((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionUnits((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnitValuesToArray_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float_RArray& refarg_0=*(float_RArray*)arg[1]->GetVoidPtrOfType(&TA_float_RArray);
    ((LeabraUnit_Group*)ths)->UnitValuesToArray(refarg_0, (const char*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnitValuesFromArray_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float_RArray& refarg_0=*(float_RArray*)arg[1]->GetVoidPtrOfType(&TA_float_RArray);
    ((LeabraUnit_Group*)ths)->UnitValuesFromArray(refarg_0, (const char*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindUnitFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindUnitFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
LeabraLayer*		 TAI_LeabraLayer=NULL;
  static cssEl* cssElCFun_LeabraLayer_UnSafeCopy_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnSafeCopy((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CastCopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->CastCopyTo((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetOwner_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->GetOwner((TypeDef*)*arg[1]), 1, &TA_taBase);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath());}
    if(na == 1) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindFromPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      taString refarg_0=arg[1]->GetStr();
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(refarg_0), 1, &TA_taBase);    *arg[1]=(String)refarg_0;
}
    if(na == 2) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(refarg_0, refarg_1), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    if(na == 3) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(refarg_0, refarg_1, (int)*arg[3]), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_New_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New(), 1, &TA_taBase);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New((int)*arg[1]), 1, &TA_taBase);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taBase);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InheritsFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->InheritsFrom((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetEnumString_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraLayer*)ths)->GetEnumString((const char*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetEnumVal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->GetEnumVal((const char*)*arg[1]));}
    if(na == 2) {
      taString refarg_1=arg[2]->GetStr();
    rval=new cssInt((int)((LeabraLayer*)ths)->GetEnumVal((const char*)*arg[1], refarg_1));    *arg[2]=(String)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Load_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0));}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Save_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SaveAs_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Edit_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((LeabraLayer*)ths)->Edit());}
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->Edit((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CloseEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CloseEdit());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Close_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Close();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CopyFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CopyFrom((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CopyTo((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DuplicateMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->DuplicateMe());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ChangeMyType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ChangeMyType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SelectForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SelectForEdit((MemberDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SelectFunForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SelectFunForEdit((MethodDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Help_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Help();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CallFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->CallFun((const char*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Copy_Weights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Copy_Weights((const Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_WriteWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraLayer*)ths)->WriteWeights(refarg_0);}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraLayer*)ths)->WriteWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReadWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraLayer*)ths)->ReadWeights(refarg_0);}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraLayer*)ths)->ReadWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Build_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Build();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RecomputeGeometry_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RecomputeGeometry();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LayoutUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraLayer*)ths)->LayoutUnits();}
    if(na == 1) {
      ((LeabraLayer*)ths)->LayoutUnits((Unit*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LayoutUnitGroups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->LayoutUnitGroups();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Connect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Connect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckBuild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CheckBuild());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CheckConnect());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveCons_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveCons();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveUnits_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveUnits();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveUnitGroups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveUnitGroups();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PreConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->PreConnect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SyncSendPrjns_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SyncSendPrjns();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DisConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DisConnect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CountRecvCons_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CountRecvCons());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitExterns_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitExterns();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ModifyState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ModifyState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitWtDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitWtDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitWtState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitWtState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetToLay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetToLay((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetToMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetToMe();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Act((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateWeights();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_TransformWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->TransformWeights(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_AddNoiseToWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->AddNoiseToWeights(*(Random*)arg[1]->GetVoidPtrOfType(&TA_Random));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PruneCons_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->PruneCons(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec), (CountParam::Relation)(int)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ProbAddCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ProbAddCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ProbAddCons((float)*arg[1], (float)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LesionCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionCons((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LesionUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionUnits((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionUnits((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetLayerSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SetLayerSpec((LayerSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetLayerSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->GetLayerSpec(), 1, &TA_LayerSpec);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SetUnitSpec((UnitSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetUnitType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetUnitType((TypeDef*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SetConSpec((ConSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckTypes_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CheckTypes());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->CheckConfig((TrialProcess*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->CheckConfig((TrialProcess*)(void*)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FixPrjnIndexes_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->FixPrjnIndexes();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceUnitSpec((UnitSpec*)(void*)*arg[1], (UnitSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceConSpec((ConSpec*)(void*)*arg[1], (ConSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplacePrjnSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplacePrjnSpec((ProjectionSpec*)(void*)*arg[1], (ProjectionSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceLayerSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceLayerSpec((LayerSpec*)(void*)*arg[1], (LayerSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GridViewWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2]);}
    if(na == 3) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4]);}
    if(na == 5) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4], (int)*arg[5]);}
    if(na == 6) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4], (int)*arg[5], (int)*arg[6]);}
    if(na == 7) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4], (int)*arg[5], (int)*arg[6], (int)*arg[7]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_WeightsToEnv_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->WeightsToEnv((Environment*)(void*)*arg[1], (Layer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetExtFlag_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetExtFlag((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UnSetExtFlag_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnSetExtFlag((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitGpFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitGpFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit_Group);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetActGeomNoSpc_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    PosTDCoord& refarg_0=*(PosTDCoord*)arg[1]->GetVoidPtrOfType(&TA_PosTDCoord);
    ((LeabraLayer*)ths)->GetActGeomNoSpc(refarg_0);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitInhib_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitInhib();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetCurLrate((LeabraTrial*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Active_K_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Active_K();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_HardClamp((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_NetScale((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_ClampNet((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Clamp_NetAvg((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Inhib((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_InhibAvg((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->PhaseInit((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayEvent((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayPhase((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayPhase2((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ExtToComp((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->TargExtToComp((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraLayer*)ths)->PostSettle((LeabraTrial*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraLayer*)ths)->PostSettle((LeabraTrial*)(void*)*arg[1], (bool)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_WtFmLin((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ResetSortBuf();
    return rval;}
LeabraCycle*		 TAI_LeabraCycle=NULL;
  static cssEl* cssElCFun_LeabraCycle_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Clamp_NetAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_Inhib_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Inhib();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_InhibAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_InhibAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_Act_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Act();
    return rval;}
LeabraSettle*		 TAI_LeabraSettle=NULL;
  static cssEl* cssElCFun_LeabraSettle_Compute_Active_K_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_Active_K();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_DecayEvent_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->DecayEvent();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_DecayPhase_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->DecayPhase();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_DecayPhase2_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->DecayPhase2();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_PhaseInit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->PhaseInit();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_ExtToComp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->ExtToComp();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_TargExtToComp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->TargExtToComp();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_HardClamp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_HardClamp();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_NetScale_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_NetScale();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Send_ClampNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Send_ClampNet();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_PostSettle_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->PostSettle();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_PostSettle_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->PostSettle_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_dWt_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_dWt_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->UpdateWeights();
    return rval;}
LeabraTrial*		 TAI_LeabraTrial=NULL;
  static cssEl* cssElCFun_LeabraTrial_GenCntrLog_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->GenCntrLog((LogData*)(void*)*arg[1], (bool)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_InitState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->InitState();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_SetCurLrate_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->SetCurLrate();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_DecayState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->DecayState();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_EncodeState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->EncodeState();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_Compute_dWt_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->Compute_dWt_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->UpdateWeights();
    return rval;}
LeabraMaxDa*		 TAI_LeabraMaxDa=NULL;
  static cssEl* cssElCFun_LeabraMaxDa_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaxDa*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraMaxDa_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaxDa*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraMaxDa_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaxDa*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
WtScaleSpec*		 TAI_WtScaleSpec=NULL;
  static cssEl* cssElCFun_WtScaleSpec_NetScale_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtScaleSpec*)ths)->NetScale());
    return rval;}
WtSigSpec*		 TAI_WtSigSpec=NULL;
  static cssEl* cssElCFun_WtSigSpec_SigFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtSigSpec*)ths)->SigFun((float)*arg[1], (float)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_WtSigSpec_SigFunInv_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtSigSpec*)ths)->SigFunInv((float)*arg[1], (float)*arg[2], (float)*arg[3]));
    return rval;}
LearnMixSpec*		 TAI_LearnMixSpec=NULL;
FixedSAvg*		 TAI_FixedSAvg=NULL;
  static cssEl* cssElCFun_FixedSAvg_GetSAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FixedSAvg*)ths)->GetSAvg((float)*arg[1]));
    return rval;}
SAvgCorSpec*		 TAI_SAvgCorSpec=NULL;
ActFunSpec*		 TAI_ActFunSpec=NULL;
SpikeFunSpec*		 TAI_SpikeFunSpec=NULL;
DepressSpec*		 TAI_DepressSpec=NULL;
OptThreshSpec*		 TAI_OptThreshSpec=NULL;
DtSpec*		 TAI_DtSpec=NULL;
LeabraChannels*		 TAI_LeabraChannels=NULL;
VChanSpec*		 TAI_VChanSpec=NULL;
  static cssEl* cssElCFun_VChanSpec_UpdateBasis_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float refarg_0=(float)*arg[1];    bool refarg_1=(bool)*arg[2];    float refarg_2=(float)*arg[3];
    ((VChanSpec*)ths)->UpdateBasis(refarg_0, refarg_1, refarg_2, (float)*arg[4]);
    *arg[1]=(Real)refarg_0;    *arg[2]=(Int)refarg_1;    *arg[3]=(Real)refarg_2;
    return rval;}
PhaseSharpSpec*		 TAI_PhaseSharpSpec=NULL;
ActRegSpec*		 TAI_ActRegSpec=NULL;
VChanBasis*		 TAI_VChanBasis=NULL;
LeabraUnitChans*		 TAI_LeabraUnitChans=NULL;
taPtrList<LeabraUnit>*		 TAI_taPtrList_LeabraUnit_=NULL;
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Find_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Find((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Remove_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Remove((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->SafeEl((int)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FastEl((int)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Edit_El((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FindName((const char*)*arg[1]), 1, &TA_LeabraUnit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_LeabraUnit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Pop(), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Peek(), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->AddUniqNameOld((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->LinkUniqNameOld((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FindEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->FindEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->AddEl((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Add_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Add((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->AddUnique((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->AddUniqNameNew((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Insert_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Insert((LeabraUnit*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Replace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Replace((int)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceName((const char*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__RemoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->RemoveEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__DuplicateEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->DuplicateEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Link_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Link((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->LinkUnique((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->LinkUniqNameNew((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__InsertLink_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->InsertLink((LeabraUnit*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->InsertLink((LeabraUnit*)(void*)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceLink((int)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLinkEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceLinkEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLinkName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceLinkName((const char*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Push_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Push((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->MoveEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Transfer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Transfer((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->MoveBefore((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->MoveAfter((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
LeabraSort*		 TAI_LeabraSort=NULL;
  static cssEl* cssElCFun_LeabraSort_FindNewNetPos_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraSort*)ths)->FindNewNetPos((float)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraSort_FastInsertLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSort*)ths)->FastInsertLink((void*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
KWTASpec*		 TAI_KWTASpec=NULL;
AdaptISpec*		 TAI_AdaptISpec=NULL;
ClampSpec*		 TAI_ClampSpec=NULL;
DecaySpec*		 TAI_DecaySpec=NULL;
LayerLinkSpec*		 TAI_LayerLinkSpec=NULL;
SpecPtr<LeabraLayerSpec>*		 TAI_SpecPtr_LeabraLayerSpec_=NULL;
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__SetDefaultSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SpecPtr<LeabraLayerSpec>*)ths)->SetDefaultSpec((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__CheckSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((SpecPtr<LeabraLayerSpec>*)ths)->CheckSpec());
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__NewChild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((SpecPtr<LeabraLayerSpec>*)ths)->NewChild(), 1, &TA_LeabraLayerSpec);
    return rval;}
LeabraLayerSpec_SPtr*		 TAI_LeabraLayerSpec_SPtr=NULL;
AvgMaxVals*		 TAI_AvgMaxVals=NULL;
KWTAVals*		 TAI_KWTAVals=NULL;
  static cssEl* cssElCFun_KWTAVals_Compute_Pct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((KWTAVals*)ths)->Compute_Pct((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_KWTAVals_Compute_IThrR_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((KWTAVals*)ths)->Compute_IThrR();
    return rval;}
AdaptIVals*		 TAI_AdaptIVals=NULL;
InhibVals*		 TAI_InhibVals=NULL;
LayerLink*		 TAI_LayerLink=NULL;
taList<LayerLink>*		 TAI_taList_LayerLink_=NULL;
  static cssEl* cssElCFun_taList_LayerLink__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taList<LayerLink>*)ths)->MoveBefore((LayerLink*)(void*)*arg[1], (LayerLink*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taList<LayerLink>*)ths)->MoveAfter((LayerLink*)(void*)*arg[1], (LayerLink*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->SafeEl((int)*arg[1]), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->FastEl((int)*arg[1]), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->DefaultEl(), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->Edit_El((LayerLink*)(void*)*arg[1]), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->FindName((const char*)*arg[1]), 1, &TA_LayerLink);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_LayerLink);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_LayerLink);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_LayerLink);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->Pop(), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->Peek(), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->AddUniqNameOld((LayerLink*)(void*)*arg[1]), 1, &TA_LayerLink);
    return rval;}
  static cssEl* cssElCFun_taList_LayerLink__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taList<LayerLink>*)ths)->LinkUniqNameOld((LayerLink*)(void*)*arg[1]), 1, &TA_LayerLink);
    return rval;}
LayerLink_List*		 TAI_LayerLink_List=NULL;
LeabraSE_Stat*		 TAI_LeabraSE_Stat=NULL;
  static cssEl* cssElCFun_LeabraSE_Stat_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSE_Stat*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
LeabraAeSE_Stat*		 TAI_LeabraAeSE_Stat=NULL;
LeabraGoodStat*		 TAI_LeabraGoodStat=NULL;
  static cssEl* cssElCFun_LeabraGoodStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGoodStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraGoodStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGoodStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraGoodStat_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGoodStat*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
LeabraSharpStat*		 TAI_LeabraSharpStat=NULL;
  static cssEl* cssElCFun_LeabraSharpStat_Unit_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->Unit_Run((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraSharpStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraSharpStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraSharpStat_Layer_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->Layer_Stat((Layer*)(void*)*arg[1]);
    return rval;}
WrongOnStat*		 TAI_WrongOnStat=NULL;
  static cssEl* cssElCFun_WrongOnStat_Unit_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((WrongOnStat*)ths)->Unit_Run((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_WrongOnStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((WrongOnStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_WrongOnStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((WrongOnStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
ACRewSpec*		 TAI_ACRewSpec=NULL;
LeabraACLayerSpec*		 TAI_LeabraACLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraACLayerSpec_UpdateUnitGain_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraACLayerSpec*)ths)->UpdateUnitGain((LeabraUnitSpec*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraACLayerSpec_UpdateUnitErr_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraACLayerSpec*)ths)->UpdateUnitErr((LeabraUnitSpec*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
LeabraLinUnitSpec*		 TAI_LeabraLinUnitSpec=NULL;
CtxtUpdateSpec*		 TAI_CtxtUpdateSpec=NULL;
LeabraContextLayerSpec*		 TAI_LeabraContextLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraContextLayerSpec_Compute_Context_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraContextLayerSpec*)ths)->Compute_Context((LeabraLayer*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
GateSpec*		 TAI_GateSpec=NULL;
GateNoiseSpec*		 TAI_GateNoiseSpec=NULL;
LeabraGatedCtxLayerSpec*		 TAI_LeabraGatedCtxLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraGatedCtxLayerSpec_FindACLayer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraGatedCtxLayerSpec*)ths)->FindACLayer((LeabraLayer*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraGatedCtxLayerSpec_Get_TD_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraGatedCtxLayerSpec*)ths)->Get_TD((LeabraLayer*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraGatedCtxLayerSpec_Get_RewReset_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraGatedCtxLayerSpec*)ths)->Get_RewReset((LeabraLayer*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraGatedCtxLayerSpec_UpdateConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGatedCtxLayerSpec*)ths)->UpdateConSpec((LeabraConSpec*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraGatedCtxLayerSpec_UndoHardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGatedCtxLayerSpec*)ths)->UndoHardClamp((LeabraLayer*)(void*)*arg[1]);
    return rval;}
LeabraACMaintLayerSpec*		 TAI_LeabraACMaintLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraACMaintLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraACMaintLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LeabraACMaintLayerSpec_FindACLayer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraACMaintLayerSpec*)ths)->FindACLayer((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraACMaintLayerSpec_Get_TD_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraACMaintLayerSpec*)ths)->Get_TD((LeabraLayer*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraACMaintLayerSpec_Get_RewReset_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraACMaintLayerSpec*)ths)->Get_RewReset((LeabraLayer*)(void*)*arg[1]));
    return rval;}
PhaseOrderEventSpec*		 TAI_PhaseOrderEventSpec=NULL;
LeabraTimeUnit*		 TAI_LeabraTimeUnit=NULL;
LeabraTimeUnitSpec*		 TAI_LeabraTimeUnitSpec=NULL;
  static cssEl* cssElCFun_LeabraTimeUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTimeUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraTimeUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTimeUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraTimeUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTimeUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraTimeUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssInt((int)((LeabraTimeUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssInt((int)((LeabraTimeUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
LeabraTimeCon_Group*		 TAI_LeabraTimeCon_Group=NULL;
TimeMixSpec*		 TAI_TimeMixSpec=NULL;
LeabraTimeConSpec*		 TAI_LeabraTimeConSpec=NULL;
  static cssEl* cssElCFun_LeabraTimeConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTimeConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraTimeConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTimeConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraTimeConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraTimeConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
LeabraNegBiasSpec*		 TAI_LeabraNegBiasSpec=NULL;
LeabraMaintConSpec*		 TAI_LeabraMaintConSpec=NULL;
  static cssEl* cssElCFun_LeabraMaintConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaintConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraMaintConSpec_C_Switch_Maint_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaintConSpec*)ths)->C_Switch_Maint((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
LeabraNetConSpec*		 TAI_LeabraNetConSpec=NULL;
  static cssEl* cssElCFun_LeabraNetConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraNetConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraNetConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraNetConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
PhaseDWtConSpec*		 TAI_PhaseDWtConSpec=NULL;
PhaseDWtUnitSpec*		 TAI_PhaseDWtUnitSpec=NULL;
LeabraTabledConSpec*		 TAI_LeabraTabledConSpec=NULL;
  static cssEl* cssElCFun_LeabraTabledConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTabledConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4], (float)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTabledConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_LookupDWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraTabledConSpec*)ths)->LookupDWt((float)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_LoadDWtTable_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    istream& refarg_0=*(istream*)*arg[1];
    ((LeabraTabledConSpec*)ths)->LoadDWtTable(refarg_0);
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_ListTable_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraTabledConSpec*)ths)->ListTable();}
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraTabledConSpec*)ths)->ListTable(refarg_0);}
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_ShiftNorm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTabledConSpec*)ths)->ShiftNorm((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_MulNorm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTabledConSpec*)ths)->MulNorm((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraTabledConSpec_Graph2DTable_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTabledConSpec*)ths)->Graph2DTable((GraphLog*)(void*)*arg[1]);
    return rval;}
TrialSynDepCon*		 TAI_TrialSynDepCon=NULL;
SynDepSpec*		 TAI_SynDepSpec=NULL;
TrialSynDepConSpec*		 TAI_TrialSynDepConSpec=NULL;
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TrialSynDepConSpec*)ths)->C_Compute_Net((TrialSynDepCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TrialSynDepConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Depress_Wt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Depress_Wt((TrialSynDepCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Depress_Wt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Depress_Wt((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Reset_EffWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Reset_EffWt((TrialSynDepCon*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Reset_EffWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Reset_EffWt((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
FastWtCon*		 TAI_FastWtCon=NULL;
FastWtSpec*		 TAI_FastWtSpec=NULL;
FastWtConSpec*		 TAI_FastWtConSpec=NULL;
  static cssEl* cssElCFun_FastWtConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_UpdateWeights((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowHebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FastWtConSpec*)ths)->C_Compute_SlowHebb((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowErr_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FastWtConSpec*)ths)->C_Compute_SlowErr((FastWtCon*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowdWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_SlowdWt((FastWtCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_FastDecay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_FastDecay((FastWtCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]);
    return rval;}
LeabraNewHebbConSpec*		 TAI_LeabraNewHebbConSpec=NULL;
  static cssEl* cssElCFun_LeabraNewHebbConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNewHebbConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAorg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraNewHebbConSpec*)ths)->C_Compute_Hebb_CPCAorg((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAsimp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraNewHebbConSpec*)ths)->C_Compute_Hebb_CPCAsimp((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraNewHebbConSpec_C_Compute_Hebb_SinXY_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraNewHebbConSpec*)ths)->C_Compute_Hebb_SinXY((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraNewHebbConSpec_GraphHebb_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraNewHebbConSpec*)ths)->GraphHebb((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraNewHebbConSpec*)ths)->GraphHebb((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraNewHebbConSpec*)ths)->GraphHebb((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    return rval;}
SigAmpSpec*		 TAI_SigAmpSpec=NULL;
  static cssEl* cssElCFun_SigAmpSpec_WriteToFile_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ostream& refarg_0=*(ostream*)*arg[1];
    ((SigAmpSpec*)ths)->WriteToFile(refarg_0);
    return rval;}
  static cssEl* cssElCFun_SigAmpSpec_ReadFromFile_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    istream& refarg_0=*(istream*)*arg[1];
    ((SigAmpSpec*)ths)->ReadFromFile(refarg_0);
    return rval;}
LeabraSigHebbConSpec*		 TAI_LeabraSigHebbConSpec=NULL;
  static cssEl* cssElCFun_LeabraSigHebbConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSigHebbConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraSigHebbConSpec_WriteToFile_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraSigHebbConSpec*)ths)->WriteToFile(refarg_0);
    return rval;}
  static cssEl* cssElCFun_LeabraSigHebbConSpec_ReadFromFile_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    istream& refarg_0=*(istream*)*arg[1];
    ((LeabraSigHebbConSpec*)ths)->ReadFromFile(refarg_0);
    return rval;}
  static cssEl* cssElCFun_LeabraSigHebbConSpec_GraphHebb_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraSigHebbConSpec*)ths)->GraphHebb((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraSigHebbConSpec*)ths)->GraphHebb((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraSigHebbConSpec*)ths)->GraphHebb((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    return rval;}
ScalarValSpec*		 TAI_ScalarValSpec=NULL;
  static cssEl* cssElCFun_ScalarValSpec_InitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSpec*)ths)->InitVal((float)*arg[1], (int)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSpec_GetUnitAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValSpec*)ths)->GetUnitAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_ScalarValSpec_GetUnitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValSpec*)ths)->GetUnitVal((int)*arg[1]));
    return rval;}
ScalarValBias*		 TAI_ScalarValBias=NULL;
ScalarValLayerSpec*		 TAI_ScalarValLayerSpec=NULL;
  static cssEl* cssElCFun_ScalarValLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ClampValue_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((ScalarValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);}
    if(na == 3) {
      ((ScalarValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ClampAvgAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValLayerSpec*)ths)->ClampAvgAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ReadValue_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValLayerSpec*)ths)->ReadValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ResetAfterClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->ResetAfterClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_HardClampExt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->HardClampExt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnits_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnits_impl((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnits_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnits((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnitsNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnitsNet((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_WtBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_WtBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_NegSlp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_NegSlp((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_PosSlp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_PosSlp((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_BiasVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_BiasVal((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ReConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((ScalarValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((ScalarValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
ScalarValSelfPrjnSpec*		 TAI_ScalarValSelfPrjnSpec=NULL;
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_Connect_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->Connect_impl((Projection*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->C_InitWtState((Projection*)(void*)*arg[1], (Con_Group*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_Connect_UnitGroup_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->Connect_UnitGroup((Unit_Group*)(void*)*arg[1], (Projection*)(void*)*arg[2]);
    return rval;}
MarkerConSpec*		 TAI_MarkerConSpec=NULL;
  static cssEl* cssElCFun_MarkerConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MarkerConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
DaModUnit*		 TAI_DaModUnit=NULL;
DaModSpec*		 TAI_DaModSpec=NULL;
DaModUnitSpec*		 TAI_DaModUnitSpec=NULL;
  static cssEl* cssElCFun_DaModUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssInt((int)((DaModUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssInt((int)((DaModUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
AvgExtRewSpec*		 TAI_AvgExtRewSpec=NULL;
OutErrSpec*		 TAI_OutErrSpec=NULL;
ExtRewSpec*		 TAI_ExtRewSpec=NULL;
ExtRewLayerSpec*		 TAI_ExtRewLayerSpec=NULL;
  static cssEl* cssElCFun_ExtRewLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_OutErrRewAvail_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((ExtRewLayerSpec*)ths)->OutErrRewAvail((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_GetOutErrRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ExtRewLayerSpec*)ths)->GetOutErrRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_OutErrRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_OutErrRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_ExtRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_ExtRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_DaRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_DaRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_UnitDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_UnitDa((float)*arg[1], (DaModUnit*)(void*)*arg[2], (Unit_Group*)(void*)*arg[3], (LeabraLayer*)(void*)*arg[4], (LeabraTrial*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_NoRewAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_NoRewAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
ExtRew_Stat*		 TAI_ExtRew_Stat=NULL;
  static cssEl* cssElCFun_ExtRew_Stat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRew_Stat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ExtRew_Stat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRew_Stat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
TDRewPredConSpec*		 TAI_TDRewPredConSpec=NULL;
  static cssEl* cssElCFun_TDRewPredConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TDRewPredConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (DaModUnit*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3]));
    return rval;}
TDRewPredLayerSpec*		 TAI_TDRewPredLayerSpec=NULL;
  static cssEl* cssElCFun_TDRewPredLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_SavePred_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_SavePred((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ClampPred_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ClampPred((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ClampPrev_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ClampPrev((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_TdPlusPhase_impl((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_TdPlusPhase((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
TDRewIntegSpec*		 TAI_TDRewIntegSpec=NULL;
TDRewIntegLayerSpec*		 TAI_TDRewIntegLayerSpec=NULL;
  static cssEl* cssElCFun_TDRewIntegLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->HelpConfig();
    return rval;}
TdLayerSpec*		 TAI_TdLayerSpec=NULL;
  static cssEl* cssElCFun_TdLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_Td_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_Td((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Send_Td_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Send_Td((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
LVConSpec*		 TAI_LVConSpec=NULL;
  static cssEl* cssElCFun_LVConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LVConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]));
    return rval;}
LVSpec*		 TAI_LVSpec=NULL;
LVLayerSpec*		 TAI_LVLayerSpec=NULL;
  static cssEl* cssElCFun_LVLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LVLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LVLayerSpec_Compute_ExtRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    bool refarg_2=(bool)*arg[3];    bool refarg_3=(bool)*arg[4];
    rval=new cssReal((double)((LVLayerSpec*)ths)->Compute_ExtRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], refarg_2, refarg_3));
    *arg[3]=(Int)refarg_2;    *arg[4]=(Int)refarg_3;
    return rval;}
  static cssEl* cssElCFun_LVLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVLayerSpec_Compute_dWtUgp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVLayerSpec*)ths)->Compute_dWtUgp((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LVLayerSpec_Compute_LVPlusPhaseDwt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVLayerSpec*)ths)->Compute_LVPlusPhaseDwt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PVConSpec*		 TAI_PVConSpec=NULL;
  static cssEl* cssElCFun_PVConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((PVConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]));
    return rval;}
PVSpec*		 TAI_PVSpec=NULL;
PVLayerSpec*		 TAI_PVLayerSpec=NULL;
  static cssEl* cssElCFun_PVLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PVLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PVLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLayerSpec_Compute_dWtUgp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLayerSpec*)ths)->Compute_dWtUgp((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_PVLayerSpec_Compute_DepressWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLayerSpec*)ths)->Compute_DepressWt((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_PVLayerSpec_Compute_PVPlusPhaseDwt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLayerSpec*)ths)->Compute_PVPlusPhaseDwt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PVSLayerSpec*		 TAI_PVSLayerSpec=NULL;
PVLVDaSpec*		 TAI_PVLVDaSpec=NULL;
PVLVDaLayerSpec*		 TAI_PVLVDaLayerSpec=NULL;
  static cssEl* cssElCFun_PVLVDaLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_Da((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Send_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Send_Da((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PatchLayerSpec*		 TAI_PatchLayerSpec=NULL;
SNcMiscSpec*		 TAI_SNcMiscSpec=NULL;
SNcLayerSpec*		 TAI_SNcLayerSpec=NULL;
  static cssEl* cssElCFun_SNcLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNcLayerSpec*)ths)->HelpConfig();
    return rval;}
MatrixConSpec*		 TAI_MatrixConSpec=NULL;
  static cssEl* cssElCFun_MatrixConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MatrixConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3], (DaModUnit*)(void*)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_MatrixConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MatrixConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (DaModUnit*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3]));
    return rval;}
MatrixBiasSpec*		 TAI_MatrixBiasSpec=NULL;
MatrixUnitSpec*		 TAI_MatrixUnitSpec=NULL;
ContrastSpec*		 TAI_ContrastSpec=NULL;
MatrixRndGoSpec*		 TAI_MatrixRndGoSpec=NULL;
MatrixRndGoThrSpec*		 TAI_MatrixRndGoThrSpec=NULL;
MatrixMiscSpec*		 TAI_MatrixMiscSpec=NULL;
MatrixLayerSpec*		 TAI_MatrixLayerSpec=NULL;
  static cssEl* cssElCFun_MatrixLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_RndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_RndGo((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_ClearRndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_ClearRndGo((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaModUnit_NoContrast_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaModUnit_NoContrast((DaModUnit*)(void*)*arg[1], (float)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaModUnit_Contrast_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaModUnit_Contrast((DaModUnit*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (int)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaTonicMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaTonicMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaPerfMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaPerfMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaLearnMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaLearnMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_AvgGODA_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_AvgGODA((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
SNrThalLayerSpec*		 TAI_SNrThalLayerSpec=NULL;
  static cssEl* cssElCFun_SNrThalLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_Compute_GoNogoNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->Compute_GoNogoNet((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PFCGateSpec*		 TAI_PFCGateSpec=NULL;
PFCLayerSpec*		 TAI_PFCLayerSpec=NULL;
  static cssEl* cssElCFun_PFCLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_ResetSynDep_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->ResetSynDep((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_MaintUpdt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_MaintUpdt((LeabraUnit_Group*)(void*)*arg[1], (PFCLayerSpec::MaintUpdtAct)(int)*arg[2], (LeabraLayer*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_SendGateStates_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->SendGateStates((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_TmpClear_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_TmpClear((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_GatingTrans_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_GatingTrans((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_GatingGOGO_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_GatingGOGO((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
LeabraWiz*		 TAI_LeabraWiz=NULL;
  static cssEl* cssElCFun_LeabraWiz_StdNetwork_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraWiz*)ths)->StdNetwork();}
    if(na == 1) {
      ((LeabraWiz*)ths)->StdNetwork((Network*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_StdLayerSpecs_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWiz*)ths)->StdLayerSpecs((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_SRNContext_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWiz*)ths)->SRNContext((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_UnitInhib_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->UnitInhib((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->UnitInhib((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_TD_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->TD((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->TD((Network*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->TD((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_PVLV_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4]);}
    if(na == 5) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_BgPFC_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3], (bool)*arg[4]);}
    if(na == 5) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5]);}
    if(na == 6) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6]);}
    if(na == 7) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7]);}
    if(na == 8) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7], (bool)*arg[8]);}
    if(na == 9) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (int)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7], (bool)*arg[8], (bool)*arg[9]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_SetPFCStripes_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraWiz*)ths)->SetPFCStripes((Network*)(void*)*arg[1], (int)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->SetPFCStripes((Network*)(void*)*arg[1], (int)*arg[2], (int)*arg[3]);}
    return rval;}

// Type Data

static int LeabraCon::* TA_LeabraCon_MbrOff;
static MemberDef_data TA_LeabraCon_MemberDef[]={
  {&TA_float,NULL,"dwt"," resulting net weight change","NO_VIEW NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_MbrOff=(int LeabraCon::*)(&LeabraCon::dwt))),0,NULL,0},
  {&TA_float,NULL,"pdw"," previous delta-weight change","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_MbrOff=(int LeabraCon::*)(&LeabraCon::pdw))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraConSpec_LRSValue[]={
  {"NO_LRS"," don't use a learning rate schedule","",0},
  {"EPOCH"," current epoch counter","",1},
  {"SE_STAT"," LeabraSE_Stat value at epoch-level (in process above epoch)","",2},
  {"EXT_REW_STAT"," ExtRew_Stat value at epoch-level (in process above epoch): value is * 100 (0..100) ","",3},
  {"EXT_REW_AVG"," uses average reward computed by ExtRew layer (if present): value is units[0].act_avg (avg_rew) * 100 (0..100) ","",4},
  NULL};
static int LeabraConSpec::* TA_LeabraConSpec_MbrOff;
static MemberDef_data TA_LeabraConSpec_MemberDef[]={
  {&TA_bool,NULL,"inhib"," makes the connection inhibitory (to g_i instead of net)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::inhib))),0,NULL,0},
  {&TA_WtScaleSpec,NULL,"wt_scale"," scale weight values, both relative and absolute factors","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_scale))),0,NULL,0},
  {&TA_WtSigSpec,NULL,"wt_sig"," sigmoidal weight function for contrast enhancement: high gain makes weights more binary & discriminative","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig))),0,NULL,0},
  {&TA_float,NULL,"lrate"," learning rate -- how fast do the weights change per experience","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrate))),0,NULL,0},
  {&TA_float,NULL,"cur_lrate"," current actual learning rate = lrate * lrate_sched current value (* 1 if no lrate_sched)","READ_ONLY NO_INHERIT SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::cur_lrate))),0,NULL,0},
  {NULL,"::LRSValue","lrs_value"," what value to drive the learning rate schedule with (Important: affects values entered in start_ctr fields of schedule!)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrs_value))),0,NULL,0},
  {&TA_Schedule,NULL,"lrate_sched"," schedule of learning rate over training epochs (multiplies lrate!)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrate_sched))),0,NULL,0},
  {&TA_LearnMixSpec,NULL,"lmix"," mixture of hebbian & err-driven learning","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lmix))),0,NULL,0},
  {&TA_FixedSAvg,NULL,"fix_savg"," how to normalize the computation of average net input: fixed sending avg act value for normalizing netin","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::fix_savg))),0,NULL,0},
  {&TA_SAvgCorSpec,NULL,"savg_cor"," for Hebbian: correction for sending average act levels (i.e., renormalization)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::savg_cor))),0,NULL,0},
  {&TA_FunLookup,NULL,"wt_sig_fun"," computes wt sigmoidal fun","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun))),0,NULL,0},
  {&TA_FunLookup,NULL,"wt_sig_fun_inv"," computes inverse of wt sigmoidal fun","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_inv))),0,NULL,0},
  {&TA_WtSigSpec,NULL,"wt_sig_fun_lst"," last values of wt sig parameters for which the wt_sig_fun's were computed; prevents excessive updating","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_lst))),0,NULL,0},
  {&TA_float,NULL,"wt_sig_fun_res"," last values of resolution parameters for which the wt_sig_fun's were computed","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_res))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtState_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Net_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"gp",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_LinFmWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_LinFmWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"gp",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtState_Post_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Connection_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_SAvgCor_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"na",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"su_act_m",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_B_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_B_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_GraphWtSigFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  NULL};
static MethodDef_data TA_LeabraConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtState","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtState_stub,TA_LeabraConSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtDelta_stub,TA_LeabraConSpec_C_InitWtDelta_MethArgs},
  {&TA_float,NULL,"C_Compute_Net","","","",
    1,3,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Net_stub,TA_LeabraConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_Net_stub,TA_LeabraConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_Net_stub,TA_LeabraConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_Net_stub,TA_LeabraConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_dWt_stub,TA_LeabraConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_dWt_stub,TA_LeabraConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights","","","",
    1,5,-1,0,NULL,cssElCFun_LeabraConSpec_C_UpdateWeights_stub,TA_LeabraConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_UpdateWeights_stub,TA_LeabraConSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"C_Compute_WtFmLin"," weight is negative if it is in its linear form, only perform if negative","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_WtFmLin_stub,TA_LeabraConSpec_C_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," compute actual weight value from linear weight value","","",
    0,1,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_WtFmLin_stub,TA_LeabraConSpec_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"C_Compute_LinFmWt"," weight is negative if it is in its linear form, only perform if positive","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_LinFmWt_stub,TA_LeabraConSpec_C_Compute_LinFmWt_MethArgs},
  {&TA_void,NULL,"Compute_LinFmWt"," compute linear weight value from actual weight value","","",
    0,1,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_LinFmWt_stub,TA_LeabraConSpec_Compute_LinFmWt_MethArgs},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtState_Post_stub,TA_LeabraConSpec_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"C_Send_Inhib","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_Inhib_stub,TA_LeabraConSpec_C_Send_Inhib_MethArgs},
  {&TA_void,NULL,"Send_Inhib"," sender-based inhibitiory net input computation","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_Inhib_stub,TA_LeabraConSpec_Send_Inhib_MethArgs},
  {&TA_void,NULL,"C_Send_NetDelta","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_NetDelta_stub,TA_LeabraConSpec_C_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," sender-based delta net input computation (send_delta mode only)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_NetDelta_stub,TA_LeabraConSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"C_Send_InhibDelta","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_InhibDelta_stub,TA_LeabraConSpec_C_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"Send_InhibDelta"," sender-based delta inhibitiory net input computation (send_delta mode only)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_InhibDelta_stub,TA_LeabraConSpec_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"C_Send_ClampNet","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_ClampNet_stub,TA_LeabraConSpec_C_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," sender-based net input computation for clamp net","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_ClampNet_stub,TA_LeabraConSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Compute_SAvgCor"," compute hebb correction scaling terms for sending average act, returns inc cor, and dec cor","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_SAvgCor_stub,TA_LeabraConSpec_Compute_SAvgCor_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," compute Hebbian associative learning","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Hebb_stub,TA_LeabraConSpec_C_Compute_Hebb_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    0,5,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Err_stub,TA_LeabraConSpec_C_Compute_Err_MethArgs},
  {&TA_void,NULL,"B_Compute_dWt"," compute bias weight change for netin model of bias weight","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_B_Compute_dWt_stub,TA_LeabraConSpec_B_Compute_dWt_MethArgs},
  {&TA_void,NULL,"B_UpdateWeights","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraConSpec_B_UpdateWeights_stub,TA_LeabraConSpec_B_UpdateWeights_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on schedule given epoch (or error value)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_SetCurLrate_stub,TA_LeabraConSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"CreateWtSigFun"," create the wt_sig_fun and wt_sig_fun_inv","","",
    0,0,-1,0,NULL,cssElCFun_LeabraConSpec_CreateWtSigFun_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraConSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"GraphWtSigFun"," graph the sigmoidal weight contrast enhancement function (NULL = new graph log)","BUTTON NULL_OK ","",
    0,1,-1,0,NULL,cssElCFun_LeabraConSpec_GraphWtSigFun_stub,TA_LeabraConSpec_GraphWtSigFun_MethArgs},
  NULL};
static int LeabraBiasSpec::* TA_LeabraBiasSpec_MbrOff;
static MemberDef_data TA_LeabraBiasSpec_MemberDef[]={
  {&TA_float,NULL,"dwt_thresh"," don't change if dwt < thresh, prevents buildup of small changes","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_LeabraBiasSpec_MbrOff=(int LeabraBiasSpec::*)(&LeabraBiasSpec::dwt_thresh))),0,NULL,0},
  NULL};
static int LeabraCon_Group::* TA_LeabraCon_Group_MbrOff;
static MemberDef_data TA_LeabraCon_Group_MemberDef[]={
  {&TA_float,NULL,"scale_eff"," effective scale parameter for netin","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::scale_eff))),0,NULL,0},
  {&TA_float,NULL,"savg"," sending average activation","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::savg))),0,NULL,0},
  {&TA_float,NULL,"max_cor"," savg correction factor for cpca","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::max_cor))),0,NULL,0},
  {&TA_float,NULL,"net"," total (averaged) net input from all connections in group","","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::net))),0,NULL,0},
  {&TA_float,NULL,"p_savg"," previous sending average activation for time-based learning","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::p_savg))),0,NULL,0},
  {&TA_float,NULL,"p_max_cor"," previous savg correction factor for cpca for time-based learning","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::p_max_cor))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_C_InitWtState_Post_MethArgs[]={
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_Send_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_Send_NetDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_EncodeState_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_LeabraCon_Group_MethodDef[]={
  {&TA_void,NULL,"Compute_LinFmWt","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCon_Group_Compute_LinFmWt_stub,NULL},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCon_Group_Compute_WtFmLin_stub,NULL},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,3,-1,0,NULL,cssElCFun_LeabraCon_Group_C_InitWtState_Post_stub,TA_LeabraCon_Group_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraCon_Group_SetCurLrate_stub,TA_LeabraCon_Group_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraCon_Group_Send_ClampNet_stub,TA_LeabraCon_Group_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraCon_Group_Send_NetDelta_stub,TA_LeabraCon_Group_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"EncodeState"," encode current state information (for time-based learning)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraCon_Group_EncodeState_stub,TA_LeabraCon_Group_EncodeState_MethArgs},
  NULL};
static EnumDef_data TA_LeabraUnitSpec_ActFun[]={
  {"NOISY_XX1"," x over x plus 1 convolved with Gaussian noise (noise is nvar)","",0},
  {"XX1"," x over x plus 1, hard threshold, no noise convolution","",1},
  {"LINEAR"," simple linear output function (still thesholded)","",2},
  {"DEPRESS"," depressing synapses activation function (rate coded)","",3},
  {"SPIKE"," discrete spiking activations (spike when > thr)","",4},
  NULL};
static EnumDef_data TA_LeabraUnitSpec_NoiseType[]={
  {"NO_NOISE"," no noise added to processing","",0},
  {"VM_NOISE"," noise in the value of v_m (membrane potential)","",1},
  {"NETIN_NOISE"," noise in the net input (g_e)","",2},
  {"ACT_NOISE"," noise in the activations","",3},
  NULL};
static int LeabraUnitSpec::* TA_LeabraUnitSpec_MbrOff;
static MemberDef_data TA_LeabraUnitSpec_MemberDef[]={
  {NULL,"::ActFun","act_fun"," activation function to use","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act_fun))),0,NULL,0},
  {&TA_ActFunSpec,NULL,"act"," activation function specs","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act))),0,NULL,0},
  {&TA_SpikeFunSpec,NULL,"spike"," spiking function specs (only for act_fun = SPIKE)","CONDEDIT_ON_act_fun:SPIKE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::spike))),0,NULL,0},
  {&TA_DepressSpec,NULL,"depress"," depressing synapses activation function specs, note that act_range deterimines range of spk_amp spiking amplitude, max should be > 1","CONDEDIT_ON_act_fun:DEPRESS ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::depress))),0,NULL,0},
  {&TA_OptThreshSpec,NULL,"opt_thresh"," optimization thresholds for speeding up processing when units are basically inactive","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::opt_thresh))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"clamp_range"," range of clamped activation values (min, max, 0, .95 std), don't clamp to 1 because acts can't reach, so .95 instead","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::clamp_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"vm_range"," membrane potential range (min, max, 0-1 for normalized, -90-50 for bio-based)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::vm_range))),0,NULL,0},
  {&TA_Random,NULL,"v_m_init"," what to initialize the membrane potential to (mean = .15, var = 0 std)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::v_m_init))),0,NULL,0},
  {&TA_DtSpec,NULL,"dt"," time constants (rate of updating): membrane potential (vm) and net input (net)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::dt))),0,NULL,0},
  {&TA_LeabraChannels,NULL,"g_bar"," [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::g_bar))),0,NULL,0},
  {&TA_LeabraChannels,NULL,"e_rev"," [Defaults: 1, .15, .15, 1, 0] reversal potentials for each channel","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::e_rev))),0,NULL,0},
  {&TA_VChanSpec,NULL,"hyst"," [Defaults: .05, .8, .7, .1] hysteresis (excitatory) v-gated chan (Ca2+, NMDA)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::hyst))),0,NULL,0},
  {&TA_VChanSpec,NULL,"acc"," [Defaults: .01, .5, .1, .1] accomodation (inhibitory) v-gated chan (K+)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::acc))),0,NULL,0},
  {&TA_PhaseSharpSpec,NULL,"phase_sharp"," phase-based sharpening, makes activations sharper in plus phase as extra unsupervised learning signal","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::phase_sharp))),0,NULL,0},
  {&TA_ActRegSpec,NULL,"act_reg"," activity regulation via global scaling of weight values","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act_reg))),0,NULL,0},
  {NULL,"::NoiseType","noise_type"," where to add random noise in the processing (if at all)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_type))),0,NULL,0},
  {&TA_Random,NULL,"noise"," distribution parameters for random added noise","CONDEDIT_OFF_noise_type:NO_NOISE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise))),0,NULL,0},
  {&TA_Schedule,NULL,"noise_sched"," schedule of noise variance over settling cycles","CONDEDIT_OFF_noise_type:NO_NOISE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_sched))),0,NULL,0},
  {&TA_FunLookup,NULL,"nxx1_fun"," convolved gaussian and x/x+1 function as lookup table","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::nxx1_fun))),0,NULL,0},
  {&TA_FunLookup,NULL,"noise_conv"," gaussian for convolution","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_conv))),0,NULL,0},
  {&TA_float,NULL,"phase_delta"," external plus-minus phase dif (error signal), applied in post settle","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::phase_delta))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitWtState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_Net_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","0"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_SetCurLrate_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_HardClampNoClip_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThresh_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoAH_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Conduct_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Vm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_ActFmVm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SelfReg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_PhaseInit_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_DecayPhase_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_ExtToComp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_TargExtToComp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_PostSettle_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","0"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_dWt_impl_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_EncodeState_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_GraphVmFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"g_i"," .5"},
  {&TA_float,NULL,"min"," 0.0"},
  {&TA_float,NULL,"max"," 1.0"},
  {&TA_float,NULL,"incr"," .01"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_GraphActFmVmFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"min"," .15"},
  {&TA_float,NULL,"max"," .50"},
  {&TA_float,NULL,"incr"," .001"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_GraphActFmNetFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"g_i"," .5"},
  {&TA_float,NULL,"min"," 0.0"},
  {&TA_float,NULL,"max"," 1.0"},
  {&TA_float,NULL,"incr"," .001"},
  NULL};
static MethodDef_data TA_LeabraUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_InitState_stub,TA_LeabraUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"InitWtState"," init weight state variables","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_InitWtState_stub,TA_LeabraUnitSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Send_Net"," send net input to all units I send to add ext input, sender-based","","",
    2,2,-1,0,NULL,cssElCFun_LeabraUnitSpec_Send_Net_stub,TA_LeabraUnitSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act"," compute the final activation: calls following function steps","","",
    2,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Act_stub,TA_LeabraUnitSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    2,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_dWt_stub,TA_LeabraUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights from deltas","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_UpdateWeights_stub,TA_LeabraUnitSpec_UpdateWeights_MethArgs},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,4,3,0,NULL,cssElCFun_LeabraUnitSpec_CheckConfig_stub,TA_LeabraUnitSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on epoch","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_SetCurLrate_stub,TA_LeabraUnitSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"InitDelta","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_InitDelta_stub,TA_LeabraUnitSpec_InitDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," compute net input scaling values and input from hard-clamped inputs","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetScale_stub,TA_LeabraUnitSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," compute net input from hard-clamped inputs (sender based)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Send_ClampNet_stub,TA_LeabraUnitSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," //////////////////////////////////////////////////////////////","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnitSpec_Send_NetDelta_stub,TA_LeabraUnitSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg"," compute netin average","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetAvg_stub,TA_LeabraUnitSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," compute inhib netin average","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_InhibAvg_stub,TA_LeabraUnitSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," force units to external values provided by environment: also optimizes settling by only computing netinput once","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_HardClamp_stub,TA_LeabraUnitSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_HardClampNoClip"," hard-clamp units without clipping values to clamp_range (use for second plus phase clamping to settled values)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_HardClampNoClip_stub,TA_LeabraUnitSpec_Compute_HardClampNoClip_MethArgs},
  {&TA_bool,NULL,"Compute_SoftClamp"," soft-clamps unit, returns true if unit is not above .5","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SoftClamp_stub,TA_LeabraUnitSpec_Compute_SoftClamp_MethArgs},
  {&TA_float,NULL,"Compute_IThresh"," compute inhibitory value that would place unit directly at threshold","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThresh_stub,TA_LeabraUnitSpec_Compute_IThresh_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoAH"," compute inhibitory value that would place unit directly at threshold, excluding any gc.a, gc.h currents","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoAH_stub,TA_LeabraUnitSpec_Compute_IThreshNoAH_MethArgs},
  {&TA_void,NULL,"Compute_Conduct"," compute input conductance values in the gc variables","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Conduct_stub,TA_LeabraUnitSpec_Compute_Conduct_MethArgs},
  {&TA_void,NULL,"Compute_Vm"," compute the membrante potential from input conductances","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Vm_stub,TA_LeabraUnitSpec_Compute_Vm_MethArgs},
  {&TA_void,NULL,"Compute_ActFmVm"," compute the activation from membrane potential","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_ActFmVm_stub,TA_LeabraUnitSpec_Compute_ActFmVm_MethArgs},
  {&TA_void,NULL,"Compute_SelfReg"," compute self-regulatory currents (hysteresis, accommodation)","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SelfReg_stub,TA_LeabraUnitSpec_Compute_SelfReg_MethArgs},
  {&TA_void,NULL,"PhaseInit"," initialize external input flags based on phase","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_PhaseInit_stub,TA_LeabraUnitSpec_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayPhase"," decay activation states towards initial values: at phase-level boundary","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_DecayPhase_stub,TA_LeabraUnitSpec_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay activation states towards initial values: at event-level boundary","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_DecayEvent_stub,TA_LeabraUnitSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"ExtToComp"," change external inputs to comparisons (remove input)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_ExtToComp_stub,TA_LeabraUnitSpec_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp"," change target & external inputs to comparisons (remove targ & input)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_TargExtToComp_stub,TA_LeabraUnitSpec_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle"," set stuff after settling is over (set_both = both _m and _p for current)","","",
    0,5,4,0,NULL,cssElCFun_LeabraUnitSpec_PostSettle_stub,TA_LeabraUnitSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_dWt_impl"," actually do wt change","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_dWt_impl_stub,TA_LeabraUnitSpec_Compute_dWt_impl_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," if weights need to be updated from linear values without doing updatewts","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_WtFmLin_stub,TA_LeabraUnitSpec_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"EncodeState"," encode current state information (hook for time-based learning)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_EncodeState_stub,TA_LeabraUnitSpec_EncodeState_MethArgs},
  {&TA_void,NULL,"CreateNXX1Fun"," create convolved gaussian and x/x+1 ","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnitSpec_CreateNXX1Fun_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnitSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"GraphVmFun"," graph membrane potential (v_m) as a function of excitatory net input (net) for given inhib conductance (g_i) (NULL = new graph log)","BUTTON NULL_OK ","",
    0,5,1,0,NULL,cssElCFun_LeabraUnitSpec_GraphVmFun_stub,TA_LeabraUnitSpec_GraphVmFun_MethArgs},
  {&TA_void,NULL,"GraphActFmVmFun"," graph the activation function as a function of membrane potential (v_m) (NULL = new graph log)","BUTTON NULL_OK ","",
    0,4,1,0,NULL,cssElCFun_LeabraUnitSpec_GraphActFmVmFun_stub,TA_LeabraUnitSpec_GraphActFmVmFun_MethArgs},
  {&TA_void,NULL,"GraphActFmNetFun"," graph the activation function as a function of net input (projected through membrane potential) (NULL = new graph log)","BUTTON NULL_OK ","",
    0,5,1,0,NULL,cssElCFun_LeabraUnitSpec_GraphActFmNetFun_stub,TA_LeabraUnitSpec_GraphActFmNetFun_MethArgs},
  NULL};
static int LeabraUnit::* TA_LeabraUnit_MbrOff;
static MemberDef_data TA_LeabraUnit_MemberDef[]={
  {&TA_float,NULL,"act_eq"," rate-code equivalent activity value (time-averaged spikes or just act)","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_eq))),0,NULL,0},
  {&TA_float,NULL,"act_avg"," average activation over long time intervals (dt = act.avg_dt)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_avg))),0,NULL,0},
  {&TA_float,NULL,"act_m"," minus_phase activation, set after settling, used for learning","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_m))),0,NULL,0},
  {&TA_float,NULL,"act_p"," plus_phase activation, set after settling, used for learning","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_p))),0,NULL,0},
  {&TA_float,NULL,"act_dif"," difference between plus and minus phase acts, gives unit err contribution","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_dif))),0,NULL,0},
  {&TA_float,NULL,"da"," delta activation: change in act from one cycle to next, used to stop settling","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::da))),0,NULL,0},
  {&TA_VChanBasis,NULL,"vcb"," voltage-gated channel basis variables","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::vcb))),0,NULL,0},
  {&TA_LeabraUnitChans,NULL,"gc"," current unit channel conductances","DMEM_SHARE_SET_1 NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::gc))),0,NULL,0},
  {&TA_float,NULL,"I_net"," net current produced by all channels","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::I_net))),0,NULL,0},
  {&TA_float,NULL,"v_m"," membrane potential","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::v_m))),0,NULL,0},
  {&TA_bool,NULL,"in_subgp"," determine if unit is in a subgroup","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::in_subgp))),0,NULL,0},
  {&TA_float,NULL,"clmp_net"," hard-clamp net input (no need to recompute)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_4 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::clmp_net))),0,NULL,0},
  {&TA_float,NULL,"net_scale"," total netinput scaling basis","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_scale))),0,NULL,0},
  {&TA_float,NULL,"bias_scale"," bias weight scaling factor","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::bias_scale))),0,NULL,0},
  {&TA_float,NULL,"prv_net"," previous net input (for time averaging)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::prv_net))),0,NULL,0},
  {&TA_float,NULL,"prv_g_i"," previous inhibitory conductance value (for time averaging)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::prv_g_i))),0,NULL,0},
  {&TA_float,NULL,"act_sent"," last activation value sent (only send when diff is over threshold)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_sent))),0,NULL,0},
  {&TA_float,NULL,"act_delta"," change in activation to send to other units","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_delta))),0,NULL,0},
  {&TA_float,NULL,"net_raw"," raw net input received from sending units (increments the deltas in send_delta)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_raw))),0,NULL,0},
  {&TA_float,NULL,"net_delta"," change in netinput received from other units (send_delta mode only)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_3 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_delta))),0,NULL,0},
  {&TA_float,NULL,"g_i_raw"," raw inhib net input received from sending units (increments the deltas in send_delta)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::g_i_raw))),0,NULL,0},
  {&TA_float,NULL,"g_i_delta"," change in inhibitory netinput received from other units (send_delta mode only)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_3 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::g_i_delta))),0,NULL,0},
  {&TA_float,NULL,"i_thr"," inhibitory threshold value for computing kWTA","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::i_thr))),0,NULL,0},
  {&TA_float,NULL,"spk_amp"," amplitude of spiking output (for depressing synapse activation function)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::spk_amp))),0,NULL,0},
  {&TA_float,NULL,"misc_1"," miscellaneous variable for other algorithms that need it (e.g., TdLayerSpec)","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::misc_1))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnit_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_Net_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_SetCurLrate_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_NetDelta_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_HardClampNoClip_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_IThresh_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_IThreshNoAH_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_PhaseInit_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_DecayEvent_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_DecayPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_ExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_TargExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_EncodeState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LeabraUnit_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","MENU ","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_InitState_stub,TA_LeabraUnit_InitState_MethArgs},
  {&TA_void,NULL,"Send_Net","","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Send_Net_stub,TA_LeabraUnit_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act","","","",
    1,3,-1,0,NULL,cssElCFun_LeabraUnit_Compute_Act_stub,TA_LeabraUnit_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_dWt_stub,TA_LeabraUnit_Compute_dWt_MethArgs},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_SetCurLrate_stub,TA_LeabraUnit_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_NetScale_stub,TA_LeabraUnit_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Send_ClampNet_stub,TA_LeabraUnit_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Send_NetDelta_stub,TA_LeabraUnit_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Compute_NetAvg_stub,TA_LeabraUnit_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Compute_InhibAvg_stub,TA_LeabraUnit_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_HardClamp_stub,TA_LeabraUnit_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_HardClampNoClip","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_HardClampNoClip_stub,TA_LeabraUnit_Compute_HardClampNoClip_MethArgs},
  {&TA_bool,NULL,"Compute_SoftClamp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_SoftClamp_stub,TA_LeabraUnit_Compute_SoftClamp_MethArgs},
  {&TA_float,NULL,"Compute_IThresh","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_IThresh_stub,TA_LeabraUnit_Compute_IThresh_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoAH","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_IThreshNoAH_stub,TA_LeabraUnit_Compute_IThreshNoAH_MethArgs},
  {&TA_void,NULL,"PhaseInit","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_PhaseInit_stub,TA_LeabraUnit_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_DecayEvent_stub,TA_LeabraUnit_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_DecayPhase_stub,TA_LeabraUnit_DecayPhase_MethArgs},
  {&TA_void,NULL,"ExtToComp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_ExtToComp_stub,TA_LeabraUnit_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_TargExtToComp_stub,TA_LeabraUnit_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle","","","",
    0,4,3,0,NULL,cssElCFun_LeabraUnit_PostSettle_stub,TA_LeabraUnit_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_WtFmLin_stub,TA_LeabraUnit_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"EncodeState","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_EncodeState_stub,TA_LeabraUnit_EncodeState_MethArgs},
  {&TA_void,NULL,"GetInSubGp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_GetInSubGp_stub,NULL},
  NULL};
static int LeabraInhib::* TA_LeabraInhib_MbrOff;
static MemberDef_data TA_LeabraInhib_MemberDef[]={
  {&TA_LeabraSort,NULL,"active_buf"," list of active units","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::active_buf))),0,NULL,0},
  {&TA_LeabraSort,NULL,"inact_buf"," list of inactive units","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::inact_buf))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"netin"," net input values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::netin))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts"," activation values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts_p"," plus-phase activation stats for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts_p))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts_m"," minus-phase activation stats for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts_m))),0,NULL,0},
  {&TA_float,NULL,"phase_dif_ratio"," phase-difference ratio (acts_m.avg / acts_p.avg)","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::phase_dif_ratio))),0,NULL,0},
  {&TA_KWTAVals,NULL,"kwta"," values for kwta -- activity levels, etc NOTE THIS IS A COMPUTED VALUE: k IS SET IN LayerSpec!","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::kwta))),0,NULL,0},
  {&TA_InhibVals,NULL,"i_val"," inhibitory values computed by kwta","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::i_val))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"un_g_i"," average and stdev (not max) values for unit inhib-to-thresh","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::un_g_i))),0,NULL,0},
  {&TA_AdaptIVals,NULL,"adapt_i"," adapting inhibition values","READ_ONLY AKA_adapt_pt ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::adapt_i))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodDef_data TA_LeabraInhib_MethodDef[]={
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_SetVals_stub,TA_LeabraInhib_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_InitState_stub,TA_LeabraInhib_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_Copy__stub,TA_LeabraInhib_Inhib_Copy__MethArgs},
  NULL};
static EnumDef_data TA_LeabraLayerSpec_Compute_I[]={
  {"KWTA_INHIB"," between thresholds of k and k+1th most activated units (sets precise k value, should use i_kwta_pt = .25 std)","",0},
  {"KWTA_AVG_INHIB"," average of top k vs avg of rest (provides more flexibility in actual k value, should use i_kwta_pt = .6 std)","",1},
  {"UNIT_INHIB"," unit-based inhibition (g_i from netinput -- requires connections with inhib flag set to provide inhibition)","",2},
  {"UNIT_M_KWTA_P"," unit-based inhibition in minus phase, kWTA in plus phase","",3},
  {"UNIT_M_KWTA_AVG_P"," unit-based inhibition in minus phase, kWTA avg-based in plus phase","",4},
  NULL};
static EnumDef_data TA_LeabraLayerSpec_InhibGroup[]={
  {"ENTIRE_LAYER"," treat entire layer as one inhibitory group (even if subgroups exist)","",0},
  {"UNIT_GROUPS"," treat sub unit groups as separate inhibitory groups","",1},
  {"LAY_AND_GPS"," compute inhib over both groups and whole layer, inhibi is max of layer and group inhib","",2},
  {"GPS_THEN_UNITS"," first find top gp_kwta.k most active (on average) groups, then find top kwta.k units within those groups (else all units inhibbed)","",3},
  NULL};
static int LeabraLayerSpec::* TA_LeabraLayerSpec_MbrOff;
static MemberDef_data TA_LeabraLayerSpec_MemberDef[]={
  {&TA_KWTASpec,NULL,"kwta"," desired activity level over entire layer","CONDEDIT_OFF_inhib_group:UNIT_GROUPS ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::kwta))),0,NULL,0},
  {&TA_KWTASpec,NULL,"gp_kwta"," desired activity level for units within unit groups (not for ENTIRE_LAYER)","CONDEDIT_OFF_inhib_group:ENTIRE_LAYER ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::gp_kwta))),0,NULL,0},
  {NULL,"::InhibGroup","inhib_group"," what to consider the inhibitory group (layer or unit subgroups, or both)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::inhib_group))),0,NULL,0},
  {NULL,"::Compute_I","compute_i"," how to compute inhibition (g_i): two forms of kwta or unit-level inhibition","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::compute_i))),0,NULL,0},
  {&TA_float,NULL,"i_kwta_pt"," [Default: .25 for KWTA_INHIB, .6 for KWTA_AVG] point to place inhibition between k and k+1","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::i_kwta_pt))),0,NULL,0},
  {&TA_AdaptISpec,NULL,"adapt_i"," adapt the inhibition: either i_kwta_pt point based on diffs between actual and target k level (for avg-based), or g_bar.i for unit-inhib","AKA_adapt_pt ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::adapt_i))),0,NULL,0},
  {&TA_ClampSpec,NULL,"clamp"," how to clamp external inputs to units (hard vs. soft)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::clamp))),0,NULL,0},
  {&TA_DecaySpec,NULL,"decay"," decay of activity state vars between events, -/+ phase, and 2nd set of phases (if appl)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::decay))),0,NULL,0},
  {&TA_LayerLinkSpec,NULL,"layer_link"," link inhibition between layers (with specified gain), rarely used, linked layers in layer objects","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::layer_link))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitWtState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_SetCurLrate_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Active_K_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Active_K_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_KWTASpec_ref,NULL,"kwtspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Pat_K_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_HardClampPhase2_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_Net_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitInhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_LinkInhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_InhibAvg_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActMAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActMAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActPAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActPAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_PhaseInit_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayPhase2_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_ExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_TargExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","0"},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_AdaptGBarI_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_AdaptKWTAPt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpec_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int_ref,NULL,"prjn_idx",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpecExact_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int_ref,NULL,"prjn_idx",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpecNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","0"},
  NULL};
static MethodDef_data TA_LeabraLayerSpec_MethodDef[]={
  {&TA_void,NULL,"InitWtState"," initialize weight values and other permanent state","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_InitWtState_stub,TA_LeabraLayerSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on epoch","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_SetCurLrate_stub,TA_LeabraLayerSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_Active_K"," prior to settling: compute actual activity levels based on spec, inputs, etc","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Active_K_stub,TA_LeabraLayerSpec_Compute_Active_K_MethArgs},
  {&TA_void,NULL,"Compute_Active_K_impl","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Active_K_impl_stub,TA_LeabraLayerSpec_Compute_Active_K_impl_MethArgs},
  {&TA_int,NULL,"Compute_Pat_K"," above are implementation helpers","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Pat_K_stub,TA_LeabraLayerSpec_Compute_Pat_K_MethArgs},
  {&TA_void,NULL,"InitState"," prior to settling: initialize dynamic state variables","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_InitState_stub,TA_LeabraLayerSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_HardClampPhase2"," prior to settling: hard-clamp inputs (special code for hard clamping in phase 2 based on prior acts)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_HardClampPhase2_stub,TA_LeabraLayerSpec_Compute_HardClampPhase2_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_HardClamp_stub,TA_LeabraLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," prior to settling: compute netinput scaling values","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetScale_stub,TA_LeabraLayerSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," prior to settling: compute input from hard-clamped","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Send_ClampNet_stub,TA_LeabraLayerSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_Net"," compute net inputs","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_Send_Net_stub,TA_LeabraLayerSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," compute net inputs as changes in activation","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_Send_NetDelta_stub,TA_LeabraLayerSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_Clamp_NetAvg"," clamp and compute averages of net inputs that were already computed","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Clamp_NetAvg_stub,TA_LeabraLayerSpec_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetAvg_stub,TA_LeabraLayerSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_SoftClamp"," soft-clamp inputs by adding to net input","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_SoftClamp_stub,TA_LeabraLayerSpec_Compute_SoftClamp_MethArgs},
  {&TA_void,NULL,"InitInhib"," initialize the inhibitory state values","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_InitInhib_stub,TA_LeabraLayerSpec_InitInhib_MethArgs},
  {&TA_void,NULL,"Compute_Inhib"," stage two: compute the inhibition for layer","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_stub,TA_LeabraLayerSpec_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_impl"," implementation of inhibition computation for either layer or unit group","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_impl_stub,TA_LeabraLayerSpec_Compute_Inhib_impl_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA"," implementation of basic kwta inhibition computation","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA_Avg"," implementation of kwta avg-based inhibition computation","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA_Gps"," implementation of GPS_THEN_UNITS kwta on groups","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_MethArgs},
  {&TA_void,NULL,"Compute_LinkInhib"," compute inhibition after linkages with other layers are factored in","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_LinkInhib_stub,TA_LeabraLayerSpec_Compute_LinkInhib_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," stage three: compute final activation","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_InhibAvg_stub,TA_LeabraLayerSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg_impl"," //////////////////////////////////////","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_InhibAvg_impl_stub,TA_LeabraLayerSpec_Compute_InhibAvg_impl_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg_ugp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg"," helper function to compute acts.avg from act_eq","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActAvg_stub,TA_LeabraLayerSpec_Compute_ActAvg_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg_ugp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActMAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActMAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg"," helper function to compute acts_m.avg from act_m","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActMAvg_stub,TA_LeabraLayerSpec_Compute_ActMAvg_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg_ugp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActPAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActPAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg"," helper function to compute acts_p.avg from act_p","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActPAvg_stub,TA_LeabraLayerSpec_Compute_ActPAvg_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Act_stub,TA_LeabraLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl"," //////////////////////////////////////","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Act_impl_stub,TA_LeabraLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"PhaseInit"," initialize start of a setting phase, set input flags appropriately, etc","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_PhaseInit_stub,TA_LeabraLayerSpec_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_DecayEvent_stub,TA_LeabraLayerSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_DecayPhase_stub,TA_LeabraLayerSpec_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayPhase2","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_DecayPhase2_stub,TA_LeabraLayerSpec_DecayPhase2_MethArgs},
  {&TA_void,NULL,"ExtToComp"," change external inputs to comparisons (remove input)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_ExtToComp_stub,TA_LeabraLayerSpec_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp"," change target & external inputs to comparisons (remove targ & input)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_TargExtToComp_stub,TA_LeabraLayerSpec_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle"," after settling, keep track of phase variables, etc.","","",
    0,3,2,0,NULL,cssElCFun_LeabraLayerSpec_PostSettle_stub,TA_LeabraLayerSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"AdaptGBarI"," adapt inhibitory conductances based on target activation values relative to current values","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_AdaptGBarI_stub,TA_LeabraLayerSpec_AdaptGBarI_MethArgs},
  {&TA_void,NULL,"AdaptKWTAPt"," adapt the kwta point based on average activity","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_AdaptKWTAPt_stub,TA_LeabraLayerSpec_AdaptKWTAPt_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_dWt_stub,TA_LeabraLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," use this if weights will be used again for activations prior to being updated","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_WtFmLin_stub,TA_LeabraLayerSpec_Compute_WtFmLin_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpec"," find a layer that given layer receives from based on the type of layer spec","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_FindLayerFmSpec_stub,TA_LeabraLayerSpec_FindLayerFmSpec_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpecExact"," find a layer that given layer receives from based on the type of layer spec: uses exact type match, not inherits!","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_FindLayerFmSpecExact_stub,TA_LeabraLayerSpec_FindLayerFmSpecExact_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpecNet"," find a layer in network based on the type of layer spec","","",
    0,2,-1,1,(ta_void_fun)(LeabraLayerSpec::FindLayerFmSpecNet),cssElCFun_LeabraLayerSpec_FindLayerFmSpecNet_stub,TA_LeabraLayerSpec_FindLayerFmSpecNet_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayerSpec_HelpConfig_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    0,3,2,0,NULL,cssElCFun_LeabraLayerSpec_CheckConfig_stub,TA_LeabraLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayerSpec_Defaults_stub,NULL},
  NULL};
static int LeabraUnit_Group::* TA_LeabraUnit_Group_MbrOff;
static MemberDef_data TA_LeabraUnit_Group_MemberDef[]={
  {&TA_int,NULL,"misc_state"," miscellaneous state variable","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state))),0,NULL,0},
  {&TA_int,NULL,"misc_state1"," second miscellaneous state variable ","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state1))),0,NULL,0},
  {&TA_int,NULL,"misc_state2"," third miscellaneous state variable ","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state2))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnSafeCopy_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CastCopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetPath_MethArgs[]={
  {&TA_TAPtr,NULL,"ta","0"},
  {&TA_TAPtr,NULL,"par_stop","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindFromPath_MethArgs[]={
  {&TA_taString_ref,NULL,"path",""},
  {&TA_MemberDef_ptr_ref,NULL,"ret_md","no_mdef"},
  {&TA_int,NULL,"start","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_New_MethArgs[]={
  {&TA_int,NULL,"n_objs","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_InheritsFrom_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetEnumString_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_tp_nm",""},
  {&TA_int,NULL,"enum_val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetEnumVal_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_nm",""},
  {&TA_taString_ref,NULL,"enum_tp_nm"," no_name"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Load_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Save_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SaveAs_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Edit_MethArgs[]={
  {&TA_bool,NULL,"wait","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CopyFrom_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_from",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChangeMyType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SelectForEdit_MethArgs[]={
  {&TA_MemberDef_ptr,NULL,"member",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SelectFunForEdit_MethArgs[]={
  {&TA_MethodDef_ptr,NULL,"function",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CallFun_MethArgs[]={
  {&TA_const_char_ptr,NULL,"fun_name",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Alloc_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BuildHashTable_MethArgs[]={
  {&TA_int,NULL,"n_buckets",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Find_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Remove_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Move_MethArgs[]={
  {&TA_int,NULL,"from",""},
  {&TA_int,NULL,"to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Swap_MethArgs[]={
  {&TA_int,NULL,"pos1",""},
  {&TA_int,NULL,"pos2",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Sort_MethArgs[]={
  {&TA_bool,NULL,"descending","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Sort__MethArgs[]={
  {&TA_bool,NULL,"descending","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Duplicate_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DupeUniqNameNew_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DupeUniqNameOld_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Stealth_Borrow_MethArgs[]={
  {&TA_const_taPtrList_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Borrow_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUnique_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUniqNameNew_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUniqNameOld_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Common_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Duplicate_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Borrow_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_List_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm","cout"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Add_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUnique_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUniqNameNew_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Insert_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  {&TA_int,NULL,"where",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Replace_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","old_it",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DuplicateEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Link_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUnique_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUniqNameNew_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_InsertLink_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  {&TA_int,NULL,"idx"," -1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLink_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLinkEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","old_it",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLinkName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Push_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","from",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Transfer_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveBefore_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","trg",""},
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveAfter_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","trg",""},
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Dump_Save_PathR_impl_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultEl_MethArgs[]={
  {&TA_TAPtr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultElName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultElType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceSize_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceSameStru_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChangeType_MethArgs[]={
  {&TA_TAPtr,NULL,"itm",""},
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"old_type",""},
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetBaseType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeafEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveGp_MethArgs[]={
  {&TA_TAGPtr,NULL,"group",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceLeaves_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeaf_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Edit_El_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LeafGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUniqNameOld_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUniqNameOld_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Weights_MethArgs[]={
  {&TA_const_Unit_Group_ptr,NULL,"src",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_WriteWeights_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReadWeights_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LayoutUnits_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u"," 0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"unitspec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"conspec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_TransformWeights_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"trans",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddNoiseToWeights_MethArgs[]={
  {&TA_const_Random_ref,NULL,"noise_spec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_PruneCons_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"pre_proc",""},
  {NULL,"CountParam::Relation","rel",""},
  {&TA_float,NULL,"cmp_val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LesionCons_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LesionUnits_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnitValuesToArray_MethArgs[]={
  {&TA_float_RArray_ref,NULL,"ary",""},
  {&TA_const_char_ptr,NULL,"variable",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnitValuesFromArray_MethArgs[]={
  {&TA_float_RArray_ref,NULL,"ary",""},
  {&TA_const_char_ptr,NULL,"variable",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindUnitFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodDef_data TA_LeabraUnit_Group_MethodDef[]={
  {&TA_void,NULL,"UnSafeCopy","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnSafeCopy_stub,TA_LeabraUnit_Group_UnSafeCopy_MethArgs},
  {&TA_void,NULL,"CastCopyTo","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CastCopyTo_stub,TA_LeabraUnit_Group_CastCopyTo_MethArgs},
  {&TA_TAPtr,NULL,"GetOwner","","","",
    2,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetOwner_stub,NULL},
  {&TA_taString,NULL,"GetPath"," get path without name informtation, stop at par_stop if non-null","","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_GetPath_stub,TA_LeabraUnit_Group_GetPath_MethArgs},
  {&TA_TAPtr,NULL,"FindFromPath"," find object from path (starting from this, and position start of the path)","","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_FindFromPath_stub,TA_LeabraUnit_Group_FindFromPath_MethArgs},
  {&TA_TAPtr,NULL,"New"," create n_objs new objects of given type","MENU MENU_ON_Object ARGC_0 UPDATE_MENUS NO_SCRIPT ","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_New_stub,TA_LeabraUnit_Group_New_MethArgs},
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"InheritsFrom"," does this inherit from given type?","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_InheritsFrom_stub,TA_LeabraUnit_Group_InheritsFrom_MethArgs},
  {&TA_taString,NULL,"GetEnumString"," get the name corresponding to given enum value in enum type enum_tp_nm","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetEnumString_stub,TA_LeabraUnit_Group_GetEnumString_MethArgs},
  {&TA_int,NULL,"GetEnumVal"," get the enum value corresponding to the given enum name (-1 if not found), and sets enum_tp_nm to name of type this enum belongs in (empty if not found)","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_GetEnumVal_stub,TA_LeabraUnit_Group_GetEnumVal_MethArgs},
  {&TA_int,NULL,"Load"," Load object data from a file","MENU MENU_ON_Object ARGC_1 UPDATE_MENUS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_Load_stub,TA_LeabraUnit_Group_Load_MethArgs},
  {&TA_int,NULL,"Save"," Save object data to a file","MENU ARGC_1 QUICK_SAVE ","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_Save_stub,TA_LeabraUnit_Group_Save_MethArgs},
  {&TA_int,NULL,"SaveAs"," Save object data to a new file","MENU ARGC_1 ","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_SaveAs_stub,TA_LeabraUnit_Group_SaveAs_MethArgs},
  {&TA_int,NULL,"Edit"," Edit this object using the gui","MENU ARGC_0 MENU_ON_Object NO_SCRIPT ","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_Edit_stub,TA_LeabraUnit_Group_Edit_MethArgs},
  {&TA_bool,NULL,"CloseEdit"," close any open edit dialogs for this object","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_CloseEdit_stub,NULL},
  {&TA_void,NULL,"Close"," PERMANENTLY Destroy this object! This is not Iconify.","MENU CONFIRM NO_REVERT_AFTER LABEL_Close_(Destroy) ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Close_stub,NULL},
  {&TA_bool,NULL,"CopyFrom"," Copy from given object into this object","MENU MENU_SEP_BEFORE TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CopyFrom_stub,TA_LeabraUnit_Group_CopyFrom_MethArgs},
  {&TA_bool,NULL,"CopyTo"," Copy to given object from this object","MENU TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CopyTo_stub,TA_LeabraUnit_Group_CopyTo_MethArgs},
  {&TA_bool,NULL,"DuplicateMe"," Make another copy of myself (done through owner)","MENU CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_DuplicateMe_stub,NULL},
  {&TA_bool,NULL,"ChangeMyType"," Change me into a different type of object, copying current info (done through owner)","MENU TYPE_this UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChangeMyType_stub,TA_LeabraUnit_Group_ChangeMyType_MethArgs},
  {&TA_bool,NULL,"SelectForEdit"," select a given member for editing in a select edit dialog -- if already on dialog, removes it & returns false (else true)","MENU ","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_SelectForEdit_stub,TA_LeabraUnit_Group_SelectForEdit_MethArgs},
  {&TA_bool,NULL,"SelectFunForEdit"," select a given function (method) for calling in a select edit dialog -- if already on dialog, removes it & returns false (else true)","MENU ","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_SelectFunForEdit_stub,TA_LeabraUnit_Group_SelectFunForEdit_MethArgs},
  {&TA_void,NULL,"Help"," get help on using this object","MENU ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Help_stub,NULL},
  {&TA_void,NULL,"CallFun"," call function of given name on this object, prompting for args using gui interface","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CallFun_stub,TA_LeabraUnit_Group_CallFun_MethArgs},
  {&TA_void,NULL,"Alloc"," allocate a list big enough for given number of elements (or current size)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Alloc_stub,TA_LeabraUnit_Group_Alloc_MethArgs},
  {&TA_void,NULL,"Reset"," reset the list (remove all elements)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Reset_stub,NULL},
  {&TA_bool,NULL,"IsEmpty","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_IsEmpty_stub,NULL},
  {&TA_void,NULL,"BuildHashTable"," build a hash table with given number of buckets (not dynamic, so make it big)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BuildHashTable_stub,TA_LeabraUnit_Group_BuildHashTable_MethArgs},
  {&TA_int,NULL,"Find"," find named element in list find element in list (-1 if not there) find element of given type","","",
    4,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Find_stub,TA_LeabraUnit_Group_Find_MethArgs},
  {&TA_bool,NULL,"Remove"," remove (and delete) element from list at index Remove object at given index on list","","",
    10,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Remove_stub,TA_LeabraUnit_Group_Remove_MethArgs},
  {&TA_bool,NULL,"RemoveName"," remove given named element from list (if on list)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveName_stub,TA_LeabraUnit_Group_RemoveName_MethArgs},
  {&TA_bool,NULL,"RemoveLast"," remove the last element on the list","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLast_stub,NULL},
  {&TA_void,NULL,"RemoveAll"," Remove all elements on the list","MENU MENU_ON_Edit CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveAll_stub,NULL},
  {&TA_bool,NULL,"Move"," Move element from (from) to position (to) in list","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Move_stub,TA_LeabraUnit_Group_Move_MethArgs},
  {&TA_bool,NULL,"Swap"," Swap the elements in the two given positions on the list","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Swap_stub,TA_LeabraUnit_Group_Swap_MethArgs},
  {&TA_void,NULL,"PopAll"," pop all elements off the stack","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_PopAll_stub,NULL},
  {&TA_void,NULL,"Permute"," permute the items in the list into a random order","MENU CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Permute_stub,NULL},
  {&TA_void,NULL,"Sort"," sort the items in the list in alpha order according to name (or El_Compare_)","MENU CONFIRM UPDATE_MENUS ","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_Sort_stub,TA_LeabraUnit_Group_Sort_MethArgs},
  {&TA_void,NULL,"Sort_"," implementation of sorting function","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_Sort__stub,TA_LeabraUnit_Group_Sort__MethArgs},
  {&TA_void,NULL,"UpdateAllIndicies"," update all indicies of elements in list","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAllIndicies_stub,NULL},
  {&TA_void,NULL,"Duplicate"," duplicate (clone & add) elements of given list into this one","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Duplicate_stub,TA_LeabraUnit_Group_Duplicate_MethArgs},
  {&TA_void,NULL,"DupeUniqNameNew"," duplicate so result is unique names, replacing with new ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DupeUniqNameNew_stub,TA_LeabraUnit_Group_DupeUniqNameNew_MethArgs},
  {&TA_void,NULL,"DupeUniqNameOld"," duplicate so result is unique names, using old ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DupeUniqNameOld_stub,TA_LeabraUnit_Group_DupeUniqNameOld_MethArgs},
  {&TA_void,NULL,"Stealth_Borrow"," borrow without referencing the borrowed elements (i.e. use AddEl_())","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Stealth_Borrow_stub,TA_LeabraUnit_Group_Stealth_Borrow_MethArgs},
  {&TA_void,NULL,"Borrow"," borrow (link) elements of given list into this one","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Borrow_stub,TA_LeabraUnit_Group_Borrow_MethArgs},
  {&TA_void,NULL,"BorrowUnique"," borrow so result is unique list","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUnique_stub,TA_LeabraUnit_Group_BorrowUnique_MethArgs},
  {&TA_void,NULL,"BorrowUniqNameNew"," borrow so result is unique names, replacing with new ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUniqNameNew_stub,TA_LeabraUnit_Group_BorrowUniqNameNew_MethArgs},
  {&TA_void,NULL,"BorrowUniqNameOld"," borrow so result is unique names, using old ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUniqNameOld_stub,TA_LeabraUnit_Group_BorrowUniqNameOld_MethArgs},
  {&TA_void,NULL,"Copy_Common"," apply copy operator to only those items in common between the two lists","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Common_stub,TA_LeabraUnit_Group_Copy_Common_MethArgs},
  {&TA_void,NULL,"Copy_Duplicate"," apply copy operator to items, use duplicate to add new ones from cp (if necc)","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Duplicate_stub,TA_LeabraUnit_Group_Copy_Duplicate_MethArgs},
  {&TA_void,NULL,"Copy_Borrow"," apply copy operator to items, use borrow to add new ones from cp (if necc)","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Borrow_stub,TA_LeabraUnit_Group_Copy_Borrow_MethArgs},
  {&TA_void,NULL,"List"," List the group items","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_List_stub,TA_LeabraUnit_Group_List_MethArgs},
  {&TA_int,NULL,"FindEl"," find given element in list (-1 if not there)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindEl_stub,TA_LeabraUnit_Group_FindEl_MethArgs},
  {&TA_void,NULL,"AddEl"," append a new pointer to end of list","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddEl_stub,TA_LeabraUnit_Group_AddEl_MethArgs},
  {&TA_void,NULL,"Add"," add element to the list and 'own' item","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Add_stub,TA_LeabraUnit_Group_Add_MethArgs},
  {&TA_bool,NULL,"AddUnique"," add so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddUnique_stub,TA_LeabraUnit_Group_AddUnique_MethArgs},
  {&TA_bool,NULL,"AddUniqNameNew"," add so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddUniqNameNew_stub,TA_LeabraUnit_Group_AddUniqNameNew_MethArgs},
  {&TA_bool,NULL,"Insert"," insert element at index (-1 for end)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Insert_stub,TA_LeabraUnit_Group_Insert_MethArgs},
  {&TA_bool,NULL,"Replace"," replace element at index with the new one","","",
    2,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Replace_stub,TA_LeabraUnit_Group_Replace_MethArgs},
  {&TA_bool,NULL,"ReplaceEl"," replace given element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceEl_stub,TA_LeabraUnit_Group_ReplaceEl_MethArgs},
  {&TA_bool,NULL,"ReplaceName"," replace named element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceName_stub,TA_LeabraUnit_Group_ReplaceName_MethArgs},
  {&TA_bool,NULL,"RemoveEl"," Remove given item from list Remove given item from the list","MENU LABEL_Remove ARG_ON_OBJ UPDATE_MENUS ","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveEl_stub,TA_LeabraUnit_Group_RemoveEl_MethArgs},
  {&TA_bool,NULL,"DuplicateEl"," Duplicate given list item and Add to list","MENU ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DuplicateEl_stub,TA_LeabraUnit_Group_DuplicateEl_MethArgs},
  {&TA_void,NULL,"Link"," Link an item to list without owning it","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Link_stub,TA_LeabraUnit_Group_Link_MethArgs},
  {&TA_bool,NULL,"LinkUnique"," link so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUnique_stub,TA_LeabraUnit_Group_LinkUnique_MethArgs},
  {&TA_bool,NULL,"LinkUniqNameNew"," link so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUniqNameNew_stub,TA_LeabraUnit_Group_LinkUniqNameNew_MethArgs},
  {&TA_bool,NULL,"InsertLink"," Insert a link at index (-1 for end)","MENU LABEL_Link UPDATE_MENUS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_InsertLink_stub,TA_LeabraUnit_Group_InsertLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLink"," replace element with a link to the new one","","",
    2,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLink_stub,TA_LeabraUnit_Group_ReplaceLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkEl"," replace given element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLinkEl_stub,TA_LeabraUnit_Group_ReplaceLinkEl_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkName"," replace given named element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLinkName_stub,TA_LeabraUnit_Group_ReplaceLinkName_MethArgs},
  {&TA_void,NULL,"Push"," push item on stack (for temporary use, not 'owned')","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Push_stub,TA_LeabraUnit_Group_Push_MethArgs},
  {&TA_bool,NULL,"MoveEl"," Move item (from) to position of (to)","MENU LABEL_Move ARG_ON_OBJ UPDATE_MENUS ","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_MoveEl_stub,TA_LeabraUnit_Group_MoveEl_MethArgs},
  {&TA_bool,NULL,"Transfer"," Transfer element to this list","MENU MENU_ON_Edit NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Transfer_stub,TA_LeabraUnit_Group_Transfer_MethArgs},
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_MoveBefore_stub,TA_LeabraUnit_Group_MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_MoveAfter_stub,TA_LeabraUnit_Group_MoveAfter_MethArgs},
  {&TA_int,NULL,"Dump_Save_PathR_impl","","","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_Dump_Save_PathR_impl_stub,TA_LeabraUnit_Group_Dump_Save_PathR_impl_MethArgs},
  {&TA_int,NULL,"SetDefaultEl"," set the default element to be given item","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultEl_stub,TA_LeabraUnit_Group_SetDefaultEl_MethArgs},
  {&TA_int,NULL,"SetDefaultElName"," set the default element to be item with given name","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultElName_stub,TA_LeabraUnit_Group_SetDefaultElName_MethArgs},
  {&TA_int,NULL,"SetDefaultElType"," set the default element to be item with given type","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultElType_stub,TA_LeabraUnit_Group_SetDefaultElType_MethArgs},
  {&TA_void,NULL,"EnforceSize"," add or remove elements to force list to be of given size","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceSize_stub,TA_LeabraUnit_Group_EnforceSize_MethArgs},
  {&TA_void,NULL,"EnforceType"," enforce current type (all elements have to be of this type)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceType_stub,NULL},
  {&TA_void,NULL,"EnforceSameStru"," make the two lists identical in terms of size and types of objects","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceSameStru_stub,TA_LeabraUnit_Group_EnforceSameStru_MethArgs},
  {&TA_bool,NULL,"ChangeType"," change type of item at index change type of item to new type, copying current info","MENU MENU_ON_Object UPDATE_MENUS ARG_ON_OBJ TYPE_ON_el_base ","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChangeType_stub,TA_LeabraUnit_Group_ChangeType_MethArgs},
  {&TA_int,NULL,"ReplaceType"," replace all items of old type with new type (returns number changed)","MENU MENU_ON_Object USE_RVAL UPDATE_MENUS TYPE_ON_el_base ","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceType_stub,TA_LeabraUnit_Group_ReplaceType_MethArgs},
  {&TA_void,NULL,"SetBaseType"," set base (and default) type to given td","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetBaseType_stub,TA_LeabraUnit_Group_SetBaseType_MethArgs},
  {&TA_MemberDef_ptr,NULL,"ReturnFindMd"," return the find_md variable, initialized if necessary","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReturnFindMd_stub,NULL},
  {&TA_void,NULL,"InitLeafGp"," Initialize the leaf group","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_InitLeafGp_stub,NULL},
  {&TA_bool,NULL,"RemoveLeaf"," remove given leaf element Remove leaf element at leaf index","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeaf_stub,TA_LeabraUnit_Group_RemoveLeaf_MethArgs},
  {&TA_bool,NULL,"RemoveLeafName"," remove given named leaf element ","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeafName_stub,TA_LeabraUnit_Group_RemoveLeafName_MethArgs},
  {&TA_bool,NULL,"RemoveLeafEl"," Remove given leaf element","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeafEl_stub,TA_LeabraUnit_Group_RemoveLeafEl_MethArgs},
  {&TA_bool,NULL,"RemoveGp"," remove group at given index remove given group ","MENU FROM_GROUP_gp MENU_ON_Edit UPDATE_MENUS ","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveGp_stub,TA_LeabraUnit_Group_RemoveGp_MethArgs},
  {&TA_TALOG_ptr,NULL,"EditSubGps"," edit the list of sub-groups (e.g., so you can move around subgroups)","MENU USE_RVAL ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_EditSubGps_stub,NULL},
  {&TA_void,NULL,"EnforceLeaves"," ensure that sz leaves exits by adding new ones to top group and removing old ones from end","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceLeaves_stub,TA_LeabraUnit_Group_EnforceLeaves_MethArgs},
  {&TA_int,NULL,"FindLeaf"," find given leaf element (-1 = not here) find named leaf element","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeaf_stub,TA_LeabraUnit_Group_FindLeaf_MethArgs},
  {&TA_int,NULL,"FindLeafEl"," find given leaf element -1 = not here. ","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafEl_stub,TA_LeabraUnit_Group_FindLeafEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SafeEl_stub,TA_LeabraUnit_Group_SafeEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FastEl"," fast element (no checking)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FastEl_stub,TA_LeabraUnit_Group_FastEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","DefaultEl"," returns the element specified as the default for this group","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_DefaultEl_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Edit_El_stub,TA_LeabraUnit_Group_Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SafeGp_stub,TA_LeabraUnit_Group_SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FastGp_stub,TA_LeabraUnit_Group_FastGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","Leaf"," get leaf element at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Leaf_stub,TA_LeabraUnit_Group_Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"LeafGp"," the group containing given leaf","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LeafGp_stub,TA_LeabraUnit_Group_LeafGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FirstEl"," returns first leaf element and inits indexes","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FirstEl_stub,TA_LeabraUnit_Group_FirstEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","NextEl"," returns next leaf element and incs indexes","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_NextEl_stub,TA_LeabraUnit_Group_NextEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FirstGp_stub,TA_LeabraUnit_Group_FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_NextGp_stub,TA_LeabraUnit_Group_NextGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","NewEl"," Create and add (n_els) new element(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_NewEl_stub,TA_LeabraUnit_Group_NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_NewGp_stub,TA_LeabraUnit_Group_NewGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindName_stub,TA_LeabraUnit_Group_FindName_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindType_stub,TA_LeabraUnit_Group_FindType_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Pop_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Peek_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddUniqNameOld_stub,TA_LeabraUnit_Group_AddUniqNameOld_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUniqNameOld_stub,TA_LeabraUnit_Group_LinkUniqNameOld_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindLeafName"," Find element with given name (el_nm) ","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafName_stub,TA_LeabraUnit_Group_FindLeafName_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafType_stub,TA_LeabraUnit_Group_FindLeafType_MethArgs},
  {&TA_void,NULL,"Copy_Weights"," copies weights from other unit group (incl wts assoc with unit bias member)","MENU MENU_ON_Object ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Weights_stub,TA_LeabraUnit_Group_Copy_Weights_MethArgs},
  {&TA_void,NULL,"WriteWeights"," write weight values out in a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_WriteWeights_stub,TA_LeabraUnit_Group_WriteWeights_MethArgs},
  {&TA_void,NULL,"ReadWeights"," read weight values in from a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_ReadWeights_stub,TA_LeabraUnit_Group_ReadWeights_MethArgs},
  {&TA_bool,NULL,"Build"," for subgroups: build units to specs (true if changed)","MENU MENU_ON_Actions ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Build_stub,NULL},
  {&TA_bool,NULL,"CheckBuild"," check if build needs to be performed (true if yes, false if no)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_CheckBuild_stub,NULL},
  {&TA_void,NULL,"LayoutUnits"," for subgroups: redistribute units within the given geometry of the group","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_LayoutUnits_stub,TA_LeabraUnit_Group_LayoutUnits_MethArgs},
  {&TA_void,NULL,"RecomputeGeometry"," re compute geometry based on parent layer","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RecomputeGeometry_stub,NULL},
  {&TA_bool,NULL,"SetUnitSpec"," set for all units in group","MENU MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetUnitSpec_stub,TA_LeabraUnit_Group_SetUnitSpec_MethArgs},
  {&TA_bool,NULL,"SetConSpec"," set for all unit's connections in group","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetConSpec_stub,TA_LeabraUnit_Group_SetConSpec_MethArgs},
  {&TA_void,NULL,"TransformWeights"," apply given transformation to weights","MENU MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_TransformWeights_stub,TA_LeabraUnit_Group_TransformWeights_MethArgs},
  {&TA_void,NULL,"AddNoiseToWeights"," add noise to weights using given noise specification","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddNoiseToWeights_stub,TA_LeabraUnit_Group_AddNoiseToWeights_MethArgs},
  {&TA_int,NULL,"PruneCons"," remove weights that (after pre-proc) meet relation to compare val","MENU USE_RVAL ","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_PruneCons_stub,TA_LeabraUnit_Group_PruneCons_MethArgs},
  {&TA_int,NULL,"LesionCons"," remove connections with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_LesionCons_stub,TA_LeabraUnit_Group_LesionCons_MethArgs},
  {&TA_int,NULL,"LesionUnits"," remove units with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_LesionUnits_stub,TA_LeabraUnit_Group_LesionUnits_MethArgs},
  {&TA_void,NULL,"UnitValuesToArray"," adds values of variable from the units into the given array","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnitValuesToArray_stub,TA_LeabraUnit_Group_UnitValuesToArray_MethArgs},
  {&TA_void,NULL,"UnitValuesFromArray"," sets unit values from values in the given array","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnitValuesFromArray_stub,TA_LeabraUnit_Group_UnitValuesFromArray_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmCoord"," returns unit at given coordinates within layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindUnitFmCoord_stub,TA_LeabraUnit_Group_FindUnitFmCoord_MethArgs},
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_SetVals_stub,TA_LeabraUnit_Group_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_InitState_stub,TA_LeabraUnit_Group_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_Copy__stub,TA_LeabraUnit_Group_Inhib_Copy__MethArgs},
  NULL};
static int LeabraLayer::* TA_LeabraLayer_MbrOff;
static MemberDef_data TA_LeabraLayer_MemberDef[]={
  {&TA_LeabraLayerSpec_SPtr,NULL,"spec"," the spec for this layer: controls all functions of layer","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::spec))),0,NULL,0},
  {&TA_LayerLink_List,NULL,"layer_links"," list of layers to link inhibition with","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::layer_links))),0,NULL,0},
  {&TA_float,NULL,"stm_gain"," actual stim gain for soft clamping, can be incremented to ensure clamped units active","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::stm_gain))),0,NULL,0},
  {&TA_bool,NULL,"hard_clamped"," this layer is actually hard clamped","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::hard_clamped))),0,NULL,0},
  {&TA_int,NULL,"prv_phase"," previous phase value (needed for 2nd plus phases and the like)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::prv_phase))),0,NULL,0},
  {&TA_float,NULL,"dav"," dopamine-like modulatory value (where applicable)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::dav))),0,NULL,0},
  {&TA_int,NULL,"da_updt"," true if da triggered an update (either + to store or - reset)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::da_updt))),0,NULL,0},
  {&TA_int_Array,NULL,"misc_iar"," misc int array of data","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::misc_iar))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraLayer_UnSafeCopy_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CastCopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetOwner_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"tp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetPath_MethArgs[]={
  {&TA_TAPtr,NULL,"ta","0"},
  {&TA_TAPtr,NULL,"par_stop","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindFromPath_MethArgs[]={
  {&TA_taString_ref,NULL,"path",""},
  {&TA_MemberDef_ptr_ref,NULL,"ret_md","no_mdef"},
  {&TA_int,NULL,"start","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_New_MethArgs[]={
  {&TA_int,NULL,"n_objs","0"},
  {&TA_TypeDef_ptr,NULL,"type","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_InheritsFrom_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetEnumString_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_tp_nm",""},
  {&TA_int,NULL,"enum_val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetEnumVal_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_nm",""},
  {&TA_taString_ref,NULL,"enum_tp_nm"," no_name"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Load_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Save_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SaveAs_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","0"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Edit_MethArgs[]={
  {&TA_bool,NULL,"wait","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_CopyFrom_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_from",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_to",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ChangeMyType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SelectForEdit_MethArgs[]={
  {&TA_MemberDef_ptr,NULL,"member",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SelectFunForEdit_MethArgs[]={
  {&TA_MethodDef_ptr,NULL,"function",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CallFun_MethArgs[]={
  {&TA_const_char_ptr,NULL,"fun_name",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Copy_Weights_MethArgs[]={
  {&TA_const_Layer_ptr,NULL,"src",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_WriteWeights_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReadWeights_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LayoutUnits_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Send_NetToLay_MethArgs[]={
  {&TA_Layer_ptr,NULL,"tolay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Act_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_TransformWeights_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"trans",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_AddNoiseToWeights_MethArgs[]={
  {&TA_const_Random_ref,NULL,"noise_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PruneCons_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"pre_proc",""},
  {NULL,"CountParam::Relation","rel",""},
  {&TA_float,NULL,"cmp_val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ProbAddCons_MethArgs[]={
  {&TA_float,NULL,"p_add_con",""},
  {&TA_float,NULL,"init_wt"," 0.0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LesionCons_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","1"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LesionUnits_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","1"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetLayerSpec_MethArgs[]={
  {&TA_LayerSpec_ptr,NULL,"sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"unitspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetUnitType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"td",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"conspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CheckConfig_MethArgs[]={
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"old_sp",""},
  {&TA_UnitSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"old_sp",""},
  {&TA_ConSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplacePrjnSpec_MethArgs[]={
  {&TA_ProjectionSpec_ptr,NULL,"old_sp",""},
  {&TA_ProjectionSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceLayerSpec_MethArgs[]={
  {&TA_LayerSpec_ptr,NULL,"old_sp",""},
  {&TA_LayerSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GridViewWeights_MethArgs[]={
  {&TA_GridLog_ptr,NULL,"grid_log",""},
  {&TA_Layer_ptr,NULL,"send_lay",""},
  {&TA_bool,NULL,"use_swt","0"},
  {&TA_int,NULL,"un_x","-1"},
  {&TA_int,NULL,"un_y","-1"},
  {&TA_int,NULL,"wt_x","-1"},
  {&TA_int,NULL,"wt_y","-1"},
  NULL};
static MethodArgs_data TA_LeabraLayer_WeightsToEnv_MethArgs[]={
  {&TA_Environment_ptr,NULL,"env",""},
  {&TA_Layer_ptr,NULL,"send_lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetExtFlag_MethArgs[]={
  {&TA_int,NULL,"flg",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_UnSetExtFlag_MethArgs[]={
  {&TA_int,NULL,"flg",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitGpFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetActGeomNoSpc_MethArgs[]={
  {&TA_PosTDCoord_ref,NULL,"nospc_geom",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetCurLrate_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_NetScale_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Send_ClampNet_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Inhib_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PhaseInit_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayEvent_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayPhase_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayPhase2_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ExtToComp_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_TargExtToComp_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PostSettle_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LeabraLayer_MethodDef[]={
  {&TA_void,NULL,"UnSafeCopy","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_UnSafeCopy_stub,TA_LeabraLayer_UnSafeCopy_MethArgs},
  {&TA_void,NULL,"CastCopyTo","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CastCopyTo_stub,TA_LeabraLayer_CastCopyTo_MethArgs},
  {&TA_TAPtr,NULL,"GetOwner","","","",
    3,1,-1,0,NULL,cssElCFun_LeabraLayer_GetOwner_stub,TA_LeabraLayer_GetOwner_MethArgs},
  {&TA_taString,NULL,"GetPath"," get path without name informtation, stop at par_stop if non-null","","",
    0,2,0,0,NULL,cssElCFun_LeabraLayer_GetPath_stub,TA_LeabraLayer_GetPath_MethArgs},
  {&TA_TAPtr,NULL,"FindFromPath"," find object from path (starting from this, and position start of the path)","","",
    0,3,1,0,NULL,cssElCFun_LeabraLayer_FindFromPath_stub,TA_LeabraLayer_FindFromPath_MethArgs},
  {&TA_TAPtr,NULL,"New"," Create n_objs objects of given type (type is optional)","","",
    0,2,0,0,NULL,cssElCFun_LeabraLayer_New_stub,TA_LeabraLayer_New_MethArgs},
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"InheritsFrom"," does this inherit from given type?","","",
    2,1,-1,0,NULL,cssElCFun_LeabraLayer_InheritsFrom_stub,TA_LeabraLayer_InheritsFrom_MethArgs},
  {&TA_taString,NULL,"GetEnumString"," get the name corresponding to given enum value in enum type enum_tp_nm","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_GetEnumString_stub,TA_LeabraLayer_GetEnumString_MethArgs},
  {&TA_int,NULL,"GetEnumVal"," get the enum value corresponding to the given enum name (-1 if not found), and sets enum_tp_nm to name of type this enum belongs in (empty if not found)","","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_GetEnumVal_stub,TA_LeabraLayer_GetEnumVal_MethArgs},
  {&TA_int,NULL,"Load"," Load object data from a file","MENU MENU_ON_Object ARGC_1 UPDATE_MENUS ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_Load_stub,TA_LeabraLayer_Load_MethArgs},
  {&TA_int,NULL,"Save"," Save object data to a file","MENU ARGC_1 QUICK_SAVE ","",
    0,3,1,0,NULL,cssElCFun_LeabraLayer_Save_stub,TA_LeabraLayer_Save_MethArgs},
  {&TA_int,NULL,"SaveAs"," Save object data to a new file","MENU ARGC_1 ","",
    0,3,1,0,NULL,cssElCFun_LeabraLayer_SaveAs_stub,TA_LeabraLayer_SaveAs_MethArgs},
  {&TA_int,NULL,"Edit"," Edit this object using the gui","MENU ARGC_0 MENU_ON_Object NO_SCRIPT ","",
    0,1,0,0,NULL,cssElCFun_LeabraLayer_Edit_stub,TA_LeabraLayer_Edit_MethArgs},
  {&TA_bool,NULL,"CloseEdit"," close any open edit dialogs for this object","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CloseEdit_stub,NULL},
  {&TA_void,NULL,"Close"," PERMANENTLY Destroy this object! This is not Iconify.","MENU CONFIRM NO_REVERT_AFTER LABEL_Close_(Destroy) ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Close_stub,NULL},
  {&TA_bool,NULL,"CopyFrom"," Copy from given object into this object","MENU MENU_SEP_BEFORE TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CopyFrom_stub,TA_LeabraLayer_CopyFrom_MethArgs},
  {&TA_bool,NULL,"CopyTo"," Copy to given object from this object","MENU TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CopyTo_stub,TA_LeabraLayer_CopyTo_MethArgs},
  {&TA_bool,NULL,"DuplicateMe"," Make another copy of myself (done through owner)","MENU CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_DuplicateMe_stub,NULL},
  {&TA_bool,NULL,"ChangeMyType"," Change me into a different type of object, copying current info (done through owner)","MENU TYPE_this UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_ChangeMyType_stub,TA_LeabraLayer_ChangeMyType_MethArgs},
  {&TA_bool,NULL,"SelectForEdit"," select a given member for editing in a select edit dialog -- if already on dialog, removes it & returns false (else true)","MENU ","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_SelectForEdit_stub,TA_LeabraLayer_SelectForEdit_MethArgs},
  {&TA_bool,NULL,"SelectFunForEdit"," select a given function (method) for calling in a select edit dialog -- if already on dialog, removes it & returns false (else true)","MENU ","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_SelectFunForEdit_stub,TA_LeabraLayer_SelectFunForEdit_MethArgs},
  {&TA_void,NULL,"Help"," get help on using this object","MENU ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Help_stub,NULL},
  {&TA_void,NULL,"CallFun"," call function of given name on this object, prompting for args using gui interface","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CallFun_stub,TA_LeabraLayer_CallFun_MethArgs},
  {&TA_void,NULL,"Copy_Weights"," copies weights from other layer (incl wts assoc with unit bias member)","MENU MENU_ON_Object MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Copy_Weights_stub,TA_LeabraLayer_Copy_Weights_MethArgs},
  {&TA_void,NULL,"WriteWeights"," write weight values out in a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_WriteWeights_stub,TA_LeabraLayer_WriteWeights_MethArgs},
  {&TA_void,NULL,"ReadWeights"," read weight values in from a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_ReadWeights_stub,TA_LeabraLayer_ReadWeights_MethArgs},
  {&TA_void,NULL,"Build"," build the units based on n_units, geom","MENU MENU_ON_Actions CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Build_stub,NULL},
  {&TA_void,NULL,"RecomputeGeometry"," recompute the layer's geometry specifcations","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RecomputeGeometry_stub,NULL},
  {&TA_void,NULL,"LayoutUnits"," layout the units according to layer geometry","ARGC_0 ","",
    0,1,0,0,NULL,cssElCFun_LeabraLayer_LayoutUnits_stub,TA_LeabraLayer_LayoutUnits_MethArgs},
  {&TA_void,NULL,"LayoutUnitGroups"," layout the unit groups according to layer group geometry and spacing","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_LayoutUnitGroups_stub,NULL},
  {&TA_void,NULL,"Connect"," connect the layer","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Connect_stub,NULL},
  {&TA_bool,NULL,"CheckBuild"," check if build needs to be performed (true if yes, false if no)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CheckBuild_stub,NULL},
  {&TA_bool,NULL,"CheckConnect"," check if connect needs to be performed (true if yes, false if no)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CheckConnect_stub,NULL},
  {&TA_void,NULL,"RemoveCons"," remove all connections in this layer","MENU CONFIRM MENU_SEP_BEFORE ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RemoveCons_stub,NULL},
  {&TA_void,NULL,"RemoveUnits"," remove all units in this layer (preserving groups)","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RemoveUnits_stub,NULL},
  {&TA_void,NULL,"RemoveUnitGroups"," remove all unit groups in this layer","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RemoveUnitGroups_stub,NULL},
  {&TA_void,NULL,"PreConnect"," prepare to connect the layer (create con_groups)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_PreConnect_stub,NULL},
  {&TA_void,NULL,"SyncSendPrjns"," synchronize sending projections with the recv projections so everyone's happy","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_SyncSendPrjns_stub,NULL},
  {&TA_void,NULL,"DisConnect"," disconnect layer from all others","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_DisConnect_stub,NULL},
  {&TA_int,NULL,"CountRecvCons"," count recv connections for all units in layer","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CountRecvCons_stub,NULL},
  {&TA_void,NULL,"InitExterns"," Initializes external and target inputs","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitExterns_stub,NULL},
  {&TA_void,NULL,"InitDelta"," Initialize the unit deltas","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitDelta_stub,NULL},
  {&TA_void,NULL,"InitState"," Initialize the unit state variables","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitState_stub,NULL},
  {&TA_void,NULL,"ModifyState"," Alters state in an algorithm-specific way (e.g., decay)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_ModifyState_stub,NULL},
  {&TA_void,NULL,"InitWtDelta"," Initialize the deltas","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitWtDelta_stub,NULL},
  {&TA_void,NULL,"InitWtState"," Initialize the weights","MENU LABEL_Init_Weights CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitWtState_stub,NULL},
  {&TA_void,NULL,"Compute_Net"," Compute NetInput","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Send_Net"," sender-based compute net-input sending to all layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Send_Net_stub,NULL},
  {&TA_void,NULL,"Send_NetToLay"," sender-based compute net-input sending only to tolay layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Send_NetToLay_stub,TA_LeabraLayer_Send_NetToLay_MethArgs},
  {&TA_void,NULL,"Send_NetToMe"," tell all layers that I receive from to send their net input to me","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Send_NetToMe_stub,NULL},
  {&TA_void,NULL,"Compute_Act"," Compute Activation","","",
    1,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Act_stub,TA_LeabraLayer_Compute_Act_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights for whole layer","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UpdateWeights_stub,NULL},
  {&TA_void,NULL,"Compute_dWt"," update weights for whole layer","","",
    2,0,-1,0,NULL,cssElCFun_LeabraLayer_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"TransformWeights"," apply given transformation to weights","MENU MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_TransformWeights_stub,TA_LeabraLayer_TransformWeights_MethArgs},
  {&TA_void,NULL,"AddNoiseToWeights"," add noise to weights using given noise specification","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_AddNoiseToWeights_stub,TA_LeabraLayer_AddNoiseToWeights_MethArgs},
  {&TA_int,NULL,"PruneCons"," remove weights that (after pre-proc) meet relation to compare val","MENU USE_RVAL ","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_PruneCons_stub,TA_LeabraLayer_PruneCons_MethArgs},
  {&TA_int,NULL,"ProbAddCons"," probabilistically add new connections (assuming prior pruning), init_wt = initial weight value of new connection","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_ProbAddCons_stub,TA_LeabraLayer_ProbAddCons_MethArgs},
  {&TA_int,NULL,"LesionCons"," remove connectiosn with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_LesionCons_stub,TA_LeabraLayer_LesionCons_MethArgs},
  {&TA_int,NULL,"LesionUnits"," remove units with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_LesionUnits_stub,TA_LeabraLayer_LesionUnits_MethArgs},
  {&TA_bool,NULL,"SetLayerSpec"," set the layer specification","MENU MENU_SEP_BEFORE ","",
    1,1,-1,0,NULL,cssElCFun_LeabraLayer_SetLayerSpec_stub,TA_LeabraLayer_SetLayerSpec_MethArgs},
  {&TA_LayerSpec_ptr,NULL,"GetLayerSpec","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_GetLayerSpec_stub,NULL},
  {&TA_bool,NULL,"SetUnitSpec"," set for all units in layer","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetUnitSpec_stub,TA_LeabraLayer_SetUnitSpec_MethArgs},
  {&TA_void,NULL,"SetUnitType"," set unit type for all units in layer (created by Build)","MENU TYPE_Unit ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetUnitType_stub,TA_LeabraLayer_SetUnitType_MethArgs},
  {&TA_bool,NULL,"SetConSpec"," set for all unit's connections in layer","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetConSpec_stub,TA_LeabraLayer_SetConSpec_MethArgs},
  {&TA_bool,NULL,"CheckTypes"," check that the object and spec types are all ok","MENU USE_RVAL ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CheckTypes_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,2,1,0,NULL,cssElCFun_LeabraLayer_CheckConfig_stub,TA_LeabraLayer_CheckConfig_MethArgs},
  {&TA_void,NULL,"FixPrjnIndexes"," fix the projection indicies of the connection groups (other_idx)","MENU ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_FixPrjnIndexes_stub,NULL},
  {&TA_int,NULL,"ReplaceUnitSpec"," switch any units/layers using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplaceUnitSpec_stub,TA_LeabraLayer_ReplaceUnitSpec_MethArgs},
  {&TA_int,NULL,"ReplaceConSpec"," switch any connections/projections using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplaceConSpec_stub,TA_LeabraLayer_ReplaceConSpec_MethArgs},
  {&TA_int,NULL,"ReplacePrjnSpec"," switch any projections using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplacePrjnSpec_stub,TA_LeabraLayer_ReplacePrjnSpec_MethArgs},
  {&TA_int,NULL,"ReplaceLayerSpec"," switch any layers using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplaceLayerSpec_stub,TA_LeabraLayer_ReplaceLayerSpec_MethArgs},
  {&TA_void,NULL,"GridViewWeights"," display entire set of weights from sending layer (use sending weights if use_swt) in grid log, -1 for x,y = use layer geometry (otherwise limits range, un= unit range, wt = weight (sending lay) range) ","MENU MENU_SEP_BEFORE NULL_OK ","",
    0,7,2,0,NULL,cssElCFun_LeabraLayer_GridViewWeights_stub,TA_LeabraLayer_GridViewWeights_MethArgs},
  {&TA_void,NULL,"WeightsToEnv"," send entire set of weights from sending layer to given environment (e.g., for analysis), with one event per receiving unit, and the pattern in the event reflects the weights into that unit","MENU NULL_OK ","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_WeightsToEnv_stub,TA_LeabraLayer_WeightsToEnv_MethArgs},
  {&TA_void,NULL,"SetExtFlag","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetExtFlag_stub,TA_LeabraLayer_SetExtFlag_MethArgs},
  {&TA_void,NULL,"UnSetExtFlag","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_UnSetExtFlag_stub,TA_LeabraLayer_UnSetExtFlag_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmCoord"," get unit from coordinates, taking into account group geometry if present (subtracts any gp_spc -- as if it is not present). ","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_FindUnitFmCoord_stub,TA_LeabraLayer_FindUnitFmCoord_MethArgs},
  {&TA_Unit_Group_ptr,NULL,"FindUnitGpFmCoord"," get unit group from group coordinates (i.e., within gp_geom, not unit coordinates)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_FindUnitGpFmCoord_stub,TA_LeabraLayer_FindUnitGpFmCoord_MethArgs},
  {&TA_void,NULL,"GetActGeomNoSpc"," get the actual geometry of the layer, subtracting any gp_spc that might be present (as if there were no spaces between unit groups)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_GetActGeomNoSpc_stub,TA_LeabraLayer_GetActGeomNoSpc_MethArgs},
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_SetVals_stub,TA_LeabraLayer_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_InitState_stub,TA_LeabraLayer_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_Copy__stub,TA_LeabraLayer_Inhib_Copy__MethArgs},
  {&TA_void,NULL,"InitInhib"," initialize inhibitory state","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitInhib_stub,NULL},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_SetCurLrate_stub,TA_LeabraLayer_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_Active_K","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Active_K_stub,NULL},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_HardClamp_stub,TA_LeabraLayer_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_NetScale_stub,TA_LeabraLayer_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Send_ClampNet_stub,TA_LeabraLayer_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Send_NetDelta_stub,NULL},
  {&TA_void,NULL,"Compute_Clamp_NetAvg","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Clamp_NetAvg_stub,TA_LeabraLayer_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_Inhib","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Inhib_stub,TA_LeabraLayer_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_InhibAvg_stub,TA_LeabraLayer_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"PhaseInit","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_PhaseInit_stub,TA_LeabraLayer_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay between events","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DecayEvent_stub,TA_LeabraLayer_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase"," decay between phases","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DecayPhase_stub,TA_LeabraLayer_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayPhase2"," decay between 2nd set of phases","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DecayPhase2_stub,TA_LeabraLayer_DecayPhase2_MethArgs},
  {&TA_void,NULL,"ExtToComp","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_ExtToComp_stub,TA_LeabraLayer_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_TargExtToComp_stub,TA_LeabraLayer_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle","","","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_PostSettle_stub,TA_LeabraLayer_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_WtFmLin_stub,TA_LeabraLayer_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_ResetSortBuf_stub,NULL},
  NULL};
static int LeabraCycle::* TA_LeabraCycle_MbrOff;
static MemberDef_data TA_LeabraCycle_MemberDef[]={
  {&TA_LeabraSettle_ptr,NULL,"leabra_settle"," pointer to parent settle proc","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCycle_MbrOff=(int LeabraCycle::*)(&LeabraCycle::leabra_settle))),0,NULL,0},
  NULL};
static MethodDef_data TA_LeabraCycle_MethodDef[]={
  {&TA_void,NULL,"Compute_Net","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Compute_Clamp_NetAvg","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Clamp_NetAvg_stub,NULL},
  {&TA_void,NULL,"Compute_Inhib","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Inhib_stub,NULL},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_InhibAvg_stub,NULL},
  {&TA_void,NULL,"Compute_Act","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Act_stub,NULL},
  NULL};
static int LeabraSettle::* TA_LeabraSettle_MbrOff;
static MemberDef_data TA_LeabraSettle_MemberDef[]={
  {&TA_LeabraTrial_ptr,NULL,"leabra_trial"," pointer to parent phase trial","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::leabra_trial))),0,NULL,0},
  {&TA_int,NULL,"min_cycles"," minimum number of cycles to settle for","DEF_15 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::min_cycles))),0,NULL,0},
  {&TA_int,NULL,"min_cycles_phase2"," minimum number of cycles to settle for in second phase","DEF_15 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::min_cycles_phase2))),0,NULL,0},
  {&TA_int,NULL,"netin_mod"," net input computation modulus: how often to compute netinput vs. activation update (2 = faster)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::netin_mod))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send netin deltas instead of raw netin: more efficient (automatically sets corresponding unitspec flag)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::send_delta))),0,NULL,0},
  NULL};
static MethodDef_data TA_LeabraSettle_MethodDef[]={
  {&TA_void,NULL,"Compute_Active_K","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_Active_K_stub,NULL},
  {&TA_void,NULL,"DecayEvent","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_DecayEvent_stub,NULL},
  {&TA_void,NULL,"DecayPhase","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_DecayPhase_stub,NULL},
  {&TA_void,NULL,"DecayPhase2","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_DecayPhase2_stub,NULL},
  {&TA_void,NULL,"PhaseInit","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_PhaseInit_stub,NULL},
  {&TA_void,NULL,"ExtToComp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_ExtToComp_stub,NULL},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_TargExtToComp_stub,NULL},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_HardClamp_stub,NULL},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_NetScale_stub,NULL},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Send_ClampNet_stub,NULL},
  {&TA_void,NULL,"PostSettle","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_PostSettle_stub,NULL},
  {&TA_void,NULL,"PostSettle_NStdLay","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_PostSettle_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_dWt_NStdLay"," on non-nstandard layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_dWt_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_dWt"," on all layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"UpdateWeights","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_UpdateWeights_stub,NULL},
  NULL};
static EnumDef_data TA_LeabraTrial_StateInit[]={
  {"DO_NOTHING"," do nothing","",0},
  {"INIT_STATE"," initialize state","",1},
  {"DECAY_STATE"," decay the state","",2},
  NULL};
static EnumDef_data TA_LeabraTrial_Phase[]={
  {"MINUS_PHASE"," minus phase","",0},
  {"PLUS_PHASE"," plus phase","",1},
  {"MINUS_2"," second minus phase","",2},
  {"PLUS_2"," second plus phase","",3},
  NULL};
static EnumDef_data TA_LeabraTrial_PhaseOrder[]={
  {"MINUS_PLUS"," standard minus-plus (err and assoc)","",0},
  {"PLUS_ONLY"," only present the plus phase (hebbian-only)","",1},
  {"MINUS_PLUS_NOTHING"," auto-encoder version with final 'nothing' minus phase","",2},
  {"PLUS_NOTHING"," just the auto-encoder (no initial minus phase)","",3},
  {"MINUS_PLUS_PLUS"," two plus phases for gated context layer updating","",4},
  {"MINUS_PLUS_2"," two minus-plus phases (for pfc/bg system)","",5},
  NULL};
static EnumDef_data TA_LeabraTrial_FirstPlusdWt[]={
  {"NO_FIRST_DWT"," for three phase cases: don't change weights after first plus","",0},
  {"ONLY_FIRST_DWT"," for three phase cases: only change weights after first plus","",1},
  {"ALL_DWT"," for three phase cases: change weights after *both* post-minus phases","",2},
  NULL};
static int LeabraTrial::* TA_LeabraTrial_MbrOff;
static MemberDef_data TA_LeabraTrial_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," [Default: MINUS_PLUS] number and order of phases to present","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase_order))),0,NULL,0},
  {&TA_Counter,NULL,"phase_no"," Current phase number","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase_no))),0,NULL,0},
  {NULL,"::Phase","phase"," Type of current phase: minus or plus","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase))),0,NULL,0},
  {NULL,"::StateInit","trial_init"," how to initialize network state at start of trial","DEF_DECAY_STATE ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::trial_init))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_stats"," don't do stats/logging in the plus phase","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::no_plus_stats))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_test"," don't run the plus phase when testing","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::no_plus_test))),0,NULL,0},
  {NULL,"::FirstPlusdWt","first_plus_dwt"," how to change weights on first plus phase if 2 plus phases (applies only to standard leabralayer specs -- others must decide on their own!)","CONDEDIT_ON_phase_order:MINUS_PLUS_PLUS ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::first_plus_dwt))),0,NULL,0},
  {&TA_int,NULL,"cycle"," current cycle value as copied from settle process ONLY VALID DURING PROCESSING","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::cycle))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraTrial_GenCntrLog_MethArgs[]={
  {&TA_LogData_ptr,NULL,"ld",""},
  {&TA_bool,NULL,"gen",""},
  NULL};
static MethodDef_data TA_LeabraTrial_MethodDef[]={
  {&TA_void,NULL,"GenCntrLog"," generate log data for the counters","","",
    1,2,-1,0,NULL,cssElCFun_LeabraTrial_GenCntrLog_stub,TA_LeabraTrial_GenCntrLog_MethArgs},
  {&TA_void,NULL,"InitState","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_InitState_stub,NULL},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_SetCurLrate_stub,NULL},
  {&TA_void,NULL,"DecayState","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_DecayState_stub,NULL},
  {&TA_void,NULL,"EncodeState","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_EncodeState_stub,NULL},
  {&TA_void,NULL,"Compute_dWt_NStdLay"," on non-nstandard layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_Compute_dWt_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"UpdateWeights","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_UpdateWeights_stub,NULL},
  NULL};
static EnumDef_data TA_LeabraMaxDa_dAType[]={
  {"DA_ONLY"," just use da","",0},
  {"INET_ONLY"," just use inet","",1},
  {"INET_DA"," use inet if no activity, then use da","",2},
  NULL};
static int LeabraMaxDa::* TA_LeabraMaxDa_MbrOff;
static MemberDef_data TA_LeabraMaxDa_MemberDef[]={
  {&TA_LeabraSettle_ptr,NULL,"settle_proc"," the settle process","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::settle_proc))),0,NULL,0},
  {NULL,"::dAType","da_type"," type of activation change measure to use","DEF_INET_DA ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::da_type))),0,NULL,0},
  {&TA_float,NULL,"inet_scale"," how to scale the inet measure to be like da","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::inet_scale))),0,NULL,0},
  {&TA_float,NULL,"lay_avg_thr"," threshold for layer average activation to switch to da fm Inet","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::lay_avg_thr))),0,NULL,0},
  {&TA_StatVal,NULL,"da"," absolute value of activation change","","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::da))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraMaxDa_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraMaxDa_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraMaxDa_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"unit",""},
  NULL};
static MethodDef_data TA_LeabraMaxDa_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraMaxDa_RecvCon_Run_stub,TA_LeabraMaxDa_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraMaxDa_SendCon_Run_stub,TA_LeabraMaxDa_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraMaxDa_Unit_Stat_stub,TA_LeabraMaxDa_Unit_Stat_MethArgs},
  NULL};
static int WtScaleSpec::* TA_WtScaleSpec_MbrOff;
static MemberDef_data TA_WtScaleSpec_MemberDef[]={
  {&TA_float,NULL,"abs"," absolute scaling (not subject to normalization: directly multiplies weight values)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_WtScaleSpec_MbrOff=(int WtScaleSpec::*)(&WtScaleSpec::abs))),0,NULL,0},
  {&TA_float,NULL,"rel"," [Default: 1] relative scaling (subject to normalization across all other projections into unit)","","",
    *((ta_memb_ptr*)&(TA_WtScaleSpec_MbrOff=(int WtScaleSpec::*)(&WtScaleSpec::rel))),0,NULL,0},
  NULL};
static MethodDef_data TA_WtScaleSpec_MethodDef[]={
  {&TA_float,NULL,"NetScale","","","",
    0,0,-1,0,NULL,cssElCFun_WtScaleSpec_NetScale_stub,NULL},
  NULL};
static int WtSigSpec::* TA_WtSigSpec_MbrOff;
static MemberDef_data TA_WtSigSpec_MemberDef[]={
  {&TA_float,NULL,"gain"," gain (contrast, sharpness) of the weight contrast function (1 = linear)","DEF_6 ","",
    *((ta_memb_ptr*)&(TA_WtSigSpec_MbrOff=(int WtSigSpec::*)(&WtSigSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"off"," offset of the function (1=centered at .5, >1=higher, <1=lower)","DEF_1.25 ","",
    *((ta_memb_ptr*)&(TA_WtSigSpec_MbrOff=(int WtSigSpec::*)(&WtSigSpec::off))),0,NULL,0},
  NULL};
static MethodArgs_data TA_WtSigSpec_SigFun_MethArgs[]={
  {&TA_float,NULL,"w",""},
  {&TA_float,NULL,"gain",""},
  {&TA_float,NULL,"off",""},
  NULL};
static MethodArgs_data TA_WtSigSpec_SigFunInv_MethArgs[]={
  {&TA_float,NULL,"w",""},
  {&TA_float,NULL,"gain",""},
  {&TA_float,NULL,"off",""},
  NULL};
static MethodDef_data TA_WtSigSpec_MethodDef[]={
  {&TA_float,NULL,"SigFun"," function for implementing inverse of weight sigmoid","","",
    0,3,-1,1,(ta_void_fun)(WtSigSpec::SigFun),cssElCFun_WtSigSpec_SigFun_stub,TA_WtSigSpec_SigFun_MethArgs},
  {&TA_float,NULL,"SigFunInv","","","",
    0,3,-1,1,(ta_void_fun)(WtSigSpec::SigFunInv),cssElCFun_WtSigSpec_SigFunInv_stub,TA_WtSigSpec_SigFunInv_MethArgs},
  NULL};
static int LearnMixSpec::* TA_LearnMixSpec_MbrOff;
static MemberDef_data TA_LearnMixSpec_MemberDef[]={
  {&TA_float,NULL,"hebb"," [Default: .01] amount of hebbian learning (should be relatively small, can be effective at .0001)","","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::hebb))),0,NULL,0},
  {&TA_float,NULL,"err"," [Default: .99] amount of error driven learning, automatically computed to be 1-hebb","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::err))),0,NULL,0},
  {&TA_bool,NULL,"err_sb"," apply exponential soft-bounding to the error learning component","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::err_sb))),0,NULL,0},
  NULL};
static int FixedSAvg::* TA_FixedSAvg_MbrOff;
static MemberDef_data TA_FixedSAvg_MemberDef[]={
  {&TA_bool,NULL,"fix"," use fixed val of sending avg activity level for normalizing netinput","DEF_false ","",
    *((ta_memb_ptr*)&(TA_FixedSAvg_MbrOff=(int FixedSAvg::*)(&FixedSAvg::fix))),0,NULL,0},
  {&TA_float,NULL,"savg"," [Default: .25] fixed sending average activity value","CONDEDIT_ON_fix:true ","",
    *((ta_memb_ptr*)&(TA_FixedSAvg_MbrOff=(int FixedSAvg::*)(&FixedSAvg::savg))),0,NULL,0},
  {&TA_bool,NULL,"div_gp_n"," in computing average netin, divide by the recv group n (number of actual connections), not the layer n","DEF_false ","",
    *((ta_memb_ptr*)&(TA_FixedSAvg_MbrOff=(int FixedSAvg::*)(&FixedSAvg::div_gp_n))),0,NULL,0},
  NULL};
static MethodArgs_data TA_FixedSAvg_GetSAvg_MethArgs[]={
  {&TA_float,NULL,"slayer_pct",""},
  NULL};
static MethodDef_data TA_FixedSAvg_MethodDef[]={
  {&TA_float,NULL,"GetSAvg","","","",
    0,1,-1,0,NULL,cssElCFun_FixedSAvg_GetSAvg_stub,TA_FixedSAvg_GetSAvg_MethArgs},
  NULL};
static EnumDef_data TA_SAvgCorSpec_SAvgSource[]={
  {"SLAYER_AVG_ACT"," use actual average activation computed over sending layer ","",0},
  {"SLAYER_TRG_PCT"," use target activation (from kwta) of sending layer","",1},
  {"FIXED_SAVG"," use the value specified in the fix_savg.savg","",2},
  {"COMPUTED_SAVG"," compute the average directly over the connections into each unit (EXPENSIVE!)","",3},
  NULL};
static int SAvgCorSpec::* TA_SAvgCorSpec_MbrOff;
static MemberDef_data TA_SAvgCorSpec_MemberDef[]={
  {&TA_float,NULL,"cor"," proportion of correction to apply (0=none, 1=all, .5=half, etc)","DEF_0.4 ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::cor))),0,NULL,0},
  {NULL,"::SAvgSource","src"," source of sending average act for renormalizing hebbian learning","DEF_SLAYER_AVG_ACT ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::src))),0,NULL,0},
  {&TA_float,NULL,"thresh"," threshold of sending average activation below which learning does not occur (prevents learning when there is no input)","DEF_0.001 ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::thresh))),0,NULL,0},
  NULL};
static int ActFunSpec::* TA_ActFunSpec_MbrOff;
static MemberDef_data TA_ActFunSpec_MemberDef[]={
  {&TA_float,NULL,"thr"," threshold value Theta (Q) for firing output activation ","DEF_0.25 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::thr))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain (gamma) of the sigmoidal rate-coded activation function ","DEF_600 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"nvar"," variance of the Gaussian noise kernel for convolving with XX1 in NOISY_XX1","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::nvar))),0,NULL,0},
  {&TA_float,NULL,"avg_dt"," time constant for integrating activation average (computed across trials)","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::avg_dt))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send only changes in activation when it changes beyond opt_thresh.delta: COPIED FROM LeabraSettle!","DEF_false READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::send_delta))),0,NULL,0},
  NULL};
static int SpikeFunSpec::* TA_SpikeFunSpec_MbrOff;
static MemberDef_data TA_SpikeFunSpec_MemberDef[]={
  {&TA_float,NULL,"decay"," exponential decay of activation produced by a spike (act(t+1) = act(t) * (1-decay))","DEF_0.05 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::decay))),0,NULL,0},
  {&TA_float,NULL,"v_m_r"," post-spiking membrane potential to reset to, produces refractory effect","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::v_m_r))),0,NULL,0},
  {&TA_float,NULL,"eq_gain"," gain for computing act_eq relative to actual average: act_eq = eq_gain * (spikes/cycles)","DEF_10 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::eq_gain))),0,NULL,0},
  {&TA_float,NULL,"eq_dt"," if non-zero, eq is computed as a running average with this time constant","DEF_0.02 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::eq_dt))),0,NULL,0},
  {&TA_float,NULL,"hard_gain"," gain for hard-clamped external inputs, mutliplies ext. constant external inputs otherwise have too much influence compared to spiking ones: Note: soft clamping is strongly recommended","DEF_0.4 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::hard_gain))),0,NULL,0},
  NULL};
static EnumDef_data TA_DepressSpec_PSpike[]={
  {"P_NXX1"," probability of spiking is based on NOISY_XX1 f(Vm - Q)","",0},
  {"P_LINEAR"," probability of spiking is based on LINEAR f(Vm - Q)","",1},
  NULL};
static int DepressSpec::* TA_DepressSpec_MbrOff;
static MemberDef_data TA_DepressSpec_MemberDef[]={
  {NULL,"::PSpike","p_spike"," how to compute the probability of spiking, which is then mult by amp of spiking","","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::p_spike))),0,NULL,0},
  {&TA_float,NULL,"rec"," rate of recovery of spike amplitude (determines overall time constant of depression function)","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::rec))),0,NULL,0},
  {&TA_float,NULL,"asymp_act"," asymptotic activation value (as proportion of 1) for a fully active unit (determines depl value)","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::asymp_act))),0,NULL,0},
  {&TA_float,NULL,"depl"," rate of depletion of spike amplitude as a function of activation output (computed from rec, asymp_act)","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::depl))),0,NULL,0},
  {&TA_float,NULL,"max_amp"," maximum amplitude required to maintain asymptotic firing at normal clamp levels (copied to act_range.max) ","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::max_amp))),0,NULL,0},
  NULL};
static int OptThreshSpec::* TA_OptThreshSpec_MbrOff;
static MemberDef_data TA_OptThreshSpec_MemberDef[]={
  {&TA_float,NULL,"send"," don't send activation when act <= send -- greatly speeds processing","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::send))),0,NULL,0},
  {&TA_float,NULL,"delta"," don't send activation changes until they exceed this threshold: only for when LeabraSettle::send_delta is on!","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::delta))),0,NULL,0},
  {&TA_float,NULL,"learn"," don't learn on recv unit weights when both phase acts <= learn","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::learn))),0,NULL,0},
  {&TA_bool,NULL,"updt_wts"," whether to apply learn threshold to updating weights (otherwise always update)","DEF_true ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::updt_wts))),0,NULL,0},
  {&TA_float,NULL,"phase_dif"," don't learn when +/- phase difference ratio (- / +) < phase_dif (.8 when used, but off by default)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::phase_dif))),0,NULL,0},
  NULL};
static int DtSpec::* TA_DtSpec_MbrOff;
static MemberDef_data TA_DtSpec_MemberDef[]={
  {&TA_float,NULL,"vm"," membrane potential time constant -- if units oscillate between 0 and 1, this is too high! reduce.","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::vm))),0,NULL,0},
  {&TA_float,NULL,"net"," net input time constant -- how fast to update net input (damps oscillations)","DEF_0.7 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::net))),0,NULL,0},
  NULL};
static int LeabraChannels::* TA_LeabraChannels_MbrOff;
static MemberDef_data TA_LeabraChannels_MemberDef[]={
  {&TA_float,NULL,"e"," Excitatory (glutamatergic synaptic sodium (Na) channel)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::e))),0,NULL,0},
  {&TA_float,NULL,"l"," Constant leak (potassium, K+) channel ","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::l))),0,NULL,0},
  {&TA_float,NULL,"i"," inhibitory","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::i))),0,NULL,0},
  {&TA_float,NULL,"h"," hysteresis (Ca)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::h))),0,NULL,0},
  {&TA_float,NULL,"a"," accomodation (k)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::a))),0,NULL,0},
  NULL};
static int VChanSpec::* TA_VChanSpec_MbrOff;
static MemberDef_data TA_VChanSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," true if channel is on","DEF_false ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::on))),0,NULL,0},
  {&TA_float,NULL,"b_dt"," time constant for integrating basis variable (basis ~ intracellular calcium which builds up slowly as function of activation)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::b_dt))),0,NULL,0},
  {&TA_float,NULL,"a_thr"," activation threshold of the channel: when basis > a_thr, conductance starts to build up (channels open)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::a_thr))),0,NULL,0},
  {&TA_float,NULL,"d_thr"," deactivation threshold of the channel: when basis < d_thr, conductance diminshes (channels close)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::d_thr))),0,NULL,0},
  {&TA_float,NULL,"g_dt"," time constant for changing conductance (activating or deactivating)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::g_dt))),0,NULL,0},
  {&TA_bool,NULL,"init"," initialize variables when state is intialized between trials (else with weights)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::init))),0,NULL,0},
  NULL};
static MethodArgs_data TA_VChanSpec_UpdateBasis_MethArgs[]={
  {&TA_float_ref,NULL,"basis",""},
  {&TA_bool_ref,NULL,"on_off",""},
  {&TA_float_ref,NULL,"gc",""},
  {&TA_float,NULL,"act",""},
  NULL};
static MethodDef_data TA_VChanSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateBasis","","","",
    0,4,-1,0,NULL,cssElCFun_VChanSpec_UpdateBasis_stub,TA_VChanSpec_UpdateBasis_MethArgs},
  NULL};
static EnumDef_data TA_PhaseSharpSpec_SharpType[]={
  {"NONE"," don't use phase-based sharpening","",0},
  {"SIG"," sharpen plus phase activation values by passing through sigmoidal function at each point in time","",1},
  {"SIG_END"," sharpen final plus phase activation values by passing through sigmoidal function: only at end of settling, not during","",2},
  {"NETIN"," sharpen plus phase net input values by increasing effective g_bar.e and .i values in plus phase","",3},
  NULL};
static int PhaseSharpSpec::* TA_PhaseSharpSpec_MbrOff;
static MemberDef_data TA_PhaseSharpSpec_MemberDef[]={
  {NULL,"::SharpType","type"," type of sharpening to apply","","",
    *((ta_memb_ptr*)&(TA_PhaseSharpSpec_MbrOff=(int PhaseSharpSpec::*)(&PhaseSharpSpec::type))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain of sigmoidal function for SIG -- extent above 1.0 determines sharpening","CONDEDIT_ON_type:SIG,SIG_END DEF_1.01 ","",
    *((ta_memb_ptr*)&(TA_PhaseSharpSpec_MbrOff=(int PhaseSharpSpec::*)(&PhaseSharpSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"off"," offset of sigmoidal function for SIG -- >1=offset >.5, etc","CONDEDIT_ON_type:SIG,SIG_END DEF_1 ","",
    *((ta_memb_ptr*)&(TA_PhaseSharpSpec_MbrOff=(int PhaseSharpSpec::*)(&PhaseSharpSpec::off))),0,NULL,0},
  {&TA_float,NULL,"delta"," how much to increase g_bar.e,.i values in plus phase ","CONDEDIT_ON_type:NETIN ","",
    *((ta_memb_ptr*)&(TA_PhaseSharpSpec_MbrOff=(int PhaseSharpSpec::*)(&PhaseSharpSpec::delta))),0,NULL,0},
  {&TA_float,NULL,"i_gain"," extra gain term for inhibitory netinput -- gain on inhib has smaller impact due to reversal potential dynamics","CONDEDIT_ON_type:NETIN DEF_1.6 ","",
    *((ta_memb_ptr*)&(TA_PhaseSharpSpec_MbrOff=(int PhaseSharpSpec::*)(&PhaseSharpSpec::i_gain))),0,NULL,0},
  {&TA_float,NULL,"act_gain"," extra netin gain as a function of unit activation","CONDEDIT_ON_type:NETIN DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_PhaseSharpSpec_MbrOff=(int PhaseSharpSpec::*)(&PhaseSharpSpec::act_gain))),0,NULL,0},
  NULL};
static int ActRegSpec::* TA_ActRegSpec_MbrOff;
static MemberDef_data TA_ActRegSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to activity regulation is on (active) or not","","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::on))),0,NULL,0},
  {&TA_float,NULL,"min"," increase weights for units below this level of average activation","CONDEDIT_ON_on:true DEF_0 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::min))),0,NULL,0},
  {&TA_float,NULL,"max"," decrease weights for units above this level of average activation ","CONDEDIT_ON_on:true DEF_0.35 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::max))),0,NULL,0},
  {&TA_float,NULL,"wt_dt"," pre-lrate rate constant for making weight changes to rectify over-activation (dwt = cur_lrate * wt_dt * wt)","CONDEDIT_ON_on:true DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::wt_dt))),0,NULL,0},
  NULL};
static int VChanBasis::* TA_VChanBasis_MbrOff;
static MemberDef_data TA_VChanBasis_MemberDef[]={
  {&TA_float,NULL,"hyst"," hysteresis","","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::hyst))),0,NULL,0},
  {&TA_float,NULL,"acc"," fast accomodation","","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::acc))),0,NULL,0},
  {&TA_bool,NULL,"hyst_on"," binary thresholded mode state variable, hyst","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::hyst_on))),0,NULL,0},
  {&TA_bool,NULL,"acc_on"," binary thresholded mode state variable, acc","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::acc_on))),0,NULL,0},
  {&TA_float,NULL,"g_h"," hysteresis conductance","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::g_h))),0,NULL,0},
  {&TA_float,NULL,"g_a"," accomodation conductance","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::g_a))),0,NULL,0},
  NULL};
static int LeabraUnitChans::* TA_LeabraUnitChans_MbrOff;
static MemberDef_data TA_LeabraUnitChans_MemberDef[]={
  {&TA_float,NULL,"l"," leak","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::l))),0,NULL,0},
  {&TA_float,NULL,"i"," inhibitory","DMEM_SHARE_SET_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::i))),0,NULL,0},
  {&TA_float,NULL,"h"," hysteresis (Ca)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::h))),0,NULL,0},
  {&TA_float,NULL,"a"," accomodation (K)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::a))),0,NULL,0},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Find_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Remove_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__SafeEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Edit_El_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUniqNameOld_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUniqNameOld_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FindEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Add_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUnique_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUniqNameNew_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Insert_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Replace_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","old_it",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__RemoveEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__DuplicateEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Link_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUnique_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUniqNameNew_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__InsertLink_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  {&TA_int,NULL,"idx"," -1"},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLink_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLinkEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","old_it",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLinkName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Push_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","from",""},
  {NULL,"::LeabraUnit_ptr","to",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Transfer_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveBefore_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","trg",""},
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveAfter_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","trg",""},
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodDef_data TA_taPtrList_LeabraUnit__MethodDef[]={
  {&TA_int,NULL,"Find"," find named element in list find element in list (-1 if not there)","","",
    2,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Find_stub,TA_taPtrList_LeabraUnit__Find_MethArgs},
  {&TA_bool,NULL,"Remove"," remove (and delete) element from list at index Remove element at given index","","",
    4,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Remove_stub,TA_taPtrList_LeabraUnit__Remove_MethArgs},
  {NULL,"::LeabraUnit_ptr","SafeEl"," element at index","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__SafeEl_stub,TA_taPtrList_LeabraUnit__SafeEl_MethArgs},
  {NULL,"::LeabraUnit_ptr","FastEl"," fast element (no range checking)","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FastEl_stub,TA_taPtrList_LeabraUnit__FastEl_MethArgs},
  {NULL,"::LeabraUnit_ptr","Edit_El"," Edit given list item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Edit_El_stub,TA_taPtrList_LeabraUnit__Edit_El_MethArgs},
  {NULL,"::LeabraUnit_ptr","FindName"," find given named element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FindName_stub,TA_taPtrList_LeabraUnit__FindName_MethArgs},
  {NULL,"::LeabraUnit_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Pop_stub,NULL},
  {NULL,"::LeabraUnit_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Peek_stub,NULL},
  {NULL,"::LeabraUnit_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUniqNameOld_stub,TA_taPtrList_LeabraUnit__AddUniqNameOld_MethArgs},
  {NULL,"::LeabraUnit_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUniqNameOld_stub,TA_taPtrList_LeabraUnit__LinkUniqNameOld_MethArgs},
  {&TA_int,NULL,"FindEl"," find given element in list (-1 if not there)","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FindEl_stub,TA_taPtrList_LeabraUnit__FindEl_MethArgs},
  {&TA_void,NULL,"AddEl"," append a new pointer to end of list","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddEl_stub,TA_taPtrList_LeabraUnit__AddEl_MethArgs},
  {&TA_void,NULL,"Add"," add element to the list and 'own' item","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Add_stub,TA_taPtrList_LeabraUnit__Add_MethArgs},
  {&TA_bool,NULL,"AddUnique"," add so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUnique_stub,TA_taPtrList_LeabraUnit__AddUnique_MethArgs},
  {&TA_bool,NULL,"AddUniqNameNew"," add so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUniqNameNew_stub,TA_taPtrList_LeabraUnit__AddUniqNameNew_MethArgs},
  {&TA_bool,NULL,"Insert"," Add or insert element at idx (-1 for end)","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Insert_stub,TA_taPtrList_LeabraUnit__Insert_MethArgs},
  {&TA_bool,NULL,"Replace"," replace element at index with the new one","","",
    2,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Replace_stub,TA_taPtrList_LeabraUnit__Replace_MethArgs},
  {&TA_bool,NULL,"ReplaceEl"," replace given element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceEl_stub,TA_taPtrList_LeabraUnit__ReplaceEl_MethArgs},
  {&TA_bool,NULL,"ReplaceName"," replace named element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceName_stub,TA_taPtrList_LeabraUnit__ReplaceName_MethArgs},
  {&TA_bool,NULL,"RemoveEl"," Remove given item from list","MENU LABEL_Remove ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__RemoveEl_stub,TA_taPtrList_LeabraUnit__RemoveEl_MethArgs},
  {&TA_bool,NULL,"DuplicateEl"," Duplicate given list item and Add to list","MENU ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__DuplicateEl_stub,TA_taPtrList_LeabraUnit__DuplicateEl_MethArgs},
  {&TA_void,NULL,"Link"," Link an item to list without owning it","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Link_stub,TA_taPtrList_LeabraUnit__Link_MethArgs},
  {&TA_bool,NULL,"LinkUnique"," link so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUnique_stub,TA_taPtrList_LeabraUnit__LinkUnique_MethArgs},
  {&TA_bool,NULL,"LinkUniqNameNew"," link so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUniqNameNew_stub,TA_taPtrList_LeabraUnit__LinkUniqNameNew_MethArgs},
  {&TA_bool,NULL,"InsertLink"," Insert a link at index (-1 for end)","MENU LABEL_Link UPDATE_MENUS ","",
    0,2,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__InsertLink_stub,TA_taPtrList_LeabraUnit__InsertLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLink"," replace element with a link to the new one","","",
    2,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLink_stub,TA_taPtrList_LeabraUnit__ReplaceLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkEl"," replace given element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLinkEl_stub,TA_taPtrList_LeabraUnit__ReplaceLinkEl_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkName"," replace given named element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLinkName_stub,TA_taPtrList_LeabraUnit__ReplaceLinkName_MethArgs},
  {&TA_void,NULL,"Push"," push item on stack (for temporary use, not 'owned')","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Push_stub,TA_taPtrList_LeabraUnit__Push_MethArgs},
  {&TA_bool,NULL,"MoveEl"," Move item (from) to position of (to)","MENU LABEL_Move ARG_ON_OBJ UPDATE_MENUS ","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveEl_stub,TA_taPtrList_LeabraUnit__MoveEl_MethArgs},
  {&TA_bool,NULL,"Transfer"," Transfer item to this list","MENU MENU_ON_Edit NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Transfer_stub,TA_taPtrList_LeabraUnit__Transfer_MethArgs},
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveBefore_stub,TA_taPtrList_LeabraUnit__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveAfter_stub,TA_taPtrList_LeabraUnit__MoveAfter_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraSort_FindNewNetPos_MethArgs[]={
  {&TA_float,NULL,"nw_net",""},
  NULL};
static MethodArgs_data TA_LeabraSort_FastInsertLink_MethArgs[]={
  {&TA_void_ptr,NULL,"it",""},
  {&TA_int,NULL,"where",""},
  NULL};
static MethodDef_data TA_LeabraSort_MethodDef[]={
  {&TA_int,NULL,"FindNewNetPos"," find position in list for a new net value","","",
    0,1,-1,0,NULL,cssElCFun_LeabraSort_FindNewNetPos_stub,TA_LeabraSort_FindNewNetPos_MethArgs},
  {&TA_void,NULL,"FastInsertLink"," faster version of insert link fun","","",
    0,2,-1,0,NULL,cssElCFun_LeabraSort_FastInsertLink_stub,TA_LeabraSort_FastInsertLink_MethArgs},
  NULL};
static EnumDef_data TA_KWTASpec_K_From[]={
  {"USE_K"," use the k specified directly","",0},
  {"USE_PCT"," use the percentage pct to compute the k as a function of layer size","",1},
  {"USE_PAT_K"," use the activity level of the current event pattern (k = of units > pat_q)"," ",2},
  NULL};
static int KWTASpec::* TA_KWTASpec_MbrOff;
static MemberDef_data TA_KWTASpec_MemberDef[]={
  {NULL,"::K_From","k_from"," how is the active_k determined: directly by k, by pct, or by no. of units where ext > pat_q","","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::k_from))),0,NULL,0},
  {&TA_int,NULL,"k"," desired number of active units in the layer","CONDEDIT_ON_k_from:USE_K ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::k))),0,NULL,0},
  {&TA_float,NULL,"pct"," desired proportion of activity (used to compute a k value based on layer size, .25 std)","CONDEDIT_ON_k_from:USE_PCT ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::pct))),0,NULL,0},
  {&TA_float,NULL,"pat_q"," threshold for pat_k based activity level: add to k if ext > pat_q","HIDDEN DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::pat_q))),0,NULL,0},
  {&TA_bool,NULL,"diff_act_pct"," if true, use different actual percent activity for overall layer activation","DEF_false ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::diff_act_pct))),0,NULL,0},
  {&TA_float,NULL,"act_pct"," actual percent activity to put in kwta.pct field of layer","CONDEDIT_ON_diff_act_pct:true ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::act_pct))),0,NULL,0},
  NULL};
static EnumDef_data TA_AdaptISpec_AdaptType[]={
  {"NONE"," don't adapt anything","",0},
  {"KWTA_PT"," adapt kwta point (i_kwta_pt) based on running-average layer activation as compared to target value","",1},
  {"G_BAR_I"," adapt g_bar.i for unit inhibition values based on layer activation at any point in time","",2},
  {"G_BAR_IL"," adapt g_bar.i and g_bar.l for unit inhibition & leak values based on layer activation at any point in time","",3},
  NULL};
static int AdaptISpec::* TA_AdaptISpec_MbrOff;
static MemberDef_data TA_AdaptISpec_MemberDef[]={
  {NULL,"::AdaptType","type"," what to adapt, or none for nothing","","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::type))),0,NULL,0},
  {&TA_float,NULL,"tol"," tolerance around target avg act before changing parameter","CONDEDIT_OFF_type:NONE DEF_0.02 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::tol))),0,NULL,0},
  {&TA_float,NULL,"p_dt"," time constant for changing the parameter (i_kwta_pt or g_bar.i)","CONDEDIT_OFF_type:NONE DEF_0.1 AKA_pt_dt ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::p_dt))),0,NULL,0},
  {&TA_float,NULL,"mx_d"," maximum deviation (proportion) from initial parameter setting allowed","CONDEDIT_OFF_type:NONE DEF_0.9 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::mx_d))),0,NULL,0},
  {&TA_float,NULL,"l"," proportion of difference from target activation to allocate to the leak in G_BAR_IL mode","CONDEDIT_ON_type:G_BAR_IL ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::l))),0,NULL,0},
  {&TA_float,NULL,"a_dt"," time constant for integrating average average activation, which is basis for adapting i_kwta_pt","CONDEDIT_ON_type:KWTA_PT DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::a_dt))),0,NULL,0},
  NULL};
static int ClampSpec::* TA_ClampSpec_MbrOff;
static MemberDef_data TA_ClampSpec_MemberDef[]={
  {&TA_bool,NULL,"hard"," whether to hard clamp inputs to this layer or not","DEF_true ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::hard))),0,NULL,0},
  {&TA_float,NULL,"gain"," starting soft clamp gain factor (net = gain * ext)","CONDEDIT_OFF_hard:true DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"d_gain"," [Default: 0] for soft clamp, delta to increase gain when target units not > .5 (0 = off, .1 std when used)","CONDEDIT_OFF_hard:true ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::d_gain))),0,NULL,0},
  NULL};
static int DecaySpec::* TA_DecaySpec_MbrOff;
static MemberDef_data TA_DecaySpec_MemberDef[]={
  {&TA_float,NULL,"event"," proportion decay of state vars between events","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::event))),0,NULL,0},
  {&TA_float,NULL,"phase"," proportion decay of state vars between minus and plus phases ","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::phase))),0,NULL,0},
  {&TA_float,NULL,"phase2"," proportion decay of state vars between 2nd set of phases (if appl, 0 std)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::phase2))),0,NULL,0},
  {&TA_bool,NULL,"clamp_phase2"," if true, hard-clamp second plus phase activations to prev plus phase (only special layers will then update -- optimizes speed)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::clamp_phase2))),0,NULL,0},
  NULL};
static int LayerLinkSpec::* TA_LayerLinkSpec_MbrOff;
static MemberDef_data TA_LayerLinkSpec_MemberDef[]={
  {&TA_bool,NULL,"link"," whether to link the inhibition across layers (or not)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LayerLinkSpec_MbrOff=(int LayerLinkSpec::*)(&LayerLinkSpec::link))),0,NULL,0},
  {&TA_float,NULL,"gain"," [Default: .5] strength of the inhibition link (how much to move inhib towards that of other layer(s))","CONDEDIT_ON_link:true ","",
    *((ta_memb_ptr*)&(TA_LayerLinkSpec_MbrOff=(int LayerLinkSpec::*)(&LayerLinkSpec::gain))),0,NULL,0},
  {&TA_bool,NULL,"gp_uses_lay_avg"," if using UNIT_GROUPS, use layer average activation for layer target activation percent (only for backward compatiblity)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LayerLinkSpec_MbrOff=(int LayerLinkSpec::*)(&LayerLinkSpec::gp_uses_lay_avg))),0,NULL,0},
  NULL};
static int SpecPtr<LeabraLayerSpec>::* TA_SpecPtr_LeabraLayerSpec__MbrOff;
static MemberDef_data TA_SpecPtr_LeabraLayerSpec__MemberDef[]={
  {NULL,"::LeabraLayerSpec_ptr","spec"," the actual spec itself","","",
    *((ta_memb_ptr*)&(TA_SpecPtr_LeabraLayerSpec__MbrOff=(int SpecPtr<LeabraLayerSpec>::*)(&SpecPtr<LeabraLayerSpec>::spec))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SpecPtr_LeabraLayerSpec__SetDefaultSpec_MethArgs[]={
  {&TA_TAPtr,NULL,"ownr",""},
  NULL};
static MethodDef_data TA_SpecPtr_LeabraLayerSpec__MethodDef[]={
  {&TA_void,NULL,"SetDefaultSpec"," for class that owns ptr","","",
    1,1,-1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__SetDefaultSpec_stub,TA_SpecPtr_LeabraLayerSpec__SetDefaultSpec_MethArgs},
  {&TA_bool,NULL,"CheckSpec","","","",
    1,0,-1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__CheckSpec_stub,NULL},
  {NULL,"::LeabraLayerSpec_ptr","NewChild","","","",
    0,0,-1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__NewChild_stub,NULL},
  NULL};
static int AvgMaxVals::* TA_AvgMaxVals_MbrOff;
static MemberDef_data TA_AvgMaxVals_MemberDef[]={
  {&TA_float,NULL,"avg"," average value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::avg))),0,NULL,0},
  {&TA_float,NULL,"max"," maximum value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::max))),0,NULL,0},
  {&TA_int,NULL,"max_i"," index of unit with maximum value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::max_i))),0,NULL,0},
  NULL};
static int KWTAVals::* TA_KWTAVals_MbrOff;
static MemberDef_data TA_KWTAVals_MemberDef[]={
  {&TA_int,NULL,"k"," target number of active units for this collection","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k))),0,NULL,0},
  {&TA_float,NULL,"pct"," actual percent activity in group","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::pct))),0,NULL,0},
  {&TA_float,NULL,"pct_c"," complement of (1.0 - ) actual percent activity in group","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::pct_c))),0,NULL,0},
  {&TA_int,NULL,"adth_k"," adapting threshold k value -- how many units can adapt per time","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::adth_k))),0,NULL,0},
  {&TA_float,NULL,"k_ithr"," inhib threshold for k unit (top k for kwta_avg)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k_ithr))),0,NULL,0},
  {&TA_float,NULL,"k1_ithr"," inhib threshold for k+1 unit (other units for kwta_avg)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k1_ithr))),0,NULL,0},
  {&TA_float,NULL,"ithr_r"," log of ratio of ithr values (indicates signal differentiation)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::ithr_r))),0,NULL,0},
  NULL};
static MethodArgs_data TA_KWTAVals_Compute_Pct_MethArgs[]={
  {&TA_int,NULL,"n_units",""},
  NULL};
static MethodDef_data TA_KWTAVals_MethodDef[]={
  {&TA_void,NULL,"Compute_Pct","","","",
    0,1,-1,0,NULL,cssElCFun_KWTAVals_Compute_Pct_stub,TA_KWTAVals_Compute_Pct_MethArgs},
  {&TA_void,NULL,"Compute_IThrR"," compute ithr_r ratio value","","",
    0,0,-1,0,NULL,cssElCFun_KWTAVals_Compute_IThrR_stub,NULL},
  NULL};
static int AdaptIVals::* TA_AdaptIVals_MbrOff;
static MemberDef_data TA_AdaptIVals_MemberDef[]={
  {&TA_float,NULL,"avg_avg"," average of the average activation in a layer","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::avg_avg))),0,NULL,0},
  {&TA_float,NULL,"i_kwta_pt"," adapting point to place inhibition between k and k+1 for kwta","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::i_kwta_pt))),0,NULL,0},
  {&TA_float,NULL,"g_bar_i"," adapting g_bar.i value ","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::g_bar_i))),0,NULL,0},
  {&TA_float,NULL,"g_bar_l"," adapting g_bar.l value ","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::g_bar_l))),0,NULL,0},
  NULL};
static int InhibVals::* TA_InhibVals_MbrOff;
static MemberDef_data TA_InhibVals_MemberDef[]={
  {&TA_float,NULL,"kwta"," inhibition due to kwta function","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::kwta))),0,NULL,0},
  {&TA_float,NULL,"g_i"," overall value of the inhibition","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::g_i))),0,NULL,0},
  {&TA_float,NULL,"g_i_orig"," original value of the inhibition (before linking)","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::g_i_orig))),0,NULL,0},
  NULL};
static int LayerLink::* TA_LayerLink_MbrOff;
static MemberDef_data TA_LayerLink_MemberDef[]={
  {&TA_LeabraLayer_ptr,NULL,"layer"," layer to link to","","",
    *((ta_memb_ptr*)&(TA_LayerLink_MbrOff=(int LayerLink::*)(&LayerLink::layer))),0,NULL,0},
  {&TA_float,NULL,"link_wt"," strength of the Link","","",
    *((ta_memb_ptr*)&(TA_LayerLink_MbrOff=(int LayerLink::*)(&LayerLink::link_wt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_taList_LayerLink__MoveBefore_MethArgs[]={
  {NULL,"::LayerLink_ptr","trg",""},
  {NULL,"::LayerLink_ptr","item",""},
  NULL};
static MethodArgs_data TA_taList_LayerLink__MoveAfter_MethArgs[]={
  {NULL,"::LayerLink_ptr","trg",""},
  {NULL,"::LayerLink_ptr","item",""},
  NULL};
static MethodArgs_data TA_taList_LayerLink__SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taList_LayerLink__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taList_LayerLink__Edit_El_MethArgs[]={
  {NULL,"::LayerLink_ptr","item",""},
  NULL};
static MethodArgs_data TA_taList_LayerLink__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taList_LayerLink__FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taList_LayerLink__AddUniqNameOld_MethArgs[]={
  {NULL,"::LayerLink_ptr","item",""},
  NULL};
static MethodArgs_data TA_taList_LayerLink__LinkUniqNameOld_MethArgs[]={
  {NULL,"::LayerLink_ptr","item",""},
  NULL};
static MethodDef_data TA_taList_LayerLink__MethodDef[]={
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taList_LayerLink__MoveBefore_stub,TA_taList_LayerLink__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taList_LayerLink__MoveAfter_stub,TA_taList_LayerLink__MoveAfter_MethArgs},
  {NULL,"::LayerLink_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_taList_LayerLink__SafeEl_stub,TA_taList_LayerLink__SafeEl_MethArgs},
  {NULL,"::LayerLink_ptr","FastEl"," fast element (no range checking)","","",
    0,1,-1,0,NULL,cssElCFun_taList_LayerLink__FastEl_stub,TA_taList_LayerLink__FastEl_MethArgs},
  {NULL,"::LayerLink_ptr","DefaultEl"," returns the element specified as the default for this list","","",
    0,0,-1,0,NULL,cssElCFun_taList_LayerLink__DefaultEl_stub,NULL},
  {NULL,"::LayerLink_ptr","Edit_El"," Edit given list item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taList_LayerLink__Edit_El_stub,TA_taList_LayerLink__Edit_El_MethArgs},
  {NULL,"::LayerLink_ptr","FindName"," Find element with given name (item_nm) ","MENU USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_taList_LayerLink__FindName_stub,TA_taList_LayerLink__FindName_MethArgs},
  {NULL,"::LayerLink_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taList_LayerLink__FindType_stub,TA_taList_LayerLink__FindType_MethArgs},
  {NULL,"::LayerLink_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taList_LayerLink__Pop_stub,NULL},
  {NULL,"::LayerLink_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taList_LayerLink__Peek_stub,NULL},
  {NULL,"::LayerLink_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taList_LayerLink__AddUniqNameOld_stub,TA_taList_LayerLink__AddUniqNameOld_MethArgs},
  {NULL,"::LayerLink_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taList_LayerLink__LinkUniqNameOld_stub,TA_taList_LayerLink__LinkUniqNameOld_MethArgs},
  NULL};
static int LeabraSE_Stat::* TA_LeabraSE_Stat_MbrOff;
static MemberDef_data TA_LeabraSE_Stat_MemberDef[]={
  {&TA_LeabraTrial_ptr,NULL,"trial_proc"," the trial process to get phase info","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::trial_proc))),0,NULL,0},
  {NULL,"Unit::ExtType","targ_or_comp"," when to compute SE: targ = 1st minus, comp = 2nd minus, both = both","","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::targ_or_comp))),0,NULL,0},
  {&TA_bool,NULL,"no_off_err"," do not count a unit wrong if it is off but target says on -- only count wrong units that are on but should be off","","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::no_off_err))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraSE_Stat_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"unit",""},
  NULL};
static MethodDef_data TA_LeabraSE_Stat_MethodDef[]={
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSE_Stat_Unit_Stat_stub,TA_LeabraSE_Stat_Unit_Stat_MethArgs},
  NULL};
static int LeabraGoodStat::* TA_LeabraGoodStat_MbrOff;
static MemberDef_data TA_LeabraGoodStat_MemberDef[]={
  {&TA_bool,NULL,"subtr_inhib"," subtract inhibition from harmony?","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::subtr_inhib))),0,NULL,0},
  {&TA_StatVal,NULL,"hrmny"," harmony = act * netin = a_i sum_j a_j w_ij","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::hrmny))),0,NULL,0},
  {&TA_StatVal,NULL,"strss"," stress = act * log(act)","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::strss))),0,NULL,0},
  {&TA_StatVal,NULL,"gdnss"," goodness = harmony + stress","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::gdnss))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraGoodStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraGoodStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraGoodStat_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  NULL};
static MethodDef_data TA_LeabraGoodStat_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraGoodStat_RecvCon_Run_stub,TA_LeabraGoodStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraGoodStat_SendCon_Run_stub,TA_LeabraGoodStat_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraGoodStat_Unit_Stat_stub,TA_LeabraGoodStat_Unit_Stat_MethArgs},
  NULL};
static int LeabraSharpStat::* TA_LeabraSharpStat_MbrOff;
static MemberDef_data TA_LeabraSharpStat_MemberDef[]={
  {&TA_StatVal,NULL,"sharp"," sharpness = max / avg ","","",
    *((ta_memb_ptr*)&(TA_LeabraSharpStat_MbrOff=(int LeabraSharpStat::*)(&LeabraSharpStat::sharp))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_Unit_Run_MethArgs[]={
  {&TA_Layer_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_Layer_Stat_MethArgs[]={
  {&TA_Layer_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_LeabraSharpStat_MethodDef[]={
  {&TA_void,NULL,"Unit_Run"," Compute over units in a layer no unit stat","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_Unit_Run_stub,TA_LeabraSharpStat_Unit_Run_MethArgs},
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_RecvCon_Run_stub,TA_LeabraSharpStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_SendCon_Run_stub,TA_LeabraSharpStat_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Layer_Stat"," Compute statistic on a layer","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_Layer_Stat_stub,TA_LeabraSharpStat_Layer_Stat_MethArgs},
  NULL};
static int WrongOnStat::* TA_WrongOnStat_MbrOff;
static MemberDef_data TA_WrongOnStat_MemberDef[]={
  {&TA_Layer_ptr,NULL,"trg_lay"," target layer, containing activation pattern for all possible correct responses","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::trg_lay))),0,NULL,0},
  {&TA_StatVal,NULL,"wrng"," wrong on error statistic","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::wrng))),0,NULL,0},
  {&TA_float,NULL,"threshold"," activation value to consider unit being on","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::threshold))),0,NULL,0},
  NULL};
static MethodArgs_data TA_WrongOnStat_Unit_Run_MethArgs[]={
  {&TA_Layer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_WrongOnStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_WrongOnStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_WrongOnStat_MethodDef[]={
  {&TA_void,NULL,"Unit_Run"," Compute over units in a layer","","",
    1,1,-1,0,NULL,cssElCFun_WrongOnStat_Unit_Run_stub,TA_WrongOnStat_Unit_Run_MethArgs},
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_WrongOnStat_RecvCon_Run_stub,TA_WrongOnStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_WrongOnStat_SendCon_Run_stub,TA_WrongOnStat_SendCon_Run_MethArgs},
  NULL};
static int ACRewSpec::* TA_ACRewSpec_MbrOff;
static MemberDef_data TA_ACRewSpec_MemberDef[]={
  {&TA_float,NULL,"discount"," discount factor for future rewards","","",
    *((ta_memb_ptr*)&(TA_ACRewSpec_MbrOff=(int ACRewSpec::*)(&ACRewSpec::discount))),0,NULL,0},
  {&TA_float,NULL,"inv_disc"," inverse of discount factor","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ACRewSpec_MbrOff=(int ACRewSpec::*)(&ACRewSpec::inv_disc))),0,NULL,0},
  {&TA_bool,NULL,"reset"," whether to reset to 0 after external reward received","","",
    *((ta_memb_ptr*)&(TA_ACRewSpec_MbrOff=(int ACRewSpec::*)(&ACRewSpec::reset))),0,NULL,0},
  {&TA_float,NULL,"val"," value to reset to after reward","CONDEDIT_ON_reset:true ","",
    *((ta_memb_ptr*)&(TA_ACRewSpec_MbrOff=(int ACRewSpec::*)(&ACRewSpec::val))),0,NULL,0},
  {&TA_bool,NULL,"immediate"," rewards are provided immediately for each pattern","","",
    *((ta_memb_ptr*)&(TA_ACRewSpec_MbrOff=(int ACRewSpec::*)(&ACRewSpec::immediate))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraACLayerSpec_TDModType[]={
  {"MOD_NOTHING"," don't modulate anything","",0},
  {"MOD_ERR"," modulate unit err","",1},
  {"MOD_GAIN"," modulate unit gain","",2},
  NULL};
static int LeabraACLayerSpec::* TA_LeabraACLayerSpec_MbrOff;
static MemberDef_data TA_LeabraACLayerSpec_MemberDef[]={
  {&TA_ACRewSpec,NULL,"rew"," reward specs: discount factor (1), reset reward after ext rec'd (true), val to reset to (.1), immediate = rewards on each trial","","",
    *((ta_memb_ptr*)&(TA_LeabraACLayerSpec_MbrOff=(int LeabraACLayerSpec::*)(&LeabraACLayerSpec::rew))),0,NULL,0},
  {NULL,"::TDModType","mod_type"," how to modulate units","","",
    *((ta_memb_ptr*)&(TA_LeabraACLayerSpec_MbrOff=(int LeabraACLayerSpec::*)(&LeabraACLayerSpec::mod_type))),0,NULL,0},
  {&TA_UnitSpec_SPtr,NULL,"un_gain_spec"," UnitSpec to modulate err, gain on","CONDEDIT_OFF_mod_type:MOD_NOTHING ","",
    *((ta_memb_ptr*)&(TA_LeabraACLayerSpec_MbrOff=(int LeabraACLayerSpec::*)(&LeabraACLayerSpec::un_gain_spec))),0,NULL,0},
  {&TA_float,NULL,"err_delta"," maximum err delta for MOD_ERR","CONDEDIT_ON_mod_type:MOD_ERR ","",
    *((ta_memb_ptr*)&(TA_LeabraACLayerSpec_MbrOff=(int LeabraACLayerSpec::*)(&LeabraACLayerSpec::err_delta))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"un_gain_range"," range of gain values to modulate for unit","CONDEDIT_ON_mod_type:MOD_GAIN ","",
    *((ta_memb_ptr*)&(TA_LeabraACLayerSpec_MbrOff=(int LeabraACLayerSpec::*)(&LeabraACLayerSpec::un_gain_range))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraACLayerSpec_UpdateUnitGain_MethArgs[]={
  {&TA_LeabraUnitSpec_ptr,NULL,"us",""},
  {&TA_float,NULL,"new_gain",""},
  NULL};
static MethodArgs_data TA_LeabraACLayerSpec_UpdateUnitErr_MethArgs[]={
  {&TA_LeabraUnitSpec_ptr,NULL,"us",""},
  {&TA_float,NULL,"new_err",""},
  NULL};
static MethodDef_data TA_LeabraACLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateUnitGain"," update the unit spec after new value copied","","",
    0,2,-1,0,NULL,cssElCFun_LeabraACLayerSpec_UpdateUnitGain_stub,TA_LeabraACLayerSpec_UpdateUnitGain_MethArgs},
  {&TA_void,NULL,"UpdateUnitErr"," update the unit spec after new value copied","","",
    0,2,-1,0,NULL,cssElCFun_LeabraACLayerSpec_UpdateUnitErr_stub,TA_LeabraACLayerSpec_UpdateUnitErr_MethArgs},
  NULL};
static int CtxtUpdateSpec::* TA_CtxtUpdateSpec_MbrOff;
static MemberDef_data TA_CtxtUpdateSpec_MemberDef[]={
  {&TA_float,NULL,"fm_hid"," from hidden (inputs to context layer)","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::fm_hid))),0,NULL,0},
  {&TA_float,NULL,"fm_prv"," from previous context layer values (maintenance)","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::fm_prv))),0,NULL,0},
  {&TA_float,NULL,"to_out"," outputs from context layer","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::to_out))),0,NULL,0},
  NULL};
static int LeabraContextLayerSpec::* TA_LeabraContextLayerSpec_MbrOff;
static MemberDef_data TA_LeabraContextLayerSpec_MemberDef[]={
  {&TA_CtxtUpdateSpec,NULL,"updt"," ctxt updating constants: from hidden, from previous values (hysteresis), outputs from context (n/a on simple gate layer)","","",
    *((ta_memb_ptr*)&(TA_LeabraContextLayerSpec_MbrOff=(int LeabraContextLayerSpec::*)(&LeabraContextLayerSpec::updt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraContextLayerSpec_Compute_Context_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LeabraContextLayerSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_Context"," get context source value for given context unit","","",
    0,3,-1,0,NULL,cssElCFun_LeabraContextLayerSpec_Compute_Context_stub,TA_LeabraContextLayerSpec_Compute_Context_MethArgs},
  NULL};
static EnumDef_data TA_GateSpec_MaintMode[]={
  {"EXTRACELL"," maintenance performed by extracellular mechanisms (collaterals)","",0},
  {"INTRACELL"," also intracellular maintenance ","",1},
  NULL};
static EnumDef_data TA_GateSpec_OutMod[]={
  {"NO_OUT"," don't modulate output con strength","",0},
  {"TD_MOD"," modulate as function of TD err just like inputs","",1},
  NULL};
static int GateSpec::* TA_GateSpec_MbrOff;
static MemberDef_data TA_GateSpec_MemberDef[]={
  {NULL,"::MaintMode","maint"," how to maintain activity: extracellular vs intracellular","","",
    *((ta_memb_ptr*)&(TA_GateSpec_MbrOff=(int GateSpec::*)(&GateSpec::maint))),0,NULL,0},
  {NULL,"::OutMod","out"," how to modulate output connections","","",
    *((ta_memb_ptr*)&(TA_GateSpec_MbrOff=(int GateSpec::*)(&GateSpec::out))),0,NULL,0},
  {&TA_bool,NULL,"reset"," reset activations after receiving external reward","","",
    *((ta_memb_ptr*)&(TA_GateSpec_MbrOff=(int GateSpec::*)(&GateSpec::reset))),0,NULL,0},
  NULL};
static int GateNoiseSpec::* TA_GateNoiseSpec_MbrOff;
static MemberDef_data TA_GateNoiseSpec_MemberDef[]={
  {&TA_float,NULL,"p_pos"," probability of a positive noise value","","",
    *((ta_memb_ptr*)&(TA_GateNoiseSpec_MbrOff=(int GateNoiseSpec::*)(&GateNoiseSpec::p_pos))),0,NULL,0},
  {&TA_float,NULL,"pos_var"," variance of the positive noise distribution","","",
    *((ta_memb_ptr*)&(TA_GateNoiseSpec_MbrOff=(int GateNoiseSpec::*)(&GateNoiseSpec::pos_var))),0,NULL,0},
  {&TA_float,NULL,"neg_var"," variance of the negative noise distribution","","",
    *((ta_memb_ptr*)&(TA_GateNoiseSpec_MbrOff=(int GateNoiseSpec::*)(&GateNoiseSpec::neg_var))),0,NULL,0},
  {&TA_float,NULL,"pos_thr"," threshold for always updating the state: positive td","","",
    *((ta_memb_ptr*)&(TA_GateNoiseSpec_MbrOff=(int GateNoiseSpec::*)(&GateNoiseSpec::pos_thr))),0,NULL,0},
  {&TA_float,NULL,"neg_thr"," threshold for always updating the state: negative td","","",
    *((ta_memb_ptr*)&(TA_GateNoiseSpec_MbrOff=(int GateNoiseSpec::*)(&GateNoiseSpec::neg_thr))),0,NULL,0},
  NULL};
static int LeabraGatedCtxLayerSpec::* TA_LeabraGatedCtxLayerSpec_MbrOff;
static MemberDef_data TA_LeabraGatedCtxLayerSpec_MemberDef[]={
  {&TA_CtxtUpdateSpec,NULL,"base"," base values for the gating constants","","",
    *((ta_memb_ptr*)&(TA_LeabraGatedCtxLayerSpec_MbrOff=(int LeabraGatedCtxLayerSpec::*)(&LeabraGatedCtxLayerSpec::base))),0,NULL,0},
  {&TA_GateSpec,NULL,"gate"," gating parameters: maintance by extracellular only, or plus intracellular, out = modulate output values?, reset = reset after reward?","","",
    *((ta_memb_ptr*)&(TA_LeabraGatedCtxLayerSpec_MbrOff=(int LeabraGatedCtxLayerSpec::*)(&LeabraGatedCtxLayerSpec::gate))),0,NULL,0},
  {&TA_GateNoiseSpec,NULL,"gate_noise"," noise in the gating term","","",
    *((ta_memb_ptr*)&(TA_LeabraGatedCtxLayerSpec_MbrOff=(int LeabraGatedCtxLayerSpec::*)(&LeabraGatedCtxLayerSpec::gate_noise))),0,NULL,0},
  {&TA_ConSpec_SPtr,NULL,"in_con_spec"," incoming connections to modulate using fm_hid (DYNAMIC)","","",
    *((ta_memb_ptr*)&(TA_LeabraGatedCtxLayerSpec_MbrOff=(int LeabraGatedCtxLayerSpec::*)(&LeabraGatedCtxLayerSpec::in_con_spec))),0,NULL,0},
  {&TA_ConSpec_SPtr,NULL,"maint_con_spec"," maintenance (lateral) cons mod using fm_prv (reset when td is neg)","","",
    *((ta_memb_ptr*)&(TA_LeabraGatedCtxLayerSpec_MbrOff=(int LeabraGatedCtxLayerSpec::*)(&LeabraGatedCtxLayerSpec::maint_con_spec))),0,NULL,0},
  {&TA_ConSpec_SPtr,NULL,"out_con_spec"," output cons to modulate using to_out based on out_mod","","",
    *((ta_memb_ptr*)&(TA_LeabraGatedCtxLayerSpec_MbrOff=(int LeabraGatedCtxLayerSpec::*)(&LeabraGatedCtxLayerSpec::out_con_spec))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraGatedCtxLayerSpec_FindACLayer_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraGatedCtxLayerSpec_Get_TD_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int,NULL,"ac_prjn_idx",""},
  NULL};
static MethodArgs_data TA_LeabraGatedCtxLayerSpec_Get_RewReset_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int,NULL,"ac_prjn_idx",""},
  NULL};
static MethodArgs_data TA_LeabraGatedCtxLayerSpec_UpdateConSpec_MethArgs[]={
  {&TA_LeabraConSpec_ptr,NULL,"cs",""},
  {&TA_float,NULL,"new_gain",""},
  NULL};
static MethodArgs_data TA_LeabraGatedCtxLayerSpec_UndoHardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodDef_data TA_LeabraGatedCtxLayerSpec_MethodDef[]={
  {&TA_int,NULL,"FindACLayer"," find the projection from the AC layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraGatedCtxLayerSpec_FindACLayer_stub,TA_LeabraGatedCtxLayerSpec_FindACLayer_MethArgs},
  {&TA_float,NULL,"Get_TD"," get the td error value from AC unit on 2nd connection into 1st unit in layer","","",
    0,2,-1,0,NULL,cssElCFun_LeabraGatedCtxLayerSpec_Get_TD_stub,TA_LeabraGatedCtxLayerSpec_Get_TD_MethArgs},
  {&TA_bool,NULL,"Get_RewReset"," get the reward reset from AC unit on 2nd connection into 1st unit in layer","","",
    0,2,-1,0,NULL,cssElCFun_LeabraGatedCtxLayerSpec_Get_RewReset_stub,TA_LeabraGatedCtxLayerSpec_Get_RewReset_MethArgs},
  {&TA_void,NULL,"UpdateConSpec"," update the connection spec wt_scale.abs with new gain value","","",
    0,2,-1,0,NULL,cssElCFun_LeabraGatedCtxLayerSpec_UpdateConSpec_stub,TA_LeabraGatedCtxLayerSpec_UpdateConSpec_MethArgs},
  {&TA_void,NULL,"UndoHardClamp"," undo hard clamp settings so that layer will settle normally","","",
    0,1,-1,0,NULL,cssElCFun_LeabraGatedCtxLayerSpec_UndoHardClamp_stub,TA_LeabraGatedCtxLayerSpec_UndoHardClamp_MethArgs},
  NULL};
static int LeabraACMaintLayerSpec::* TA_LeabraACMaintLayerSpec_MbrOff;
static MemberDef_data TA_LeabraACMaintLayerSpec_MemberDef[]={
  {&TA_float,NULL,"td_clear_thresh"," Threshold td value for clearing previous intracel. maint currents","","",
    *((ta_memb_ptr*)&(TA_LeabraACMaintLayerSpec_MbrOff=(int LeabraACMaintLayerSpec::*)(&LeabraACMaintLayerSpec::td_clear_thresh))),0,NULL,0},
  {&TA_bool,NULL,"ignore_td"," do not pay attention to td signal at all","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraACMaintLayerSpec_MbrOff=(int LeabraACMaintLayerSpec::*)(&LeabraACMaintLayerSpec::ignore_td))),0,NULL,0},
  {&TA_float,NULL,"min_ac_pred"," minimum AC prediction value in minus phase: AC must always predict SOME amount of reward","","",
    *((ta_memb_ptr*)&(TA_LeabraACMaintLayerSpec_MbrOff=(int LeabraACMaintLayerSpec::*)(&LeabraACMaintLayerSpec::min_ac_pred))),0,NULL,0},
  {&TA_bool,NULL,"clear_bwt_pos_td"," clear bias weights when a positive (> td_clear_thresh) TD signal is received","","",
    *((ta_memb_ptr*)&(TA_LeabraACMaintLayerSpec_MbrOff=(int LeabraACMaintLayerSpec::*)(&LeabraACMaintLayerSpec::clear_bwt_pos_td))),0,NULL,0},
  {&TA_int,NULL,"ac_prjn_idx"," projection that has the AC layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraACMaintLayerSpec_MbrOff=(int LeabraACMaintLayerSpec::*)(&LeabraACMaintLayerSpec::ac_prjn_idx))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraACMaintLayerSpec_FindACLayer_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraACMaintLayerSpec_Get_TD_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraACMaintLayerSpec_Get_RewReset_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodDef_data TA_LeabraACMaintLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_LeabraACMaintLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"FindACLayer"," find the projection from the AC layer, set ac_prjn_idx","","",
    0,1,-1,0,NULL,cssElCFun_LeabraACMaintLayerSpec_FindACLayer_stub,TA_LeabraACMaintLayerSpec_FindACLayer_MethArgs},
  {&TA_float,NULL,"Get_TD"," get the td error value from AC unit on 2nd connection into 1st unit in layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraACMaintLayerSpec_Get_TD_stub,TA_LeabraACMaintLayerSpec_Get_TD_MethArgs},
  {&TA_bool,NULL,"Get_RewReset"," get the reward reset from AC unit on 2nd connection into 1st unit in layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraACMaintLayerSpec_Get_RewReset_stub,TA_LeabraACMaintLayerSpec_Get_RewReset_MethArgs},
  NULL};
static EnumDef_data TA_PhaseOrderEventSpec_PhaseOrder[]={
  {"MINUS_PLUS"," minus phase, then plus phase","",0},
  {"PLUS_MINUS"," plus phase, then minus phase","",1},
  {"MINUS_ONLY"," only present minus","",2},
  {"PLUS_ONLY"," only present plus","",3},
  NULL};
static int PhaseOrderEventSpec::* TA_PhaseOrderEventSpec_MbrOff;
static MemberDef_data TA_PhaseOrderEventSpec_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," order to present phases of stimuli to network","","",
    *((ta_memb_ptr*)&(TA_PhaseOrderEventSpec_MbrOff=(int PhaseOrderEventSpec::*)(&PhaseOrderEventSpec::phase_order))),0,NULL,0},
  NULL};
static int LeabraTimeUnit::* TA_LeabraTimeUnit_MbrOff;
static MemberDef_data TA_LeabraTimeUnit_MemberDef[]={
  {&TA_float,NULL,"p_act_m"," previous minus phase activation ","","",
    *((ta_memb_ptr*)&(TA_LeabraTimeUnit_MbrOff=(int LeabraTimeUnit::*)(&LeabraTimeUnit::p_act_m))),0,NULL,0},
  {&TA_float,NULL,"p_act_p"," previous plus phase activation","","",
    *((ta_memb_ptr*)&(TA_LeabraTimeUnit_MbrOff=(int LeabraTimeUnit::*)(&LeabraTimeUnit::p_act_p))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraTimeUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraTimeUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraTimeUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraTimeUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","0"},
  NULL};
static MethodDef_data TA_LeabraTimeUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    4,1,-1,0,NULL,cssElCFun_LeabraTimeUnitSpec_InitState_stub,TA_LeabraTimeUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    4,3,-1,0,NULL,cssElCFun_LeabraTimeUnitSpec_Compute_dWt_stub,TA_LeabraTimeUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights from deltas","","",
    1,1,-1,0,NULL,cssElCFun_LeabraTimeUnitSpec_UpdateWeights_stub,TA_LeabraTimeUnitSpec_UpdateWeights_MethArgs},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,4,3,0,NULL,cssElCFun_LeabraTimeUnitSpec_CheckConfig_stub,TA_LeabraTimeUnitSpec_CheckConfig_MethArgs},
  NULL};
static int TimeMixSpec::* TA_TimeMixSpec_MbrOff;
static MemberDef_data TA_TimeMixSpec_MemberDef[]={
  {&TA_float,NULL,"prv"," contribution from previous point in time","","",
    *((ta_memb_ptr*)&(TA_TimeMixSpec_MbrOff=(int TimeMixSpec::*)(&TimeMixSpec::prv))),0,NULL,0},
  {&TA_float,NULL,"cur"," contribution from current point in time","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_TimeMixSpec_MbrOff=(int TimeMixSpec::*)(&TimeMixSpec::cur))),0,NULL,0},
  NULL};
static int LeabraTimeConSpec::* TA_LeabraTimeConSpec_MbrOff;
static MemberDef_data TA_LeabraTimeConSpec_MemberDef[]={
  {&TA_TimeMixSpec,NULL,"time_mix"," how much to learn based on previous versus current state information","","",
    *((ta_memb_ptr*)&(TA_LeabraTimeConSpec_MbrOff=(int LeabraTimeConSpec::*)(&LeabraTimeConSpec::time_mix))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraTimeConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  {&TA_float,NULL,"k_mult",""},
  NULL};
static MethodArgs_data TA_LeabraTimeConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraTimeConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  {&TA_float,NULL,"max_cor",""},
  NULL};
static MethodDef_data TA_LeabraTimeConSpec_MethodDef[]={
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    2,5,-1,0,NULL,cssElCFun_LeabraTimeConSpec_C_Compute_dWt_stub,TA_LeabraTimeConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LeabraTimeConSpec_Compute_dWt_stub,TA_LeabraTimeConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," compute Hebbian associative learning","","",
    1,5,-1,0,NULL,cssElCFun_LeabraTimeConSpec_C_Compute_Hebb_stub,TA_LeabraTimeConSpec_C_Compute_Hebb_MethArgs},
  NULL};
static int LeabraNegBiasSpec::* TA_LeabraNegBiasSpec_MbrOff;
static MemberDef_data TA_LeabraNegBiasSpec_MemberDef[]={
  {&TA_float,NULL,"decay"," rate of weight decay towards zero ","","",
    *((ta_memb_ptr*)&(TA_LeabraNegBiasSpec_MbrOff=(int LeabraNegBiasSpec::*)(&LeabraNegBiasSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"updt_immed"," update weights immediately when weights are changed","","",
    *((ta_memb_ptr*)&(TA_LeabraNegBiasSpec_MbrOff=(int LeabraNegBiasSpec::*)(&LeabraNegBiasSpec::updt_immed))),0,NULL,0},
  NULL};
static int LeabraMaintConSpec::* TA_LeabraMaintConSpec_MbrOff;
static MemberDef_data TA_LeabraMaintConSpec_MemberDef[]={
  {&TA_float,NULL,"maint_thresh"," when sending act > than this thresh, maint turned on in recv unit","","",
    *((ta_memb_ptr*)&(TA_LeabraMaintConSpec_MbrOff=(int LeabraMaintConSpec::*)(&LeabraMaintConSpec::maint_thresh))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraMaintConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraMaintConSpec_C_Switch_Maint_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LeabraMaintConSpec_MethodDef[]={
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_LeabraMaintConSpec_Send_Net_stub,TA_LeabraMaintConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"C_Switch_Maint","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraMaintConSpec_C_Switch_Maint_stub,TA_LeabraMaintConSpec_C_Switch_Maint_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraNetConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraNetConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraNetConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LeabraNetConSpec_MethodDef[]={
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_LeabraNetConSpec_Compute_Net_stub,TA_LeabraNetConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraNetConSpec_C_Send_Net_stub,TA_LeabraNetConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_LeabraNetConSpec_Send_Net_stub,TA_LeabraNetConSpec_Send_Net_MethArgs},
  NULL};
static EnumDef_data TA_PhaseDWtConSpec_dWtPhase[]={
  {"NO_FIRST_DWT"," for three phase cases: don't change weights after first plus","",0},
  {"ONLY_FIRST_DWT"," for three phase cases: only change weights after first plus","",1},
  {"ALL_DWT"," for three phase cases: change weights after *both* post-minus phases","",2},
  NULL};
static int PhaseDWtConSpec::* TA_PhaseDWtConSpec_MbrOff;
static MemberDef_data TA_PhaseDWtConSpec_MemberDef[]={
  {NULL,"::dWtPhase","dwt_phase"," what phase to change weights in","","",
    *((ta_memb_ptr*)&(TA_PhaseDWtConSpec_MbrOff=(int PhaseDWtConSpec::*)(&PhaseDWtConSpec::dwt_phase))),0,NULL,0},
  NULL};
static EnumDef_data TA_PhaseDWtUnitSpec_dWtPhase[]={
  {"NO_FIRST_DWT"," for three phase cases: don't change weights after first plus","",0},
  {"ONLY_FIRST_DWT"," for three phase cases: only change weights after first plus","",1},
  {"ALL_DWT"," for three phase cases: change weights after *both* post-minus phases","",2},
  NULL};
static int PhaseDWtUnitSpec::* TA_PhaseDWtUnitSpec_MbrOff;
static MemberDef_data TA_PhaseDWtUnitSpec_MemberDef[]={
  {NULL,"::dWtPhase","dwt_phase"," what phase to change weights in: for the bias weights","","",
    *((ta_memb_ptr*)&(TA_PhaseDWtUnitSpec_MbrOff=(int PhaseDWtUnitSpec::*)(&PhaseDWtUnitSpec::dwt_phase))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraTabledConSpec_TableType[]={
  {"ONE_PHASE"," hebbian-like learning based only on plus-phase activations","",0},
  {"ONE_PHASE_WITH_WT"," one-phase learning rule that incldues dependency on current weight value","",1},
  {"TWO_PHASE"," error-driven-style learning rule based on minus and plus phase activations","",2},
  {"TWO_PHASE_WITH_WT"," two-phase learning rule that incldues dependency on current weight value","",3},
  NULL};
static EnumDef_data TA_LeabraTabledConSpec_Squashing[]={
  {"SQUASH_WTS","","",0},
  {"DONT_SQUASH_WTS","","",1},
  NULL};
static int LeabraTabledConSpec::* TA_LeabraTabledConSpec_MbrOff;
static MemberDef_data TA_LeabraTabledConSpec_MemberDef[]={
  {&TA_FunLookupND,NULL,"dwt_table"," the lookup table for the learning rule implemented","HIDDEN AKA_mesh ","",
    *((ta_memb_ptr*)&(TA_LeabraTabledConSpec_MbrOff=(int LeabraTabledConSpec::*)(&LeabraTabledConSpec::dwt_table))),0,NULL,0},
  {&TA_taString,NULL,"cur_table"," name of last table loaded","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraTabledConSpec_MbrOff=(int LeabraTabledConSpec::*)(&LeabraTabledConSpec::cur_table))),0,NULL,0},
  {NULL,"::TableType","table_type"," what type of dwt table we have: hebbian (one phase) or hebb + error-driven (two phase)","","",
    *((ta_memb_ptr*)&(TA_LeabraTabledConSpec_MbrOff=(int LeabraTabledConSpec::*)(&LeabraTabledConSpec::table_type))),0,NULL,0},
  {NULL,"::Squashing","squashing"," squash the table-driven weight change values to keep them within 0-1 range (multiply inc by 1-w and dec by w)","","",
    *((ta_memb_ptr*)&(TA_LeabraTabledConSpec_MbrOff=(int LeabraTabledConSpec::*)(&LeabraTabledConSpec::squashing))),0,NULL,0},
  {&TA_float,NULL,"table_mix"," what fraction of the wt change shoud be calculated using the lookup table (1 - table_mix) is the standard leabra dwt computationa","","",
    *((ta_memb_ptr*)&(TA_LeabraTabledConSpec_MbrOff=(int LeabraTabledConSpec::*)(&LeabraTabledConSpec::table_mix))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_LookupDWt_MethArgs[]={
  {&TA_float,NULL,"su_act_m",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"wt",""},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_LoadDWtTable_MethArgs[]={
  {&TA_istream_ref,NULL,"is",""},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_ListTable_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm"," cout"},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_ShiftNorm_MethArgs[]={
  {&TA_float,NULL,"desired_mean",""},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_MulNorm_MethArgs[]={
  {&TA_float,NULL,"desired_mean",""},
  NULL};
static MethodArgs_data TA_LeabraTabledConSpec_Graph2DTable_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"disp_log",""},
  NULL};
static MethodDef_data TA_LeabraTabledConSpec_MethodDef[]={
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    2,5,-1,0,NULL,cssElCFun_LeabraTabledConSpec_C_Compute_dWt_stub,TA_LeabraTabledConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LeabraTabledConSpec_Compute_dWt_stub,TA_LeabraTabledConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"LookupDWt"," get dwt value for given set of parameters using current table","BUTTON USE_RVAL ","",
    0,5,-1,0,NULL,cssElCFun_LeabraTabledConSpec_LookupDWt_stub,TA_LeabraTabledConSpec_LookupDWt_MethArgs},
  {&TA_void,NULL,"LoadDWtTable"," loads weight-change lookup table from a file","BUTTON EXT_tab ","",
    0,1,-1,0,NULL,cssElCFun_LeabraTabledConSpec_LoadDWtTable_stub,TA_LeabraTabledConSpec_LoadDWtTable_MethArgs},
  {&TA_void,NULL,"ListTable"," output the lookup table in text format","BUTTON ARGC_0 CONFIRM ","",
    0,1,0,0,NULL,cssElCFun_LeabraTabledConSpec_ListTable_stub,TA_LeabraTabledConSpec_ListTable_MethArgs},
  {&TA_void,NULL,"ShiftNorm"," normalize the function values via an additive shift to achieve overall desired mean","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_LeabraTabledConSpec_ShiftNorm_stub,TA_LeabraTabledConSpec_ShiftNorm_MethArgs},
  {&TA_void,NULL,"MulNorm"," normalize the function values by multiplying positive and negative values by separate scaling factors to achieve desired mean","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_LeabraTabledConSpec_MulNorm_stub,TA_LeabraTabledConSpec_MulNorm_MethArgs},
  {&TA_void,NULL,"Graph2DTable"," graph a two-d table (doesn't work for higher dim tables)","BUTTON NULL_OK ","",
    0,1,-1,0,NULL,cssElCFun_LeabraTabledConSpec_Graph2DTable_stub,TA_LeabraTabledConSpec_Graph2DTable_MethArgs},
  NULL};
static int TrialSynDepCon::* TA_TrialSynDepCon_MbrOff;
static MemberDef_data TA_TrialSynDepCon_MemberDef[]={
  {&TA_float,NULL,"effwt"," effective weight value (can be depressed) -- used for sending ativation","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_TrialSynDepCon_MbrOff=(int TrialSynDepCon::*)(&TrialSynDepCon::effwt))),0,NULL,0},
  NULL};
static int SynDepSpec::* TA_SynDepSpec_MbrOff;
static MemberDef_data TA_SynDepSpec_MemberDef[]={
  {&TA_float,NULL,"rec"," rate of recovery from depression","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_SynDepSpec_MbrOff=(int SynDepSpec::*)(&SynDepSpec::rec))),0,NULL,0},
  {&TA_float,NULL,"depl"," rate of depletion of synaptic efficacy as a function of sender-receiver activations","DEF_1.1 ","",
    *((ta_memb_ptr*)&(TA_SynDepSpec_MbrOff=(int SynDepSpec::*)(&SynDepSpec::depl))),0,NULL,0},
  NULL};
static int TrialSynDepConSpec::* TA_TrialSynDepConSpec_MbrOff;
static MemberDef_data TA_TrialSynDepConSpec_MemberDef[]={
  {&TA_SynDepSpec,NULL,"syn_dep"," synaptic depression specifications","","",
    *((ta_memb_ptr*)&(TA_TrialSynDepConSpec_MbrOff=(int TrialSynDepConSpec::*)(&TrialSynDepConSpec::syn_dep))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Compute_Net_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Depress_Wt_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Depress_Wt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Reset_EffWt_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Reset_EffWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  NULL};
static MethodDef_data TA_TrialSynDepConSpec_MethodDef[]={
  {&TA_float,NULL,"C_Compute_Net","","","",
    2,3,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Compute_Net_stub,TA_TrialSynDepConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Compute_Net_stub,TA_TrialSynDepConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    2,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_Net_stub,TA_TrialSynDepConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Send_Net_stub,TA_TrialSynDepConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Compute_dWt_stub,TA_TrialSynDepConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_Send_Inhib","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_Inhib_stub,TA_TrialSynDepConSpec_C_Send_Inhib_MethArgs},
  {&TA_void,NULL,"C_Send_NetDelta","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_NetDelta_stub,TA_TrialSynDepConSpec_C_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"C_Send_InhibDelta","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_InhibDelta_stub,TA_TrialSynDepConSpec_C_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"C_Send_ClampNet","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_ClampNet_stub,TA_TrialSynDepConSpec_C_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"C_Depress_Wt","","","",
    0,3,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Depress_Wt_stub,TA_TrialSynDepConSpec_C_Depress_Wt_MethArgs},
  {&TA_void,NULL,"Depress_Wt","","","",
    0,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Depress_Wt_stub,TA_TrialSynDepConSpec_Depress_Wt_MethArgs},
  {&TA_void,NULL,"C_Reset_EffWt","","","",
    0,1,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Reset_EffWt_stub,TA_TrialSynDepConSpec_C_Reset_EffWt_MethArgs},
  {&TA_void,NULL,"Reset_EffWt","","","",
    0,1,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Reset_EffWt_stub,TA_TrialSynDepConSpec_Reset_EffWt_MethArgs},
  NULL};
static int FastWtCon::* TA_FastWtCon_MbrOff;
static MemberDef_data TA_FastWtCon_MemberDef[]={
  {&TA_float,NULL,"swt"," slow weight value","","",
    *((ta_memb_ptr*)&(TA_FastWtCon_MbrOff=(int FastWtCon::*)(&FastWtCon::swt))),0,NULL,0},
  {&TA_float,NULL,"sdwt"," slow weight delta-weight change","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_FastWtCon_MbrOff=(int FastWtCon::*)(&FastWtCon::sdwt))),0,NULL,0},
  NULL};
static EnumDef_data TA_FastWtSpec_DecayMode[]={
  {"ALWAYS"," always decay all weights toward slow weight (swt)","",0},
  {"SU_PROP"," decay in proportion to the sending unit activation: decay only happens after sending activity dissipates","",1},
  {"SU_THR"," decay only weights with sending unit activations below sending threshold (nom .1): decay only happens after sending activity dissipates","",2},
  NULL};
static int FastWtSpec::* TA_FastWtSpec_MbrOff;
static MemberDef_data TA_FastWtSpec_MemberDef[]={
  {&TA_float,NULL,"lrate"," learning rate","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::lrate))),0,NULL,0},
  {&TA_bool,NULL,"use_lrs"," use learning rate schedule to modify cur_lrate learning rate?","DEF_false ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::use_lrs))),0,NULL,0},
  {&TA_float,NULL,"cur_lrate"," current learning rate with lrate schedule factored in","READ_ONLY NO_INHERIT SHOW ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::cur_lrate))),0,NULL,0},
  {&TA_float,NULL,"decay"," rate of decay toward the slow weight values","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"slw_sat"," does fast weight contribute to saturation of slow weights?","DEF_true ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::slw_sat))),0,NULL,0},
  {NULL,"::DecayMode","dk_mode"," how to apply the decay of fast weights back to the slow weight (swt) value","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::dk_mode))),0,NULL,0},
  NULL};
static int FastWtConSpec::* TA_FastWtConSpec_MbrOff;
static MemberDef_data TA_FastWtConSpec_MemberDef[]={
  {&TA_FastWtSpec,NULL,"fast_wt"," fast weight specs: fast weights are added in separately to overall weight value as an increment (","","",
    *((ta_memb_ptr*)&(TA_FastWtConSpec_MbrOff=(int FastWtConSpec::*)(&FastWtConSpec::fast_wt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowHebb_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowErr_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"su_act_m",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowdWt_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_FastDecay_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_FastWtConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_InitWtDelta_stub,TA_FastWtConSpec_C_InitWtDelta_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    1,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_dWt_stub,TA_FastWtConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_FastWtConSpec_Compute_dWt_stub,TA_FastWtConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights","","","",
    2,5,-1,0,NULL,cssElCFun_FastWtConSpec_C_UpdateWeights_stub,TA_FastWtConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_FastWtConSpec_UpdateWeights_stub,TA_FastWtConSpec_UpdateWeights_MethArgs},
  {&TA_float,NULL,"C_Compute_SlowHebb"," todo: somewhat inefficient to do this computation twice..","","",
    0,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowHebb_stub,TA_FastWtConSpec_C_Compute_SlowHebb_MethArgs},
  {&TA_float,NULL,"C_Compute_SlowErr","","","",
    0,5,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowErr_stub,TA_FastWtConSpec_C_Compute_SlowErr_MethArgs},
  {&TA_void,NULL,"C_Compute_SlowdWt"," combine hebbian and error-driven","","",
    0,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowdWt_stub,TA_FastWtConSpec_C_Compute_SlowdWt_MethArgs},
  {&TA_void,NULL,"C_Compute_FastDecay","","","",
    0,3,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_FastDecay_stub,TA_FastWtConSpec_C_Compute_FastDecay_MethArgs},
  NULL};
static EnumDef_data TA_LeabraNewHebbConSpec_HebbFun[]={
  {"CPCA_ORIG"," original version of CPCA with savg cor and intrinsic wt squashing","",0},
  {"CPCA_SIMPLE"," a simpler version where the wt is assumed to be .5, and squashing happens afterwards, and no savg cor","",1},
  {"SIN_XY","","",2},
  NULL};
static int LeabraNewHebbConSpec::* TA_LeabraNewHebbConSpec_MbrOff;
static MemberDef_data TA_LeabraNewHebbConSpec_MemberDef[]={
  {NULL,"::HebbFun","hebb_fun"," which hebbian function to use","","",
    *((ta_memb_ptr*)&(TA_LeabraNewHebbConSpec_MbrOff=(int LeabraNewHebbConSpec::*)(&LeabraNewHebbConSpec::hebb_fun))),0,NULL,0},
  {&TA_float,NULL,"fixed_wt"," fixed weight value to use for simple cpca version","","",
    *((ta_memb_ptr*)&(TA_LeabraNewHebbConSpec_MbrOff=(int LeabraNewHebbConSpec::*)(&LeabraNewHebbConSpec::fixed_wt))),0,NULL,0},
  {&TA_float,NULL,"sinxy_freq"," frequency of the sine wave in sin_xy (in units of PI)","","",
    *((ta_memb_ptr*)&(TA_LeabraNewHebbConSpec_MbrOff=(int LeabraNewHebbConSpec::*)(&LeabraNewHebbConSpec::sinxy_freq))),0,NULL,0},
  {&TA_float,NULL,"subsu_thr"," threshold below which sending unit activity is subtracted","","",
    *((ta_memb_ptr*)&(TA_LeabraNewHebbConSpec_MbrOff=(int LeabraNewHebbConSpec::*)(&LeabraNewHebbConSpec::subsu_thr))),0,NULL,0},
  {&TA_float,NULL,"subsu_gain"," gain of subtracting su term","","",
    *((ta_memb_ptr*)&(TA_LeabraNewHebbConSpec_MbrOff=(int LeabraNewHebbConSpec::*)(&LeabraNewHebbConSpec::subsu_gain))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraNewHebbConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAorg_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAsimp_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_LeabraNewHebbConSpec_C_Compute_Hebb_SinXY_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_LeabraNewHebbConSpec_GraphHebb_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"disp_log",""},
  {&TA_float,NULL,"wt_val"," .5f"},
  {&TA_float,NULL,"savg_act"," .25f"},
  NULL};
static MethodDef_data TA_LeabraNewHebbConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LeabraNewHebbConSpec_Compute_dWt_stub,TA_LeabraNewHebbConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb_CPCAorg","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAorg_stub,TA_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAorg_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb_CPCAsimp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAsimp_stub,TA_LeabraNewHebbConSpec_C_Compute_Hebb_CPCAsimp_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb_SinXY","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraNewHebbConSpec_C_Compute_Hebb_SinXY_stub,TA_LeabraNewHebbConSpec_C_Compute_Hebb_SinXY_MethArgs},
  {&TA_void,NULL,"GraphHebb"," graph the hebbian learning rule for given values of weight and sending average activity","BUTTON NULL_OK ","",
    0,3,1,0,NULL,cssElCFun_LeabraNewHebbConSpec_GraphHebb_stub,TA_LeabraNewHebbConSpec_GraphHebb_MethArgs},
  NULL};
static int SigAmpSpec::* TA_SigAmpSpec_MbrOff;
static MemberDef_data TA_SigAmpSpec_MemberDef[]={
  {&TA_float,NULL,"amp"," amplitude","","",
    *((ta_memb_ptr*)&(TA_SigAmpSpec_MbrOff=(int SigAmpSpec::*)(&SigAmpSpec::amp))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SigAmpSpec_WriteToFile_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  NULL};
static MethodArgs_data TA_SigAmpSpec_ReadFromFile_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  NULL};
static MethodDef_data TA_SigAmpSpec_MethodDef[]={
  {&TA_void,NULL,"WriteToFile","","","",
    0,1,-1,0,NULL,cssElCFun_SigAmpSpec_WriteToFile_stub,TA_SigAmpSpec_WriteToFile_MethArgs},
  {&TA_void,NULL,"ReadFromFile","","","",
    0,1,-1,0,NULL,cssElCFun_SigAmpSpec_ReadFromFile_stub,TA_SigAmpSpec_ReadFromFile_MethArgs},
  NULL};
static int LeabraSigHebbConSpec::* TA_LeabraSigHebbConSpec_MbrOff;
static MemberDef_data TA_LeabraSigHebbConSpec_MemberDef[]={
  {&TA_SigAmpSpec,NULL,"pre0"," presynaptic sigmoids","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pre0))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pre1","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pre1))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pre2","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pre2))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pre3","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pre3))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pst0"," postsynaptic sigmoids","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pst0))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pst1","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pst1))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pst2","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pst2))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"pst3","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::pst3))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"prepst0"," pre * post","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::prepst0))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"prepst1","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::prepst1))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"prepst2","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::prepst2))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"prepst3","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::prepst3))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"ppdist0"," sqrt(pre * pre + post * post)","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::ppdist0))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"ppdist1","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::ppdist1))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"ppdist2","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::ppdist2))),0,NULL,0},
  {&TA_SigAmpSpec,NULL,"ppdist3","","","",
    *((ta_memb_ptr*)&(TA_LeabraSigHebbConSpec_MbrOff=(int LeabraSigHebbConSpec::*)(&LeabraSigHebbConSpec::ppdist3))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraSigHebbConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraSigHebbConSpec_WriteToFile_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  NULL};
static MethodArgs_data TA_LeabraSigHebbConSpec_ReadFromFile_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  NULL};
static MethodArgs_data TA_LeabraSigHebbConSpec_GraphHebb_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"disp_log",""},
  {&TA_float,NULL,"wt_val"," .5f"},
  {&TA_float,NULL,"savg_act"," .25f"},
  NULL};
static MethodDef_data TA_LeabraSigHebbConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LeabraSigHebbConSpec_Compute_dWt_stub,TA_LeabraSigHebbConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"WriteToFile"," write sigmoid parameters to file","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_LeabraSigHebbConSpec_WriteToFile_stub,TA_LeabraSigHebbConSpec_WriteToFile_MethArgs},
  {&TA_void,NULL,"ReadFromFile"," read sigmoid parameters from file","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_LeabraSigHebbConSpec_ReadFromFile_stub,TA_LeabraSigHebbConSpec_ReadFromFile_MethArgs},
  {&TA_void,NULL,"GraphHebb"," graph the hebbian learning rule for given values of weight and sending average activity","BUTTON NULL_OK ","",
    0,3,1,0,NULL,cssElCFun_LeabraSigHebbConSpec_GraphHebb_stub,TA_LeabraSigHebbConSpec_GraphHebb_MethArgs},
  NULL};
static EnumDef_data TA_ScalarValSpec_RepType[]={
  {"SUM_BAR"," bar of increasing activation threshold across units, with value = sum of overall activation. This has more natural activation dynamics than GAUSSIAN","",0},
  {"GAUSSIAN"," gaussian bump, with value = weighted average of tuned unit values","",1},
  NULL};
static int ScalarValSpec::* TA_ScalarValSpec_MbrOff;
static MemberDef_data TA_ScalarValSpec_MemberDef[]={
  {NULL,"::RepType","rep"," type of representation of scalar value to use","","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::rep))),0,NULL,0},
  {&TA_float,NULL,"un_width"," sigma parameter of a gaussian specifying the tuning width of the coarse-coded units (in min-max units)","CONDEDIT_ON_rep:GAUSSIAN ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::un_width))),0,NULL,0},
  {&TA_float,NULL,"min_net"," minimum netinput value for purposes of computing gc.i in sum_bar","CONDEDIT_ON_rep:SUM_BAR DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min_net))),0,NULL,0},
  {&TA_bool,NULL,"clamp_pat"," if true, environment provides full set of values to clamp over entire layer (instead of providing single scalar value to clamp on 1st unit, which then generates a corresponding distributed pattern)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::clamp_pat))),0,NULL,0},
  {&TA_float,NULL,"min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min))),0,NULL,0},
  {&TA_float,NULL,"range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::range))),0,NULL,0},
  {&TA_float,NULL,"val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::val))),0,NULL,0},
  {&TA_float,NULL,"incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::incr))),0,NULL,0},
  {&TA_int,NULL,"sb_lt"," sum_bar lower threshold index (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::sb_lt))),0,NULL,0},
  {&TA_float,NULL,"sb_ev"," sum_bar 'edge' unit value (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::sb_ev))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValSpec_InitVal_MethArgs[]={
  {&TA_float,NULL,"sval",""},
  {&TA_int,NULL,"ugp_size",""},
  {&TA_float,NULL,"umin",""},
  {&TA_float,NULL,"urng",""},
  NULL};
static MethodArgs_data TA_ScalarValSpec_GetUnitAct_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodArgs_data TA_ScalarValSpec_GetUnitVal_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodDef_data TA_ScalarValSpec_MethodDef[]={
  {&TA_void,NULL,"InitVal"," initialize implementational values for subsequently computing GetUnitAct to represent scalar val sval over unit group of ugp_size","","",
    0,4,-1,0,NULL,cssElCFun_ScalarValSpec_InitVal_stub,TA_ScalarValSpec_InitVal_MethArgs},
  {&TA_float,NULL,"GetUnitAct"," get activation under current representation for unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValSpec_GetUnitAct_stub,TA_ScalarValSpec_GetUnitAct_MethArgs},
  {&TA_float,NULL,"GetUnitVal"," get target value associated with unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValSpec_GetUnitVal_stub,TA_ScalarValSpec_GetUnitVal_MethArgs},
  NULL};
static EnumDef_data TA_ScalarValBias_UnitBias[]={
  {"NO_UN"," no unit bias","",0},
  {"GC"," bias value enters as a conductance in gc.h or gc.a","",1},
  {"BWT"," bias value enters as a bias.wt","",2},
  NULL};
static EnumDef_data TA_ScalarValBias_BiasShape[]={
  {"VAL"," bias as a particular value representation","",0},
  {"NEG_SLP"," bias as an increasingly negative slope (gc.a or -bwt) as unit values increase","",1},
  {"POS_SLP"," bias as an increasingly positive slope (gc.h or +bwt) as unit values increase","",2},
  NULL};
static EnumDef_data TA_ScalarValBias_WeightBias[]={
  {"NO_WT"," no weight bias","",0},
  {"WT"," input weights","",1},
  NULL};
static int ScalarValBias::* TA_ScalarValBias_MbrOff;
static MemberDef_data TA_ScalarValBias_MemberDef[]={
  {NULL,"::UnitBias","un"," bias on individual units","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un))),0,NULL,0},
  {NULL,"::BiasShape","un_shp"," shape of unit bias","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un_shp))),0,NULL,0},
  {&TA_float,NULL,"un_gain"," gain multiplier (strength) of bias to apply for units. WT = .03 as basic weight multiplier","CONDEDIT_OFF_un:NO_UN DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un_gain))),0,NULL,0},
  {NULL,"::WeightBias","wt"," bias on weights: always uses a val-shaped bias","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::wt))),0,NULL,0},
  {&TA_float,NULL,"wt_gain"," gain multiplier (strength) of bias to apply for weights (gain 1 = .03 wt value)","CONDEDIT_OFF_wt:NO_WT DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::wt_gain))),0,NULL,0},
  {&TA_float,NULL,"val"," value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::val))),0,NULL,0},
  NULL};
static int ScalarValLayerSpec::* TA_ScalarValLayerSpec_MbrOff;
static MemberDef_data TA_ScalarValLayerSpec_MemberDef[]={
  {&TA_ScalarValSpec,NULL,"scalar"," specifies how values are represented in terms of distributed patterns of activation across the layer","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::scalar))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"unit_range"," range of values represented across the units; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::unit_range))),0,NULL,0},
  {&TA_ScalarValBias,NULL,"bias_val"," specifies bias for given value (as gaussian bump) ","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::bias_val))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::val_range))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ClampValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"rescale","1.0f"},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ClampAvgAct_MethArgs[]={
  {&TA_int,NULL,"ugp_size",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ReadValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ResetAfterClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_HardClampExt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnits_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnits_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnitsNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_WtBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_NegSlp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_PosSlp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_BiasVal_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ReConfig_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_units"," -1"},
  NULL};
static MethodDef_data TA_ScalarValLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_ScalarValLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ClampValue"," clamp value in the first unit's ext field to the units in the group","","",
    0,3,2,0,NULL,cssElCFun_ScalarValLayerSpec_ClampValue_stub,TA_ScalarValLayerSpec_ClampValue_MethArgs},
  {&TA_float,NULL,"ClampAvgAct"," computes the average activation for a clamped unit pattern (for computing rescaling)","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_ClampAvgAct_stub,TA_ScalarValLayerSpec_ClampAvgAct_MethArgs},
  {&TA_float,NULL,"ReadValue"," read out current value represented by activations in layer","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_ReadValue_stub,TA_ScalarValLayerSpec_ReadValue_MethArgs},
  {&TA_void,NULL,"ResetAfterClamp"," reset activation of first unit(s) after hard clamping","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_ResetAfterClamp_stub,TA_ScalarValLayerSpec_ResetAfterClamp_MethArgs},
  {&TA_void,NULL,"HardClampExt"," hard clamp current ext values (on all units, after ClampValue called) to all the units","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_HardClampExt_stub,TA_ScalarValLayerSpec_HardClampExt_MethArgs},
  {&TA_void,NULL,"LabelUnits_impl"," label units with their underlying values","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnits_impl_stub,TA_ScalarValLayerSpec_LabelUnits_impl_MethArgs},
  {&TA_void,NULL,"LabelUnits"," label units in given layer with their underlying values","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnits_stub,TA_ScalarValLayerSpec_LabelUnits_MethArgs},
  {&TA_void,NULL,"LabelUnitsNet"," label all layers in given network using this spec","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnitsNet_stub,TA_ScalarValLayerSpec_LabelUnitsNet_MethArgs},
  {&TA_void,NULL,"Compute_WtBias_Val","","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_WtBias_Val_stub,TA_ScalarValLayerSpec_Compute_WtBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_Val","","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_Val_stub,TA_ScalarValLayerSpec_Compute_UnBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_NegSlp","","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_NegSlp_stub,TA_ScalarValLayerSpec_Compute_UnBias_NegSlp_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_PosSlp","","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_PosSlp_stub,TA_ScalarValLayerSpec_Compute_UnBias_PosSlp_MethArgs},
  {&TA_void,NULL,"Compute_BiasVal"," initialize the bias value ","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_BiasVal_stub,TA_ScalarValLayerSpec_Compute_BiasVal_MethArgs},
  {&TA_void,NULL,"ReConfig"," reconfigure layer and associated specs for current scalar.rep type; if n_units > 0, changes number of units in layer to specified value","BUTTON ","",
    0,2,1,0,NULL,cssElCFun_ScalarValLayerSpec_ReConfig_stub,TA_ScalarValLayerSpec_ReConfig_MethArgs},
  NULL};
static int ScalarValSelfPrjnSpec::* TA_ScalarValSelfPrjnSpec_MbrOff;
static MemberDef_data TA_ScalarValSelfPrjnSpec_MemberDef[]={
  {&TA_int,NULL,"width"," width of neighborhood, in units (i.e., connect width units to the left, and width units to the right)","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::width))),0,NULL,0},
  {&TA_float,NULL,"wt_width"," width of the sigmoid for providing initial weight values","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::wt_width))),0,NULL,0},
  {&TA_float,NULL,"wt_max"," maximum weight value (of 1st neighbor -- not of self unit!)","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::wt_max))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_Connect_impl_MethArgs[]={
  {&TA_Projection_ptr,NULL,"prjn",""},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_C_InitWtState_MethArgs[]={
  {&TA_Projection_ptr,NULL,"prjn",""},
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_Connect_UnitGroup_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"gp",""},
  {&TA_Projection_ptr,NULL,"prjn",""},
  NULL};
static MethodDef_data TA_ScalarValSelfPrjnSpec_MethodDef[]={
  {&TA_void,NULL,"Connect_impl"," actually implements specific connection code","","",
    1,1,-1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_Connect_impl_stub,TA_ScalarValSelfPrjnSpec_Connect_impl_MethArgs},
  {&TA_void,NULL,"C_InitWtState"," custom initialize weights in this con group for given receiving unit ru uses weight values as specified in the tesselel's","","",
    1,3,-1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_C_InitWtState_stub,TA_ScalarValSelfPrjnSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"Connect_UnitGroup","","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_Connect_UnitGroup_stub,TA_ScalarValSelfPrjnSpec_Connect_UnitGroup_MethArgs},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_MarkerConSpec_MethodDef[]={
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_Compute_Net_stub,TA_MarkerConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_Send_Net_stub,TA_MarkerConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_Compute_dWt_stub,TA_MarkerConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_UpdateWeights_stub,TA_MarkerConSpec_UpdateWeights_MethArgs},
  NULL};
static int DaModUnit::* TA_DaModUnit_MbrOff;
static MemberDef_data TA_DaModUnit_MemberDef[]={
  {&TA_float,NULL,"act_m2"," second minus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::act_m2))),0,NULL,0},
  {&TA_float,NULL,"act_p2"," second plus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::act_p2))),0,NULL,0},
  {&TA_float,NULL,"p_act_m"," previous minus phase activation ","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::p_act_m))),0,NULL,0},
  {&TA_float,NULL,"p_act_p"," previous plus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::p_act_p))),0,NULL,0},
  {&TA_float,NULL,"dav"," modulatory dopamine value ","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::dav))),0,NULL,0},
  NULL};
static int DaModSpec::* TA_DaModSpec_MbrOff;
static MemberDef_data TA_DaModSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to actually modulate activations by da values","","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::on))),0,NULL,0},
  {&TA_bool,NULL,"post"," if true, apply da modulation at end of settling, not during settling","CONDEDIT_ON_on:true DEF_false ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::post))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain multiplier of da values","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::gain))),0,NULL,0},
  {&TA_bool,NULL,"p_dwt"," whether units learn based on prior activation states (affects Compute_dWt and UpdateWeights calls)","","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::p_dwt))),0,NULL,0},
  NULL};
static int DaModUnitSpec::* TA_DaModUnitSpec_MbrOff;
static MemberDef_data TA_DaModUnitSpec_MemberDef[]={
  {&TA_DaModSpec,NULL,"da_mod"," da modulation of plus phase activations (for da-based learning)","","",
    *((ta_memb_ptr*)&(TA_DaModUnitSpec_MbrOff=(int DaModUnitSpec::*)(&DaModUnitSpec::da_mod))),0,NULL,0},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","0"},
  NULL};
static MethodDef_data TA_DaModUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    4,1,-1,0,NULL,cssElCFun_DaModUnitSpec_InitState_stub,TA_DaModUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    4,3,-1,0,NULL,cssElCFun_DaModUnitSpec_Compute_dWt_stub,TA_DaModUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights from deltas","","",
    1,1,-1,0,NULL,cssElCFun_DaModUnitSpec_UpdateWeights_stub,TA_DaModUnitSpec_UpdateWeights_MethArgs},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,4,3,0,NULL,cssElCFun_DaModUnitSpec_CheckConfig_stub,TA_DaModUnitSpec_CheckConfig_MethArgs},
  NULL};
static int AvgExtRewSpec::* TA_AvgExtRewSpec_MbrOff;
static MemberDef_data TA_AvgExtRewSpec_MemberDef[]={
  {&TA_bool,NULL,"sub_avg"," subtract average reward value in computing rewards","DEF_false ","",
    *((ta_memb_ptr*)&(TA_AvgExtRewSpec_MbrOff=(int AvgExtRewSpec::*)(&AvgExtRewSpec::sub_avg))),0,NULL,0},
  {&TA_float,NULL,"avg_dt"," time constant for integrating average reward value","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_AvgExtRewSpec_MbrOff=(int AvgExtRewSpec::*)(&AvgExtRewSpec::avg_dt))),0,NULL,0},
  NULL};
static int OutErrSpec::* TA_OutErrSpec_MbrOff;
static MemberDef_data TA_OutErrSpec_MemberDef[]={
  {&TA_bool,NULL,"graded"," compute a graded reward signal as a function of number of correct output values","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::graded))),0,NULL,0},
  {&TA_bool,NULL,"no_off_err"," do not count a unit wrong if it is off but target says on -- only count wrong units that are on but should be off","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::no_off_err))),0,NULL,0},
  {&TA_bool,NULL,"seq_all_cor"," require that all RewTarg events in a sequence be correct before giving reward (on the last event in sequence); if graded is checked, this reward is a graded function of % correct","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::seq_all_cor))),0,NULL,0},
  NULL};
static int ExtRewSpec::* TA_ExtRewSpec_MbrOff;
static MemberDef_data TA_ExtRewSpec_MemberDef[]={
  {&TA_float,NULL,"err_val"," reward value for errors (when network does not respond correctly)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::err_val))),0,NULL,0},
  {&TA_float,NULL,"norew_val"," reward value when no feedback information is present","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::norew_val))),0,NULL,0},
  {&TA_float,NULL,"rew_val"," reward value for correct responses (positive rewards)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::rew_val))),0,NULL,0},
  NULL};
static EnumDef_data TA_ExtRewLayerSpec_RewardType[]={
  {"OUT_ERR_REW"," get rewards as a function of errors on the output layer ONLY WHEN RewTarg layer act > .5 -- get from markerconspec from output layer(s)","",0},
  {"EXT_REW"," get rewards as external inputs marked as ext_flag = TARG to the first unit in the layer","",1},
  {"DA_REW"," get rewards from da values on first unit in layer","",2},
  NULL};
static int ExtRewLayerSpec::* TA_ExtRewLayerSpec_MbrOff;
static MemberDef_data TA_ExtRewLayerSpec_MemberDef[]={
  {NULL,"::RewardType","rew_type"," how do we get the reward values?","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::rew_type))),0,NULL,0},
  {&TA_AvgExtRewSpec,NULL,"avg_rew"," average reward computation specifications","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::avg_rew))),0,NULL,0},
  {&TA_OutErrSpec,NULL,"out_err"," how to compute external rewards based on output performance","CONDEDIT_ON_rew_type:OUT_ERR_REW ","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::out_err))),0,NULL,0},
  {&TA_ExtRewSpec,NULL,"rew"," misc reward computation specifications","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::rew))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_OutErrRewAvail_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_GetOutErrRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_OutErrRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_ExtRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_DaRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_UnitDa_MethArgs[]={
  {&TA_float,NULL,"er",""},
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_NoRewAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_ExtRewLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_ExtRewLayerSpec_HelpConfig_stub,NULL},
  {&TA_bool,NULL,"OutErrRewAvail"," figure out if reward is available on this trial (look if target signals are present)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_OutErrRewAvail_stub,TA_ExtRewLayerSpec_OutErrRewAvail_MethArgs},
  {&TA_float,NULL,"GetOutErrRew"," get reward value based on error at layer with MarkerConSpec connection: 1 = rew (correct), 0 = err, -1 = no info","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_GetOutErrRew_stub,TA_ExtRewLayerSpec_GetOutErrRew_MethArgs},
  {&TA_void,NULL,"Compute_OutErrRew"," get reward value based on external error (put in da val, clamp)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_OutErrRew_stub,TA_ExtRewLayerSpec_Compute_OutErrRew_MethArgs},
  {&TA_void,NULL,"Compute_ExtRew"," get external rewards from inputs (put in da val, clamp)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_ExtRew_stub,TA_ExtRewLayerSpec_Compute_ExtRew_MethArgs},
  {&TA_void,NULL,"Compute_DaRew"," clamp external rewards as da values (put in da val, clamp)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_DaRew_stub,TA_ExtRewLayerSpec_Compute_DaRew_MethArgs},
  {&TA_void,NULL,"Compute_UnitDa"," actually compute the unit da value based on external reward value er","","",
    0,5,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_UnitDa_stub,TA_ExtRewLayerSpec_Compute_UnitDa_MethArgs},
  {&TA_void,NULL,"Compute_ZeroAct"," clamp zero activations, for minus phase","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_ZeroAct_stub,TA_ExtRewLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_NoRewAct"," clamp norew_val values for when no reward information is present","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_NoRewAct_stub,TA_ExtRewLayerSpec_Compute_NoRewAct_MethArgs},
  NULL};
static int ExtRew_Stat::* TA_ExtRew_Stat_MbrOff;
static MemberDef_data TA_ExtRew_Stat_MemberDef[]={
  {&TA_StatVal,NULL,"rew"," external reward value","","",
    *((ta_memb_ptr*)&(TA_ExtRew_Stat_MbrOff=(int ExtRew_Stat::*)(&ExtRew_Stat::rew))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ExtRew_Stat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ExtRew_Stat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_ExtRew_Stat_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_ExtRew_Stat_RecvCon_Run_stub,TA_ExtRew_Stat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_ExtRew_Stat_SendCon_Run_stub,TA_ExtRew_Stat_SendCon_Run_MethArgs},
  NULL};
static MethodArgs_data TA_TDRewPredConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TDRewPredConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_TDRewPredConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_TDRewPredConSpec_Compute_dWt_stub,TA_TDRewPredConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case this computes weight changes based on sender at time t-1","","",
    1,3,-1,0,NULL,cssElCFun_TDRewPredConSpec_C_Compute_Err_stub,TA_TDRewPredConSpec_C_Compute_Err_MethArgs},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_SavePred_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ClampPred_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ClampPrev_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_TdPlusPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_TDRewPredLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_SavePred"," save current prediction to misc_1 for later clamping","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_SavePred_stub,TA_TDRewPredLayerSpec_Compute_SavePred_MethArgs},
  {&TA_void,NULL,"Compute_ClampPred"," clamp misc_1 to ext ","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ClampPred_stub,TA_TDRewPredLayerSpec_Compute_ClampPred_MethArgs},
  {&TA_void,NULL,"Compute_ClampPrev"," clamp minus phase to previous act value","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ClampPrev_stub,TA_TDRewPredLayerSpec_Compute_ClampPrev_MethArgs},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ExtToPlus_stub,TA_TDRewPredLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_TdPlusPhase_impl","","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_stub,TA_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_MethArgs},
  {&TA_void,NULL,"Compute_TdPlusPhase"," compute plus phase activations for learning including the td values","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_stub,TA_TDRewPredLayerSpec_Compute_TdPlusPhase_MethArgs},
  NULL};
static int TDRewIntegSpec::* TA_TDRewIntegSpec_MbrOff;
static MemberDef_data TA_TDRewIntegSpec_MemberDef[]={
  {&TA_float,NULL,"discount"," discount factor for V(t+1) from TDRewPredLayer","","",
    *((ta_memb_ptr*)&(TA_TDRewIntegSpec_MbrOff=(int TDRewIntegSpec::*)(&TDRewIntegSpec::discount))),0,NULL,0},
  NULL};
static int TDRewIntegLayerSpec::* TA_TDRewIntegLayerSpec_MbrOff;
static MemberDef_data TA_TDRewIntegLayerSpec_MemberDef[]={
  {&TA_TDRewIntegSpec,NULL,"rew_integ"," misc specs for TDRewIntegLayerSpec","","",
    *((ta_memb_ptr*)&(TA_TDRewIntegLayerSpec_MbrOff=(int TDRewIntegLayerSpec::*)(&TDRewIntegLayerSpec::rew_integ))),0,NULL,0},
  NULL};
static MethodDef_data TA_TDRewIntegLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TDRewIntegLayerSpec_HelpConfig_stub,NULL},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_Td_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Send_Td_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_TdLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TdLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_ZeroAct"," compute a zero td value: in minus phase","","",
    0,2,-1,0,NULL,cssElCFun_TdLayerSpec_Compute_ZeroAct_stub,TA_TdLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_Td"," compute the td value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,0,NULL,cssElCFun_TdLayerSpec_Compute_Td_stub,TA_TdLayerSpec_Compute_Td_MethArgs},
  {&TA_void,NULL,"Send_Td"," send the td value to sending projections: every cycle","","",
    0,2,-1,0,NULL,cssElCFun_TdLayerSpec_Send_Td_stub,TA_TdLayerSpec_Send_Td_MethArgs},
  NULL};
static MethodArgs_data TA_LVConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LVConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LVConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LVConSpec_Compute_dWt_stub,TA_LVConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case this computes weight changes based on sender at time t-1","","",
    1,3,-1,0,NULL,cssElCFun_LVConSpec_C_Compute_Err_stub,TA_LVConSpec_C_Compute_Err_MethArgs},
  NULL};
static int LVSpec::* TA_LVSpec_MbrOff;
static MemberDef_data TA_LVSpec_MemberDef[]={
  {&TA_float,NULL,"avg_dt"," time constant for integrating average LV value (in minus phase)","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::avg_dt))),0,NULL,0},
  {&TA_float,NULL,"avg_init"," initial average LV value (use 0 for ExtRew norew val = 0)","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::avg_init))),0,NULL,0},
  {&TA_bool,NULL,"use_pt"," use thr_avg_pt to put threshold for saying cur trial as an ER between avg LV val for hits (positive rewards) and others (no info)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::use_pt))),0,NULL,0},
  {&TA_float,NULL,"thr_avg_pt"," how close to put threshold between average LV values for hit and other (allows floating threshold to adapt to actual LV values)","CONDEDIT_ON_use_pt:true DEF_0.6 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::thr_avg_pt))),0,NULL,0},
  {&TA_float,NULL,"thr_min"," minimum threshold on LV reward expectation magnitude required for saying ER (.25 or .3 for use_pt, 0 for !use_pt and ExtRew norew = 0)","DEF_0.25 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::thr_min))),0,NULL,0},
  {&TA_float,NULL,"thr_max"," maximum threshold on LV reward expectation magnitude required for saying ER (use .75 for ExtRew norew val = .5, else use .4 for norew = 0)","DEF_0.75 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::thr_max))),0,NULL,0},
  NULL};
static int LVLayerSpec::* TA_LVLayerSpec_MbrOff;
static MemberDef_data TA_LVLayerSpec_MemberDef[]={
  {&TA_LVSpec,NULL,"lv"," learning value specs","","",
    *((ta_memb_ptr*)&(TA_LVLayerSpec_MbrOff=(int LVLayerSpec::*)(&LVLayerSpec::lv))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LVLayerSpec_Compute_ExtRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool_ref,NULL,"actual_er_avail",""},
  {&TA_bool_ref,NULL,"lv_est_er_avail",""},
  NULL};
static MethodArgs_data TA_LVLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LVLayerSpec_Compute_dWtUgp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LVLayerSpec_Compute_LVPlusPhaseDwt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LVLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_LVLayerSpec_HelpConfig_stub,NULL},
  {&TA_float,NULL,"Compute_ExtRew"," get external reward from ExtRew layer if it is available: actual_er_avail = internal flag from ExtRew layer (cheating), lv_est_er_avail = LV layer's estimate of ER availability based on current ER values vs. LV values (use this for bio authenticity)","","",
    0,4,-1,0,NULL,cssElCFun_LVLayerSpec_Compute_ExtRew_stub,TA_LVLayerSpec_Compute_ExtRew_MethArgs},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,0,NULL,cssElCFun_LVLayerSpec_Compute_ExtToPlus_stub,TA_LVLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_dWtUgp"," compute weight changes just for one unit group","","",
    0,3,-1,0,NULL,cssElCFun_LVLayerSpec_Compute_dWtUgp_stub,TA_LVLayerSpec_Compute_dWtUgp_MethArgs},
  {&TA_void,NULL,"Compute_LVPlusPhaseDwt"," compute plus phase activations as external rewards and change weights","","",
    0,2,-1,0,NULL,cssElCFun_LVLayerSpec_Compute_LVPlusPhaseDwt_stub,TA_LVLayerSpec_Compute_LVPlusPhaseDwt_MethArgs},
  NULL};
static MethodArgs_data TA_PVConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_PVConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_PVConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_PVConSpec_Compute_dWt_stub,TA_PVConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    1,3,-1,0,NULL,cssElCFun_PVConSpec_C_Compute_Err_stub,TA_PVConSpec_C_Compute_Err_MethArgs},
  NULL};
static EnumDef_data TA_PVSpec_LearnMode[]={
  {"ER"," use the external reward value directly (cheating because we shouldn't really know when reward was not delivered, but works better because of this..)","",0},
  {"DA_LV"," use DA value from LV - ER ONLY: does not include the PV system's own contribution to the DA signal & prevents weird self-feedback effects","",1},
  {"DA"," use DA value direct from VTA: does include PV system's own contribution to DA, which can cause weird self-feedback effects","",2},
  NULL};
static int PVSpec::* TA_PVSpec_MbrOff;
static MemberDef_data TA_PVSpec_MemberDef[]={
  {NULL,"::LearnMode","lrn_mode"," learning mode: what signal to use to train value?","DEF_ER ","",
    *((ta_memb_ptr*)&(TA_PVSpec_MbrOff=(int PVSpec::*)(&PVSpec::lrn_mode))),0,NULL,0},
  {&TA_float,NULL,"da_gain"," gain on the learning da signal (also used in gc_mod mode)","CONDEDIT_OFF_lrn_mode:ER,ER_LV DEF_1.5 ","",
    *((ta_memb_ptr*)&(TA_PVSpec_MbrOff=(int PVSpec::*)(&PVSpec::da_gain))),0,NULL,0},
  {&TA_bool,NULL,"use_er"," use actual external reward to determine when to learn (cheating), otherwise use LV's estimate of when ER is avail (more realistic)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PVSpec_MbrOff=(int PVSpec::*)(&PVSpec::use_er))),0,NULL,0},
  NULL};
static int PVLayerSpec::* TA_PVLayerSpec_MbrOff;
static MemberDef_data TA_PVLayerSpec_MemberDef[]={
  {&TA_PVSpec,NULL,"pv"," perceived value learning specs","","",
    *((ta_memb_ptr*)&(TA_PVLayerSpec_MbrOff=(int PVLayerSpec::*)(&PVLayerSpec::pv))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PVLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLayerSpec_Compute_dWtUgp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLayerSpec_Compute_DepressWt_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLayerSpec_Compute_PVPlusPhaseDwt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_PVLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_PVLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,0,NULL,cssElCFun_PVLayerSpec_Compute_ExtToPlus_stub,TA_PVLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_dWtUgp"," compute weight changes just for one unit group","","",
    0,3,-1,0,NULL,cssElCFun_PVLayerSpec_Compute_dWtUgp_stub,TA_PVLayerSpec_Compute_dWtUgp_MethArgs},
  {&TA_void,NULL,"Compute_DepressWt"," depress weights for units in unit group (only if not doing dwts!)","","",
    0,3,-1,0,NULL,cssElCFun_PVLayerSpec_Compute_DepressWt_stub,TA_PVLayerSpec_Compute_DepressWt_MethArgs},
  {&TA_void,NULL,"Compute_PVPlusPhaseDwt"," compute plus phase activations for learning, and actually change weights if da is above threshold","","",
    0,2,-1,0,NULL,cssElCFun_PVLayerSpec_Compute_PVPlusPhaseDwt_stub,TA_PVLayerSpec_Compute_PVPlusPhaseDwt_MethArgs},
  NULL};
static EnumDef_data TA_PVLVDaSpec_DaMode[]={
  {"IF_ER_LV"," if ext rew, da = er - nac_lv, else da = abl - nac_pv","",0},
  {"LV_PLUS_PV"," da = (ER - LV) + (PV_F - PV_S)","",1},
  NULL};
static int PVLVDaSpec::* TA_PVLVDaSpec_MbrOff;
static MemberDef_data TA_PVLVDaSpec_MemberDef[]={
  {NULL,"::DaMode","mode"," how to compute da in the 1st plus phase; minus phase is always ABL - BL; post-plus phases always PV(fast) - MAX(PV(slow), min_abl) (+add_lv..)","DEF_IF_ER_LV ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::mode))),0,NULL,0},
  {&TA_float,NULL,"tonic_da"," set a tonic 'dopamine' (DA) level (offset to add to da values)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::tonic_da))),0,NULL,0},
  {&TA_float,NULL,"min_pv_s"," minimum PV_slow value, so that a low PV_fast (ABL) value (~0) makes a negative da: DA_pv = PV_fast - MAX(PV_slow, min_pv_s)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::min_pv_s))),0,NULL,0},
  {&TA_bool,NULL,"pp_lv"," add ER - LV da to post-plus phases (second plus, etc)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::pp_lv))),0,NULL,0},
  {&TA_bool,NULL,"use_er"," use actual ext rew avail signal (i.e., cheating); else use the LV activity to determine if ER is avail","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::use_er))),0,NULL,0},
  NULL};
static int PVLVDaLayerSpec::* TA_PVLVDaLayerSpec_MbrOff;
static MemberDef_data TA_PVLVDaLayerSpec_MemberDef[]={
  {&TA_PVLVDaSpec,NULL,"da"," parameters for the pvlv da computation","","",
    *((ta_memb_ptr*)&(TA_PVLVDaLayerSpec_MbrOff=(int PVLVDaLayerSpec::*)(&PVLVDaLayerSpec::da))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Send_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_PVLVDaLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_ZeroAct"," compute a zero da value: in minus phase","","",
    0,2,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_ZeroAct_stub,TA_PVLVDaLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_Da"," compute the da value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_Da_stub,TA_PVLVDaLayerSpec_Compute_Da_MethArgs},
  {&TA_void,NULL,"Send_Da"," send the da value to sending projections: every cycle","","",
    0,2,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_Send_Da_stub,TA_PVLVDaLayerSpec_Send_Da_MethArgs},
  NULL};
static EnumDef_data TA_SNcMiscSpec_PatchMode[]={
  {"NO_PATCH"," no patch at all","",0},
  {"PATCH"," use patch..","",1},
  NULL};
static int SNcMiscSpec::* TA_SNcMiscSpec_MbrOff;
static MemberDef_data TA_SNcMiscSpec_MemberDef[]={
  {NULL,"::PatchMode","patch_mode"," how to run the patch computation","DEF_NO_PATCH ","",
    *((ta_memb_ptr*)&(TA_SNcMiscSpec_MbrOff=(int SNcMiscSpec::*)(&SNcMiscSpec::patch_mode))),0,NULL,0},
  {&TA_float,NULL,"patch_gain"," proportion of patch (stripe-specific) da relative to global abl da","CONDEDIT_ON_patch_mode:PATCH DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_SNcMiscSpec_MbrOff=(int SNcMiscSpec::*)(&SNcMiscSpec::patch_gain))),0,NULL,0},
  NULL};
static int SNcLayerSpec::* TA_SNcLayerSpec_MbrOff;
static MemberDef_data TA_SNcLayerSpec_MemberDef[]={
  {&TA_SNcMiscSpec,NULL,"snc"," misc SNc specific parameters controlling influence of patch modulation","","",
    *((ta_memb_ptr*)&(TA_SNcLayerSpec_MbrOff=(int SNcLayerSpec::*)(&SNcLayerSpec::snc))),0,NULL,0},
  NULL};
static MethodDef_data TA_SNcLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_SNcLayerSpec_HelpConfig_stub,NULL},
  NULL};
static EnumDef_data TA_MatrixConSpec_LearnRule[]={
  {"MOTOR_DELTA"," delta rule for BG_motor: (bg+ - bg-) * s-","",0},
  {"MOTOR_CHL"," CHL rule for BG_motor: (bg+ * s+) - (bg- * s-)","",1},
  {"PFC"," PFC learning rule: (bg_p2 - bg_p) * s_p","",2},
  NULL};
static int MatrixConSpec::* TA_MatrixConSpec_MbrOff;
static MemberDef_data TA_MatrixConSpec_MemberDef[]={
  {NULL,"::LearnRule","learn_rule"," learning rule to use","","",
    *((ta_memb_ptr*)&(TA_MatrixConSpec_MbrOff=(int MatrixConSpec::*)(&MatrixConSpec::learn_rule))),0,NULL,0},
  {&TA_bool,NULL,"pfc_hebb_nego"," only allow negative dwts for pfc hebb learning","","",
    *((ta_memb_ptr*)&(TA_MatrixConSpec_MbrOff=(int MatrixConSpec::*)(&MatrixConSpec::pfc_hebb_nego))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_MatrixConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_MatrixConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_MatrixConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_MatrixConSpec_Compute_dWt_stub,TA_MatrixConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," compute Hebbian associative learning","","",
    1,4,-1,0,NULL,cssElCFun_MatrixConSpec_C_Compute_Hebb_stub,TA_MatrixConSpec_C_Compute_Hebb_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    1,3,-1,0,NULL,cssElCFun_MatrixConSpec_C_Compute_Err_stub,TA_MatrixConSpec_C_Compute_Err_MethArgs},
  NULL};
static EnumDef_data TA_MatrixBiasSpec_LearnRule[]={
  {"MOTOR_DELTA"," delta rule for BG_motor: (bg+ - bg-) * s-","",0},
  {"MOTOR_CHL"," CHL rule for BG_motor: (bg+ * s+) - (bg- * s-)","",1},
  {"PFC"," PFC: learn on 2p - p","",2},
  NULL};
static int MatrixBiasSpec::* TA_MatrixBiasSpec_MbrOff;
static MemberDef_data TA_MatrixBiasSpec_MemberDef[]={
  {NULL,"::LearnRule","learn_rule"," learning rule to use","","",
    *((ta_memb_ptr*)&(TA_MatrixBiasSpec_MbrOff=(int MatrixBiasSpec::*)(&MatrixBiasSpec::learn_rule))),0,NULL,0},
  NULL};
static int MatrixUnitSpec::* TA_MatrixUnitSpec_MbrOff;
static MemberDef_data TA_MatrixUnitSpec_MemberDef[]={
  {&TA_bool,NULL,"freeze_net"," freeze netinput (PFC in 2+ phase, MOTOR in 1+ phase) during learning modulation so that learning only reflects DA modulation and not other changes in netin","DEF_true ","",
    *((ta_memb_ptr*)&(TA_MatrixUnitSpec_MbrOff=(int MatrixUnitSpec::*)(&MatrixUnitSpec::freeze_net))),0,NULL,0},
  NULL};
static int ContrastSpec::* TA_ContrastSpec_MbrOff;
static MemberDef_data TA_ContrastSpec_MemberDef[]={
  {&TA_float,NULL,"gain"," overall gain for da modulation","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"go_p"," proportion of da * gate_act for DA+ on GO units: contrast enhancement","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::go_p))),0,NULL,0},
  {&TA_float,NULL,"go_n"," proportion of da * gate_act for DA- on GO units: contrast reduction","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::go_n))),0,NULL,0},
  {&TA_float,NULL,"nogo_p"," proportion of da * gate_act for DA+ on NOGO units: contrast enhancement","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::nogo_p))),0,NULL,0},
  {&TA_float,NULL,"nogo_n"," proportion of da * gate_act for DA- on NOGO units: contrast reduction","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::nogo_n))),0,NULL,0},
  NULL};
static int MatrixRndGoSpec::* TA_MatrixRndGoSpec_MbrOff;
static MemberDef_data TA_MatrixRndGoSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to use this function or not","DEF_true ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::on))),0,NULL,0},
  {&TA_float,NULL,"go_p"," probability of actually firing a random Go when all the conditions have been met","CONDEDIT_ON_on:true DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::go_p))),0,NULL,0},
  {&TA_float,NULL,"rgo_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) when max_mnt is up or a random Go is active (applied during learning, after Go/NoGo already computed)","DEF_20 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::rgo_da))),0,NULL,0},
  {&TA_float,NULL,"prf_go_p"," uniform random performance-only Go firing (not conditional on thresholds; happens randomly; does not cause learning)","CONDEDIT_ON_on:true DEF_1e-04 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::prf_go_p))),0,NULL,0},
  {&TA_float,NULL,"prf_rgo_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) on a purely random basis (prf_go_p)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::prf_rgo_da))),0,NULL,0},
  NULL};
static int MatrixRndGoThrSpec::* TA_MatrixRndGoThrSpec_MbrOff;
static MemberDef_data TA_MatrixRndGoThrSpec_MemberDef[]={
  {&TA_float,NULL,"abs_thr"," absolute threshold on per stripe avg_go_da value (-1..1) for triggering random GO (if stripe_agd < abs_min then Go p(go_p))","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::abs_thr))),0,NULL,0},
  {&TA_float,NULL,"abs_max"," absolute maximum on per stripe avg_go_da value (-1..1) above which no random GO can occur (if stripe_agd > abs_max then never Go)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::abs_max))),0,NULL,0},
  {&TA_float,NULL,"rel"," relative threshold on per stripe avg_go_da value (-1..1) for triggering random GO (if (stripe_agd - avg_agd) < -agd_rel then Go p(go_p))","DEF_0.05 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::rel))),0,NULL,0},
  {&TA_int,NULL,"mnt"," minimum maintenance duration (trials of sustained maintenance/off) for a stripe before a random GO will fire","DEF_10 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::mnt))),0,NULL,0},
  {&TA_float,NULL,"avgrew"," threshold on global avg reward value (0..1) below which random GO can fire (uses ExtRew_Stat if avail, else avg value from ExtRewLayer)","DEF_0.9 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::avgrew))),0,NULL,0},
  NULL};
static int MatrixMiscSpec::* TA_MatrixMiscSpec_MbrOff;
static MemberDef_data TA_MatrixMiscSpec_MemberDef[]={
  {&TA_float,NULL,"neg_da_bl"," negative da baseline in learning condition: this amount subtracted from all da values in learning phase (essentially reinforces nogo)","DEF_0.0002 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::neg_da_bl))),0,NULL,0},
  {&TA_float,NULL,"neg_gain"," gain for negative DA signals relative to positive ones: neg DA may need to be stronger!","DEF_1.5 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::neg_gain))),0,NULL,0},
  {&TA_float,NULL,"perf_gain"," performance effect da gain (in 2- phase for trans, 1+ for gogo)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::perf_gain))),0,NULL,0},
  {&TA_int,NULL,"max_mnt"," maximum maintenance duration: if longer than this, NOGO is activated as per rnd_go","DEF_50 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::max_mnt))),0,NULL,0},
  {&TA_float,NULL,"avg_go_dt"," time constant for integrating the average DA value associated with Go firing for each stripe (stored in u->misc_1)","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::avg_go_dt))),0,NULL,0},
  NULL};
static EnumDef_data TA_MatrixLayerSpec_BGType[]={
  {"MOTOR"," matrix that gates motor cortex responses","",0},
  {"PFC"," matrix that gates pfc working memory updating","",1},
  NULL};
static int MatrixLayerSpec::* TA_MatrixLayerSpec_MbrOff;
static MemberDef_data TA_MatrixLayerSpec_MemberDef[]={
  {NULL,"::BGType","bg_type"," type of basal ganglia/frontal system: motor or pfc","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::bg_type))),0,NULL,0},
  {&TA_MatrixMiscSpec,NULL,"matrix"," misc parameters for the matrix layer","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::matrix))),0,NULL,0},
  {&TA_ContrastSpec,NULL,"contrast"," contrast enhancement effects of da/dopamine neuromodulation","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::contrast))),0,NULL,0},
  {&TA_MatrixRndGoSpec,NULL,"rnd_go"," matrix random GO firing to encourage exploration for non-productive stripes based on avg_go_da for that stripe (matrix_u->misc_1)","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::rnd_go))),0,NULL,0},
  {&TA_MatrixRndGoThrSpec,NULL,"rnd_go_thr"," random Go firing thresholds: when to fire a random Go that drives learning","CONDEDIT_ON_rnd_go.on:true ","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::rnd_go_thr))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_RndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_ClearRndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaModUnit_NoContrast_MethArgs[]={
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"dav",""},
  {&TA_int,NULL,"go_no",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaModUnit_Contrast_MethArgs[]={
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"dav",""},
  {&TA_float,NULL,"gating_act",""},
  {&TA_int,NULL,"go_no",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaTonicMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaPerfMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaLearnMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_AvgGODA_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_MatrixLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_MatrixLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_RndGo"," compute random GO signal for stripes that have been dormant a longish time","","",
    0,2,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_RndGo_stub,TA_MatrixLayerSpec_Compute_RndGo_MethArgs},
  {&TA_void,NULL,"Compute_ClearRndGo"," clear the rnd go signal","","",
    0,2,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_ClearRndGo_stub,TA_MatrixLayerSpec_Compute_ClearRndGo_MethArgs},
  {&TA_void,NULL,"Compute_DaModUnit_NoContrast"," apply given dopamine modulation value to the unit, based on whether it is a go (0) or nogo (1); no contrast enancement based on activation","","",
    0,3,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaModUnit_NoContrast_stub,TA_MatrixLayerSpec_Compute_DaModUnit_NoContrast_MethArgs},
  {&TA_void,NULL,"Compute_DaModUnit_Contrast"," apply given dopamine modulation value to the unit, based on whether it is a go (0) or nogo (1); contrast enhancement based on activation (gating_act)","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaModUnit_Contrast_stub,TA_MatrixLayerSpec_Compute_DaModUnit_Contrast_MethArgs},
  {&TA_void,NULL,"Compute_DaTonicMod"," compute tonic da modulation (for pfc gating units in first two phases)","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaTonicMod_stub,TA_MatrixLayerSpec_Compute_DaTonicMod_MethArgs},
  {&TA_void,NULL,"Compute_DaPerfMod"," compute dynamic da modulation; performance modulation, not learning (second minus phase)","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaPerfMod_stub,TA_MatrixLayerSpec_Compute_DaPerfMod_MethArgs},
  {&TA_void,NULL,"Compute_DaLearnMod"," compute dynamic da modulation: evaluation modulation, which is sensitive to GO/NOGO firing and activation in action phase","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaLearnMod_stub,TA_MatrixLayerSpec_Compute_DaLearnMod_MethArgs},
  {&TA_void,NULL,"Compute_AvgGODA"," compute average da present when stripes fire a GO (stored in u->misc_1); used to modulate rnd_go firing","","",
    0,2,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_AvgGODA_stub,TA_MatrixLayerSpec_Compute_AvgGODA_MethArgs},
  NULL};
static int SNrThalLayerSpec::* TA_SNrThalLayerSpec_MbrOff;
static MemberDef_data TA_SNrThalLayerSpec_MemberDef[]={
  {&TA_float,NULL,"avg_net_dt"," time-averaged netinput computation integration rate","","",
    *((ta_memb_ptr*)&(TA_SNrThalLayerSpec_MbrOff=(int SNrThalLayerSpec::*)(&SNrThalLayerSpec::avg_net_dt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SNrThalLayerSpec_Compute_GoNogoNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_SNrThalLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_SNrThalLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_GoNogoNet"," compute netinput as GO - NOGO on matrix layer","","",
    0,2,-1,0,NULL,cssElCFun_SNrThalLayerSpec_Compute_GoNogoNet_stub,TA_SNrThalLayerSpec_Compute_GoNogoNet_MethArgs},
  NULL};
static EnumDef_data TA_PFCGateSpec_GateSignal[]={
  {"GATE_GO"," gate GO unit fired ","",0},
  {"GATE_NOGO"," gate NOGO unit fired","",1},
  NULL};
static EnumDef_data TA_PFCGateSpec_GateState[]={
  {"EMPTY_GO"," stripe was empty, got a GO","",0},
  {"EMPTY_NOGO"," stripe was empty, got a NOGO","",1},
  {"LATCH_GO"," stripe was already latched, got a GO","",2},
  {"LATCH_NOGO"," stripe was already latched, got a NOGO","",3},
  {"LATCH_GOGO"," stripe was already latched, got a GO then another GO","",4},
  {"NO_GATE"," no gating took place","",5},
  {"RANDOM_GO"," matrix random-Go for stripes firing lots of NoGo (causes learning)","",6},
  {"PERF_RND_GO"," performance-only unconditional matrix random-Go ","",7},
  NULL};
static int PFCGateSpec::* TA_PFCGateSpec_MbrOff;
static MemberDef_data TA_PFCGateSpec_MemberDef[]={
  {&TA_float,NULL,"go_thr"," threshold in snrthal activation required to trigger a GO","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::go_thr))),0,NULL,0},
  {&TA_float,NULL,"off_accom"," how much of the maintenance current to apply to accommodation after turning a unit off","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::off_accom))),0,NULL,0},
  {&TA_bool,NULL,"updt_reset_sd"," reset synaptic depression when units are updated","DEF_true ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::updt_reset_sd))),0,NULL,0},
  {&TA_float,NULL,"snr_tie_thr"," how high does the average netinput need to be to detect a tie-deadlock among a set of snrthal units all sending equally strong GO signals, such that the net activation is < go_thr?","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::snr_tie_thr))),0,NULL,0},
  {&TA_bool,NULL,"snr_tie_max"," choose the max active units to win in the case of a snrthal tie deadlock ","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::snr_tie_max))),0,NULL,0},
  NULL};
static EnumDef_data TA_PFCLayerSpec_MaintUpdtAct[]={
  {"NO_UPDT"," no update action","",0},
  {"STORE"," store current activity state in maintenance currents","",1},
  {"CLEAR"," clear current activity state from maintenance currents","",2},
  {"RESTORE"," restore prior maintenance currents (after transient input activation)","",3},
  {"TMP_STORE"," temporary store of current activity state (for default maintenance of last state)","",4},
  {"TMP_CLEAR"," temporary clear of current maintenance state (for transient representation in second plus)","",5},
  NULL};
static int PFCLayerSpec::* TA_PFCLayerSpec_MbrOff;
static MemberDef_data TA_PFCLayerSpec_MemberDef[]={
  {&TA_PFCGateSpec,NULL,"gate"," parameters controlling the gating of pfc units","","",
    *((ta_memb_ptr*)&(TA_PFCLayerSpec_MbrOff=(int PFCLayerSpec::*)(&PFCLayerSpec::gate))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_ResetSynDep_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_MaintUpdt_MethArgs[]={
  {&TA_LeabraUnit_Group_ptr,NULL,"ugp",""},
  {NULL,"::MaintUpdtAct","updt_act",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_SendGateStates_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_TmpClear_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_GatingTrans_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_GatingGOGO_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_PFCLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_PFCLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ResetSynDep"," reset synaptic depression for sending cons from unit that was just toggled off in plus phase 1","","",
    0,3,-1,0,NULL,cssElCFun_PFCLayerSpec_ResetSynDep_stub,TA_PFCLayerSpec_ResetSynDep_MethArgs},
  {&TA_void,NULL,"Compute_MaintUpdt"," update maintenance state variables (gc.h, misc_1) based on given action","","",
    0,4,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_MaintUpdt_stub,TA_PFCLayerSpec_Compute_MaintUpdt_MethArgs},
  {&TA_void,NULL,"SendGateStates"," send misc_state gating state variables to the snrthal and matrix layers","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_SendGateStates_stub,TA_PFCLayerSpec_SendGateStates_MethArgs},
  {&TA_void,NULL,"Compute_TmpClear"," temporarily clear the maintenance of pfc units to prepare way for transient acts","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_TmpClear_stub,TA_PFCLayerSpec_Compute_TmpClear_MethArgs},
  {&TA_void,NULL,"Compute_GatingTrans"," compute the gating signal based on SNrThal layer: TRANS model","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_GatingTrans_stub,TA_PFCLayerSpec_Compute_GatingTrans_MethArgs},
  {&TA_void,NULL,"Compute_GatingGOGO"," compute the gating signal based on SNrThal layer: GOGO model","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_GatingGOGO_stub,TA_PFCLayerSpec_Compute_GatingGOGO_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraWiz_StdNetwork_MethArgs[]={
  {&TA_Network_ptr,NULL,"net"," 0"},
  NULL};
static MethodArgs_data TA_LeabraWiz_StdLayerSpecs_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraWiz_SRNContext_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraWiz_UnitInhib_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_inhib_units","10"},
  NULL};
static MethodArgs_data TA_LeabraWiz_TD_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," 1"},
  {&TA_bool,NULL,"td_mod_all"," 0"},
  NULL};
static MethodArgs_data TA_LeabraWiz_PVLV_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," 1"},
  {&TA_bool,NULL,"fm_hid_cons","1"},
  {&TA_bool,NULL,"fm_out_cons","0"},
  {&TA_bool,NULL,"da_mod_all"," 0"},
  NULL};
static MethodArgs_data TA_LeabraWiz_BgPFC_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_stripes","4"},
  {&TA_bool,NULL,"fm_hid_cons","0"},
  {&TA_bool,NULL,"fm_out_cons","0"},
  {&TA_bool,NULL,"mat_fm_pfc_full"," 0"},
  {&TA_bool,NULL,"make_patch","0"},
  {&TA_bool,NULL,"nolrn_pfc","0"},
  {&TA_bool,NULL,"da_mod_all"," 0"},
  {&TA_bool,NULL,"lr_sched"," 1"},
  NULL};
static MethodArgs_data TA_LeabraWiz_SetPFCStripes_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_stripes",""},
  {&TA_int,NULL,"n_units","-1"},
  NULL};
static MethodDef_data TA_LeabraWiz_MethodDef[]={
  {&TA_void,NULL,"StdNetwork"," make a standard network according to the current settings (if net == NULL, new network is created)","MENU_BUTTON MENU_ON_Network NULL_OK ","",
    1,1,0,0,NULL,cssElCFun_LeabraWiz_StdNetwork_stub,TA_LeabraWiz_StdNetwork_MethArgs},
  {&TA_void,NULL,"StdLayerSpecs"," make standard layer specs for a basic Leabra network (KWTA_AVG 25% for hiddens, KWTA PAT_K for input/output)","MENU_BUTTON MENU_ON_Network MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraWiz_StdLayerSpecs_stub,TA_LeabraWiz_StdLayerSpecs_MethArgs},
  {&TA_void,NULL,"SRNContext"," configure a simple-recurrent-network context layer in the network","MENU_BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_LeabraWiz_SRNContext_stub,TA_LeabraWiz_SRNContext_MethArgs},
  {&TA_void,NULL,"UnitInhib"," configures unit-based inhibition for all layers in the network","MENU_BUTTON ","",
    0,2,1,0,NULL,cssElCFun_LeabraWiz_UnitInhib_stub,TA_LeabraWiz_UnitInhib_MethArgs},
  {&TA_void,NULL,"TD"," configure standard TD reinforcement learning layers; bio_labels = use biologically-based labels for layers, else functional; td_mod_all = have td value modulate all the regular units in the network","MENU_BUTTON MENU_SEP_BEFORE ","",
    0,3,1,0,NULL,cssElCFun_LeabraWiz_TD_stub,TA_LeabraWiz_TD_MethArgs},
  {&TA_void,NULL,"PVLV"," configure PVLV (pavlovian perceived value from learned value) learning layers in a network; bio_labels = use biologically-based labels for layers, else functional; da_mod_all = have da value modulate all the regular units in the network","MENU_BUTTON ","",
    0,5,1,0,NULL,cssElCFun_LeabraWiz_PVLV_stub,TA_LeabraWiz_PVLV_MethArgs},
  {&TA_void,NULL,"BgPFC"," configure all the layers and specs for doing basal-ganglia based gating of the pfc layer; fm_hid_cons = make cons to pfc/bg fm hidden layers; fm_out_cons = from output layers; mat_fm_pfc_full = make pfc -> matrix prjn full (else stripe-specific); patch per-stripe learning system optional; nolrn_pfc = pfc does not learn -- just copies input acts directly; da_mod_all = have da value modulate all the regular units in the network; lr_sched = make a learning rate schedule on BG learn cons","MENU_BUTTON MENU_SEP_BEFORE ","",
    0,9,1,0,NULL,cssElCFun_LeabraWiz_BgPFC_stub,TA_LeabraWiz_BgPFC_MethArgs},
  {&TA_void,NULL,"SetPFCStripes"," set number of 'stripes' (unit groups) throughout the entire set of pfc/bg layers (n_units = -1 = use current of units)","MENU_BUTTON  ","",
    0,3,2,0,NULL,cssElCFun_LeabraWiz_SetPFCStripes_stub,TA_LeabraWiz_SetPFCStripes_MethArgs},
  NULL};

// Init Function


static bool ta_Init_oldlba_done = false;

void ta_Init_oldlba() {
  TypeDef* sbt;

  if(ta_Init_oldlba_done) return;
  ta_Init_oldlba_done = true;

  ta_Init_ta();
  ta_Init_pdp();
  ta_Init_ta_misc();
  ta_Init_iv_graphic();

  taMisc::in_init = true;

  taMisc::types.Add(&TA_LeabraCon);
    TAI_LeabraCon = new LeabraCon;
    TA_LeabraCon.AddParFormal(&TA_class);
    TA_LeabraCon.AddParCache(&TA_taBase);
    TA_LeabraCon.AddClassPar(&TA_Connection,0);
    tac_AddMembers(TA_LeabraCon,TA_LeabraCon_MemberDef);
  taMisc::types.Add(&TA_LeabraConSpec);
    TAI_LeabraConSpec = new LeabraConSpec;
    TA_LeabraConSpec.AddParFormal(&TA_class);
    TA_LeabraConSpec.AddParCache(&TA_taBase);
    TA_LeabraConSpec.AddClassPar(&TA_ConSpec,0);
    tac_AddEnum(TA_LeabraConSpec, "LRSValue", " what value to drive the learning rate schedule with", "", "", "", TA_LeabraConSpec_LRSValue);
    tac_AddMembers(TA_LeabraConSpec,TA_LeabraConSpec_MemberDef);
    tac_AddMethods(TA_LeabraConSpec,TA_LeabraConSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraBiasSpec);
    TAI_LeabraBiasSpec = new LeabraBiasSpec;
    TA_LeabraBiasSpec.AddParFormal(&TA_class);
    TA_LeabraBiasSpec.AddParCache(&TA_taBase);
    TA_LeabraBiasSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_LeabraBiasSpec,TA_LeabraBiasSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraCon_Group);
    TAI_LeabraCon_Group = new LeabraCon_Group;
    TA_LeabraCon_Group.AddParFormal(&TA_class);
    TA_LeabraCon_Group.AddParCache(&TA_taBase);
    TA_LeabraCon_Group.AddClassPar(&TA_Con_Group,0);
    tac_AddMembers(TA_LeabraCon_Group,TA_LeabraCon_Group_MemberDef);
    tac_AddMethods(TA_LeabraCon_Group,TA_LeabraCon_Group_MethodDef);
  taMisc::types.Add(&TA_LeabraUnitSpec);
    TAI_LeabraUnitSpec = new LeabraUnitSpec;
    TA_LeabraUnitSpec.AddParFormal(&TA_class);
    TA_LeabraUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraUnitSpec.AddClassPar(&TA_UnitSpec,0);
    tac_AddEnum(TA_LeabraUnitSpec, "ActFun", "", "", "", "", TA_LeabraUnitSpec_ActFun);
    tac_AddEnum(TA_LeabraUnitSpec, "NoiseType", "", "", "", "", TA_LeabraUnitSpec_NoiseType);
    tac_AddMembers(TA_LeabraUnitSpec,TA_LeabraUnitSpec_MemberDef);
    tac_AddMethods(TA_LeabraUnitSpec,TA_LeabraUnitSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraUnit);
    TAI_LeabraUnit = new LeabraUnit;
    TA_LeabraUnit.AddParFormal(&TA_class);
    TA_LeabraUnit.AddParCache(&TA_taBase);
    TA_LeabraUnit.AddClassPar(&TA_Unit,0);
    tac_AddMembers(TA_LeabraUnit,TA_LeabraUnit_MemberDef);
    tac_AddMethods(TA_LeabraUnit,TA_LeabraUnit_MethodDef);
  taMisc::types.Add(&TA_LeabraInhib);
    TAI_LeabraInhib = new LeabraInhib;
    TA_LeabraInhib.AddParFormal(&TA_class);
    tac_AddMembers(TA_LeabraInhib,TA_LeabraInhib_MemberDef);
    tac_AddMethods(TA_LeabraInhib,TA_LeabraInhib_MethodDef);
  taMisc::types.Add(&TA_LeabraLayerSpec);
    TAI_LeabraLayerSpec = new LeabraLayerSpec;
    TA_LeabraLayerSpec.AddParFormal(&TA_class);
    TA_LeabraLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraLayerSpec.AddClassPar(&TA_LayerSpec,0);
    tac_AddEnum(TA_LeabraLayerSpec, "Compute_I", " how to compute the inhibition", "", "", "", TA_LeabraLayerSpec_Compute_I);
    tac_AddEnum(TA_LeabraLayerSpec, "InhibGroup", "", "", "", "", TA_LeabraLayerSpec_InhibGroup);
    tac_AddMembers(TA_LeabraLayerSpec,TA_LeabraLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraLayerSpec,TA_LeabraLayerSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraUnit_Group);
    TAI_LeabraUnit_Group = new LeabraUnit_Group;
    TA_LeabraUnit_Group.AddParFormal(&TA_class);
    TA_LeabraUnit_Group.AddParCache(&TA_taBase);
    TA_LeabraUnit_Group.AddClassPar(&TA_Unit_Group,(int)((unsigned long)((Unit_Group*)TAI_LeabraUnit_Group)-(unsigned long)TAI_LeabraUnit_Group), &TA_LeabraInhib,(int)((unsigned long)((LeabraInhib*)TAI_LeabraUnit_Group)-(unsigned long)TAI_LeabraUnit_Group));
    tac_AddMembers(TA_LeabraUnit_Group,TA_LeabraUnit_Group_MemberDef);
    tac_AddMethods(TA_LeabraUnit_Group,TA_LeabraUnit_Group_MethodDef);
  taMisc::types.Add(&TA_LeabraLayer);
    TAI_LeabraLayer = new LeabraLayer;
    TA_LeabraLayer.AddParFormal(&TA_class);
    TA_LeabraLayer.AddParCache(&TA_taBase);
    TA_LeabraLayer.AddClassPar(&TA_Layer,(int)((unsigned long)((Layer*)TAI_LeabraLayer)-(unsigned long)TAI_LeabraLayer), &TA_LeabraInhib,(int)((unsigned long)((LeabraInhib*)TAI_LeabraLayer)-(unsigned long)TAI_LeabraLayer));
    tac_AddMembers(TA_LeabraLayer,TA_LeabraLayer_MemberDef);
    tac_AddMethods(TA_LeabraLayer,TA_LeabraLayer_MethodDef);
  taMisc::types.Add(&TA_LeabraCycle);
    TAI_LeabraCycle = new LeabraCycle;
    TA_LeabraCycle.AddParFormal(&TA_class);
    TA_LeabraCycle.AddParCache(&TA_taBase);
    TA_LeabraCycle.AddClassPar(&TA_CycleProcess,0);
    tac_AddMembers(TA_LeabraCycle,TA_LeabraCycle_MemberDef);
    tac_AddMethods(TA_LeabraCycle,TA_LeabraCycle_MethodDef);
  taMisc::types.Add(&TA_LeabraSettle);
    TAI_LeabraSettle = new LeabraSettle;
    TA_LeabraSettle.AddParFormal(&TA_class);
    TA_LeabraSettle.AddParCache(&TA_taBase);
    TA_LeabraSettle.AddClassPar(&TA_SettleProcess,0);
    tac_AddMembers(TA_LeabraSettle,TA_LeabraSettle_MemberDef);
    tac_AddMethods(TA_LeabraSettle,TA_LeabraSettle_MethodDef);
  taMisc::types.Add(&TA_LeabraTrial);
    TAI_LeabraTrial = new LeabraTrial;
    TA_LeabraTrial.AddParFormal(&TA_class);
    TA_LeabraTrial.AddParCache(&TA_taBase);
    TA_LeabraTrial.AddClassPar(&TA_TrialProcess,0);
    tac_AddEnum(TA_LeabraTrial, "StateInit", " ways of initializing the state of the network", "", "", "", TA_LeabraTrial_StateInit);
    tac_AddEnum(TA_LeabraTrial, "Phase", "", "", "", "", TA_LeabraTrial_Phase);
    tac_AddEnum(TA_LeabraTrial, "PhaseOrder", "", "", "", "", TA_LeabraTrial_PhaseOrder);
    tac_AddEnum(TA_LeabraTrial, "FirstPlusdWt", "", "", "", "", TA_LeabraTrial_FirstPlusdWt);
    tac_AddMembers(TA_LeabraTrial,TA_LeabraTrial_MemberDef);
    tac_AddMethods(TA_LeabraTrial,TA_LeabraTrial_MethodDef);
  taMisc::types.Add(&TA_LeabraMaxDa);
    TAI_LeabraMaxDa = new LeabraMaxDa;
    TA_LeabraMaxDa.AddParFormal(&TA_class);
    TA_LeabraMaxDa.AddParCache(&TA_taBase);
    TA_LeabraMaxDa.AddClassPar(&TA_Stat,0);
    tac_AddEnum(TA_LeabraMaxDa, "dAType", "", "", "", "", TA_LeabraMaxDa_dAType);
    tac_AddMembers(TA_LeabraMaxDa,TA_LeabraMaxDa_MemberDef);
    tac_AddMethods(TA_LeabraMaxDa,TA_LeabraMaxDa_MethodDef);
  taMisc::types.Add(&TA_const_LeabraCon);
    TA_const_LeabraCon.AddParents(&TA_const, &TA_LeabraCon);
  taMisc::types.Add(&TA_const_LeabraCon_ref);
    TA_const_LeabraCon_ref.AddParents(&TA_const_LeabraCon);
  taMisc::types.Add(&TA_WtScaleSpec);
    TAI_WtScaleSpec = new WtScaleSpec;
    TA_WtScaleSpec.AddParFormal(&TA_class);
    TA_WtScaleSpec.AddParCache(&TA_taBase);
    TA_WtScaleSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_WtScaleSpec,TA_WtScaleSpec_MemberDef);
    tac_AddMethods(TA_WtScaleSpec,TA_WtScaleSpec_MethodDef);
  taMisc::types.Add(&TA_const_WtScaleSpec);
    TA_const_WtScaleSpec.AddParents(&TA_const, &TA_WtScaleSpec);
  taMisc::types.Add(&TA_WtSigSpec);
    TAI_WtSigSpec = new WtSigSpec;
    TA_WtSigSpec.AddParFormal(&TA_class);
    TA_WtSigSpec.AddParCache(&TA_taBase);
    TA_WtSigSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_WtSigSpec,TA_WtSigSpec_MemberDef);
    tac_AddMethods(TA_WtSigSpec,TA_WtSigSpec_MethodDef);
  taMisc::types.Add(&TA_const_WtScaleSpec_ref);
    TA_const_WtScaleSpec_ref.AddParents(&TA_const_WtScaleSpec);
  taMisc::types.Add(&TA_const_WtSigSpec);
    TA_const_WtSigSpec.AddParents(&TA_const, &TA_WtSigSpec);
  taMisc::types.Add(&TA_const_WtSigSpec_ref);
    TA_const_WtSigSpec_ref.AddParents(&TA_const_WtSigSpec);
  taMisc::types.Add(&TA_LearnMixSpec);
    TAI_LearnMixSpec = new LearnMixSpec;
    TA_LearnMixSpec.AddParFormal(&TA_class);
    TA_LearnMixSpec.AddParCache(&TA_taBase);
    TA_LearnMixSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LearnMixSpec,TA_LearnMixSpec_MemberDef);
  taMisc::types.Add(&TA_const_LearnMixSpec);
    TA_const_LearnMixSpec.AddParents(&TA_const, &TA_LearnMixSpec);
  taMisc::types.Add(&TA_const_LearnMixSpec_ref);
    TA_const_LearnMixSpec_ref.AddParents(&TA_const_LearnMixSpec);
  taMisc::types.Add(&TA_FixedSAvg);
    TAI_FixedSAvg = new FixedSAvg;
    TA_FixedSAvg.AddParFormal(&TA_class);
    TA_FixedSAvg.AddParCache(&TA_taBase);
    TA_FixedSAvg.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_FixedSAvg,TA_FixedSAvg_MemberDef);
    tac_AddMethods(TA_FixedSAvg,TA_FixedSAvg_MethodDef);
  taMisc::types.Add(&TA_const_FixedSAvg);
    TA_const_FixedSAvg.AddParents(&TA_const, &TA_FixedSAvg);
  taMisc::types.Add(&TA_const_FixedSAvg_ref);
    TA_const_FixedSAvg_ref.AddParents(&TA_const_FixedSAvg);
  taMisc::types.Add(&TA_SAvgCorSpec);
    TAI_SAvgCorSpec = new SAvgCorSpec;
    TA_SAvgCorSpec.AddParFormal(&TA_class);
    TA_SAvgCorSpec.AddParCache(&TA_taBase);
    TA_SAvgCorSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_SAvgCorSpec, "SAvgSource", "", "", "", "", TA_SAvgCorSpec_SAvgSource);
    tac_AddMembers(TA_SAvgCorSpec,TA_SAvgCorSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraCon_Group_ptr);
    TA_LeabraCon_Group_ptr.AddParents(&TA_LeabraCon_Group);
  taMisc::types.Add(&TA_const_SAvgCorSpec);
    TA_const_SAvgCorSpec.AddParents(&TA_const, &TA_SAvgCorSpec);
  taMisc::types.Add(&TA_LeabraCon_ptr);
    TA_LeabraCon_ptr.AddParents(&TA_LeabraCon);
  taMisc::types.Add(&TA_const_SAvgCorSpec_ref);
    TA_const_SAvgCorSpec_ref.AddParents(&TA_const_SAvgCorSpec);
  taMisc::types.Add(&TA_LeabraUnit_ptr);
    TA_LeabraUnit_ptr.AddParents(&TA_LeabraUnit);
  taMisc::types.Add(&TA_LeabraUnitSpec_ptr);
    TA_LeabraUnitSpec_ptr.AddParents(&TA_LeabraUnitSpec);
  taMisc::types.Add(&TA_LeabraTrial_ptr);
    TA_LeabraTrial_ptr.AddParents(&TA_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraConSpec);
    TA_const_LeabraConSpec.AddParents(&TA_const, &TA_LeabraConSpec);
  taMisc::types.Add(&TA_const_LeabraConSpec_ref);
    TA_const_LeabraConSpec_ref.AddParents(&TA_const_LeabraConSpec);
  taMisc::types.Add(&TA_const_LeabraBiasSpec);
    TA_const_LeabraBiasSpec.AddParents(&TA_const, &TA_LeabraBiasSpec);
  taMisc::types.Add(&TA_const_LeabraBiasSpec_ref);
    TA_const_LeabraBiasSpec_ref.AddParents(&TA_const_LeabraBiasSpec);
  taMisc::types.Add(&TA_const_LeabraCon_Group);
    TA_const_LeabraCon_Group.AddParents(&TA_const, &TA_LeabraCon_Group);
  taMisc::types.Add(&TA_const_LeabraCon_Group_ref);
    TA_const_LeabraCon_Group_ref.AddParents(&TA_const_LeabraCon_Group);
  taMisc::types.Add(&TA_ActFunSpec);
    TAI_ActFunSpec = new ActFunSpec;
    TA_ActFunSpec.AddParFormal(&TA_class);
    TA_ActFunSpec.AddParCache(&TA_taBase);
    TA_ActFunSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActFunSpec,TA_ActFunSpec_MemberDef);
  taMisc::types.Add(&TA_const_ActFunSpec);
    TA_const_ActFunSpec.AddParents(&TA_const, &TA_ActFunSpec);
  taMisc::types.Add(&TA_SpikeFunSpec);
    TAI_SpikeFunSpec = new SpikeFunSpec;
    TA_SpikeFunSpec.AddParFormal(&TA_class);
    TA_SpikeFunSpec.AddParCache(&TA_taBase);
    TA_SpikeFunSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SpikeFunSpec,TA_SpikeFunSpec_MemberDef);
  taMisc::types.Add(&TA_const_ActFunSpec_ref);
    TA_const_ActFunSpec_ref.AddParents(&TA_const_ActFunSpec);
  taMisc::types.Add(&TA_const_SpikeFunSpec);
    TA_const_SpikeFunSpec.AddParents(&TA_const, &TA_SpikeFunSpec);
  taMisc::types.Add(&TA_const_SpikeFunSpec_ref);
    TA_const_SpikeFunSpec_ref.AddParents(&TA_const_SpikeFunSpec);
  taMisc::types.Add(&TA_DepressSpec);
    TAI_DepressSpec = new DepressSpec;
    TA_DepressSpec.AddParFormal(&TA_class);
    TA_DepressSpec.AddParCache(&TA_taBase);
    TA_DepressSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_DepressSpec, "PSpike", "", "", "", "", TA_DepressSpec_PSpike);
    tac_AddMembers(TA_DepressSpec,TA_DepressSpec_MemberDef);
  taMisc::types.Add(&TA_const_DepressSpec);
    TA_const_DepressSpec.AddParents(&TA_const, &TA_DepressSpec);
  taMisc::types.Add(&TA_const_DepressSpec_ref);
    TA_const_DepressSpec_ref.AddParents(&TA_const_DepressSpec);
  taMisc::types.Add(&TA_OptThreshSpec);
    TAI_OptThreshSpec = new OptThreshSpec;
    TA_OptThreshSpec.AddParFormal(&TA_class);
    TA_OptThreshSpec.AddParCache(&TA_taBase);
    TA_OptThreshSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_OptThreshSpec,TA_OptThreshSpec_MemberDef);
  taMisc::types.Add(&TA_const_OptThreshSpec);
    TA_const_OptThreshSpec.AddParents(&TA_const, &TA_OptThreshSpec);
  taMisc::types.Add(&TA_const_OptThreshSpec_ref);
    TA_const_OptThreshSpec_ref.AddParents(&TA_const_OptThreshSpec);
  taMisc::types.Add(&TA_DtSpec);
    TAI_DtSpec = new DtSpec;
    TA_DtSpec.AddParFormal(&TA_class);
    TA_DtSpec.AddParCache(&TA_taBase);
    TA_DtSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DtSpec,TA_DtSpec_MemberDef);
  taMisc::types.Add(&TA_const_DtSpec);
    TA_const_DtSpec.AddParents(&TA_const, &TA_DtSpec);
  taMisc::types.Add(&TA_const_DtSpec_ref);
    TA_const_DtSpec_ref.AddParents(&TA_const_DtSpec);
  taMisc::types.Add(&TA_LeabraChannels);
    TAI_LeabraChannels = new LeabraChannels;
    TA_LeabraChannels.AddParFormal(&TA_class);
    TA_LeabraChannels.AddParCache(&TA_taBase);
    TA_LeabraChannels.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LeabraChannels,TA_LeabraChannels_MemberDef);
  taMisc::types.Add(&TA_const_LeabraChannels);
    TA_const_LeabraChannels.AddParents(&TA_const, &TA_LeabraChannels);
  taMisc::types.Add(&TA_const_LeabraChannels_ref);
    TA_const_LeabraChannels_ref.AddParents(&TA_const_LeabraChannels);
  taMisc::types.Add(&TA_VChanSpec);
    TAI_VChanSpec = new VChanSpec;
    TA_VChanSpec.AddParFormal(&TA_class);
    TA_VChanSpec.AddParCache(&TA_taBase);
    TA_VChanSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VChanSpec,TA_VChanSpec_MemberDef);
    tac_AddMethods(TA_VChanSpec,TA_VChanSpec_MethodDef);
  taMisc::types.Add(&TA_const_VChanSpec);
    TA_const_VChanSpec.AddParents(&TA_const, &TA_VChanSpec);
  taMisc::types.Add(&TA_PhaseSharpSpec);
    TAI_PhaseSharpSpec = new PhaseSharpSpec;
    TA_PhaseSharpSpec.AddParFormal(&TA_class);
    TA_PhaseSharpSpec.AddParCache(&TA_taBase);
    TA_PhaseSharpSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PhaseSharpSpec, "SharpType", "", "", "", "", TA_PhaseSharpSpec_SharpType);
    tac_AddMembers(TA_PhaseSharpSpec,TA_PhaseSharpSpec_MemberDef);
  taMisc::types.Add(&TA_const_VChanSpec_ref);
    TA_const_VChanSpec_ref.AddParents(&TA_const_VChanSpec);
  taMisc::types.Add(&TA_const_PhaseSharpSpec);
    TA_const_PhaseSharpSpec.AddParents(&TA_const, &TA_PhaseSharpSpec);
  taMisc::types.Add(&TA_const_PhaseSharpSpec_ref);
    TA_const_PhaseSharpSpec_ref.AddParents(&TA_const_PhaseSharpSpec);
  taMisc::types.Add(&TA_ActRegSpec);
    TAI_ActRegSpec = new ActRegSpec;
    TA_ActRegSpec.AddParFormal(&TA_class);
    TA_ActRegSpec.AddParCache(&TA_taBase);
    TA_ActRegSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActRegSpec,TA_ActRegSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraLayer_ptr);
    TA_LeabraLayer_ptr.AddParents(&TA_LeabraLayer);
  taMisc::types.Add(&TA_const_ActRegSpec);
    TA_const_ActRegSpec.AddParents(&TA_const, &TA_ActRegSpec);
  taMisc::types.Add(&TA_LeabraInhib_ptr);
    TA_LeabraInhib_ptr.AddParents(&TA_LeabraInhib);
  taMisc::types.Add(&TA_const_ActRegSpec_ref);
    TA_const_ActRegSpec_ref.AddParents(&TA_const_ActRegSpec);
  taMisc::types.Add(&TA_const_LeabraUnitSpec);
    TA_const_LeabraUnitSpec.AddParents(&TA_const, &TA_LeabraUnitSpec);
  taMisc::types.Add(&TA_const_LeabraUnitSpec_ref);
    TA_const_LeabraUnitSpec_ref.AddParents(&TA_const_LeabraUnitSpec);
  taMisc::types.Add(&TA_VChanBasis);
    TAI_VChanBasis = new VChanBasis;
    TA_VChanBasis.AddParFormal(&TA_class);
    TA_VChanBasis.AddParCache(&TA_taBase);
    TA_VChanBasis.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VChanBasis,TA_VChanBasis_MemberDef);
  taMisc::types.Add(&TA_const_VChanBasis);
    TA_const_VChanBasis.AddParents(&TA_const, &TA_VChanBasis);
  taMisc::types.Add(&TA_LeabraUnitChans);
    TAI_LeabraUnitChans = new LeabraUnitChans;
    TA_LeabraUnitChans.AddParFormal(&TA_class);
    TA_LeabraUnitChans.AddParCache(&TA_taBase);
    TA_LeabraUnitChans.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LeabraUnitChans,TA_LeabraUnitChans_MemberDef);
  taMisc::types.Add(&TA_const_VChanBasis_ref);
    TA_const_VChanBasis_ref.AddParents(&TA_const_VChanBasis);
  taMisc::types.Add(&TA_const_LeabraUnit);
    TA_const_LeabraUnit.AddParents(&TA_const, &TA_LeabraUnit);
  taMisc::types.Add(&TA_const_LeabraUnitChans);
    TA_const_LeabraUnitChans.AddParents(&TA_const, &TA_LeabraUnitChans);
  taMisc::types.Add(&TA_const_LeabraUnit_ref);
    TA_const_LeabraUnit_ref.AddParents(&TA_const_LeabraUnit);
  taMisc::types.Add(&TA_const_LeabraUnitChans_ref);
    TA_const_LeabraUnitChans_ref.AddParents(&TA_const_LeabraUnitChans);
  taMisc::types.Add(&TA_taPtrList_LeabraUnit_);
    TAI_taPtrList_LeabraUnit_ = new taPtrList<LeabraUnit>;
    TA_taPtrList_LeabraUnit_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taPtrList_LeabraUnit_.AddClassPar(&TA_taPtrList,0);
    sbt = new TypeDef("LeabraUnit_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LeabraUnit);
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    tac_AddMethods(TA_taPtrList_LeabraUnit_,TA_taPtrList_LeabraUnit__MethodDef);
  taMisc::types.Add(&TA_LeabraSort);
    TAI_LeabraSort = new LeabraSort;
    TA_LeabraSort.AddParFormal(&TA_class);
    TA_LeabraSort.AddClassPar(&TA_taPtrList_LeabraUnit_,0);
    tac_AddMethods(TA_LeabraSort,TA_LeabraSort_MethodDef);
  taMisc::types.Add(&TA_KWTASpec);
    TAI_KWTASpec = new KWTASpec;
    TA_KWTASpec.AddParFormal(&TA_class);
    TA_KWTASpec.AddParCache(&TA_taBase);
    TA_KWTASpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_KWTASpec, "K_From", "", "", "", "", TA_KWTASpec_K_From);
    tac_AddMembers(TA_KWTASpec,TA_KWTASpec_MemberDef);
  taMisc::types.Add(&TA_const_KWTASpec);
    TA_const_KWTASpec.AddParents(&TA_const, &TA_KWTASpec);
  taMisc::types.Add(&TA_AdaptISpec);
    TAI_AdaptISpec = new AdaptISpec;
    TA_AdaptISpec.AddParFormal(&TA_class);
    TA_AdaptISpec.AddParCache(&TA_taBase);
    TA_AdaptISpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_AdaptISpec, "AdaptType", "", "", "", "", TA_AdaptISpec_AdaptType);
    tac_AddMembers(TA_AdaptISpec,TA_AdaptISpec_MemberDef);
  taMisc::types.Add(&TA_const_KWTASpec_ref);
    TA_const_KWTASpec_ref.AddParents(&TA_const_KWTASpec);
  taMisc::types.Add(&TA_const_AdaptISpec);
    TA_const_AdaptISpec.AddParents(&TA_const, &TA_AdaptISpec);
  taMisc::types.Add(&TA_const_AdaptISpec_ref);
    TA_const_AdaptISpec_ref.AddParents(&TA_const_AdaptISpec);
  taMisc::types.Add(&TA_ClampSpec);
    TAI_ClampSpec = new ClampSpec;
    TA_ClampSpec.AddParFormal(&TA_class);
    TA_ClampSpec.AddParCache(&TA_taBase);
    TA_ClampSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ClampSpec,TA_ClampSpec_MemberDef);
  taMisc::types.Add(&TA_const_ClampSpec);
    TA_const_ClampSpec.AddParents(&TA_const, &TA_ClampSpec);
  taMisc::types.Add(&TA_const_ClampSpec_ref);
    TA_const_ClampSpec_ref.AddParents(&TA_const_ClampSpec);
  taMisc::types.Add(&TA_DecaySpec);
    TAI_DecaySpec = new DecaySpec;
    TA_DecaySpec.AddParFormal(&TA_class);
    TA_DecaySpec.AddParCache(&TA_taBase);
    TA_DecaySpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DecaySpec,TA_DecaySpec_MemberDef);
  taMisc::types.Add(&TA_const_DecaySpec);
    TA_const_DecaySpec.AddParents(&TA_const, &TA_DecaySpec);
  taMisc::types.Add(&TA_const_DecaySpec_ref);
    TA_const_DecaySpec_ref.AddParents(&TA_const_DecaySpec);
  taMisc::types.Add(&TA_LayerLinkSpec);
    TAI_LayerLinkSpec = new LayerLinkSpec;
    TA_LayerLinkSpec.AddParFormal(&TA_class);
    TA_LayerLinkSpec.AddParCache(&TA_taBase);
    TA_LayerLinkSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LayerLinkSpec,TA_LayerLinkSpec_MemberDef);
  taMisc::types.Add(&TA_const_LayerLinkSpec);
    TA_const_LayerLinkSpec.AddParents(&TA_const, &TA_LayerLinkSpec);
  taMisc::types.Add(&TA_KWTASpec_ref);
    TA_KWTASpec_ref.AddParents(&TA_KWTASpec);
  taMisc::types.Add(&TA_const_LayerLinkSpec_ref);
    TA_const_LayerLinkSpec_ref.AddParents(&TA_const_LayerLinkSpec);
  taMisc::types.Add(&TA_const_LeabraLayerSpec);
    TA_const_LeabraLayerSpec.AddParents(&TA_const, &TA_LeabraLayerSpec);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_ref);
    TA_const_LeabraLayerSpec_ref.AddParents(&TA_const_LeabraLayerSpec);
  taMisc::types.Add(&TA_SpecPtr_LeabraLayerSpec_);
    TAI_SpecPtr_LeabraLayerSpec_ = new SpecPtr<LeabraLayerSpec>;
    TA_SpecPtr_LeabraLayerSpec_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_SpecPtr_LeabraLayerSpec_.AddParCache(&TA_taBase);
    TA_SpecPtr_LeabraLayerSpec_.AddClassPar(&TA_SpecPtr,0);
    sbt = new TypeDef("LeabraLayerSpec_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LeabraLayerSpec);
    TA_SpecPtr_LeabraLayerSpec_.sub_types.Add(sbt);
    tac_AddMembers(TA_SpecPtr_LeabraLayerSpec_,TA_SpecPtr_LeabraLayerSpec__MemberDef);
    tac_AddMethods(TA_SpecPtr_LeabraLayerSpec_,TA_SpecPtr_LeabraLayerSpec__MethodDef);
  taMisc::types.Add(&TA_LeabraLayerSpec_SPtr);
    TAI_LeabraLayerSpec_SPtr = new LeabraLayerSpec_SPtr;
    TA_LeabraLayerSpec_SPtr.AddParFormal(&TA_class);
    TA_LeabraLayerSpec_SPtr.AddParCache(&TA_taBase);
    TA_LeabraLayerSpec_SPtr.AddClassPar(&TA_SpecPtr_LeabraLayerSpec_,0);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_SPtr);
    TA_const_LeabraLayerSpec_SPtr.AddParents(&TA_const, &TA_LeabraLayerSpec_SPtr);
  taMisc::types.Add(&TA_AvgMaxVals);
    TAI_AvgMaxVals = new AvgMaxVals;
    TA_AvgMaxVals.AddParFormal(&TA_class);
    TA_AvgMaxVals.AddParCache(&TA_taBase);
    TA_AvgMaxVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AvgMaxVals,TA_AvgMaxVals_MemberDef);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_SPtr_ref);
    TA_const_LeabraLayerSpec_SPtr_ref.AddParents(&TA_const_LeabraLayerSpec_SPtr);
  taMisc::types.Add(&TA_const_AvgMaxVals);
    TA_const_AvgMaxVals.AddParents(&TA_const, &TA_AvgMaxVals);
  taMisc::types.Add(&TA_const_AvgMaxVals_ref);
    TA_const_AvgMaxVals_ref.AddParents(&TA_const_AvgMaxVals);
  taMisc::types.Add(&TA_KWTAVals);
    TAI_KWTAVals = new KWTAVals;
    TA_KWTAVals.AddParFormal(&TA_class);
    TA_KWTAVals.AddParCache(&TA_taBase);
    TA_KWTAVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_KWTAVals,TA_KWTAVals_MemberDef);
    tac_AddMethods(TA_KWTAVals,TA_KWTAVals_MethodDef);
  taMisc::types.Add(&TA_const_KWTAVals);
    TA_const_KWTAVals.AddParents(&TA_const, &TA_KWTAVals);
  taMisc::types.Add(&TA_const_KWTAVals_ref);
    TA_const_KWTAVals_ref.AddParents(&TA_const_KWTAVals);
  taMisc::types.Add(&TA_AdaptIVals);
    TAI_AdaptIVals = new AdaptIVals;
    TA_AdaptIVals.AddParFormal(&TA_class);
    TA_AdaptIVals.AddParCache(&TA_taBase);
    TA_AdaptIVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AdaptIVals,TA_AdaptIVals_MemberDef);
  taMisc::types.Add(&TA_const_AdaptIVals);
    TA_const_AdaptIVals.AddParents(&TA_const, &TA_AdaptIVals);
  taMisc::types.Add(&TA_const_AdaptIVals_ref);
    TA_const_AdaptIVals_ref.AddParents(&TA_const_AdaptIVals);
  taMisc::types.Add(&TA_InhibVals);
    TAI_InhibVals = new InhibVals;
    TA_InhibVals.AddParFormal(&TA_class);
    TA_InhibVals.AddParCache(&TA_taBase);
    TA_InhibVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_InhibVals,TA_InhibVals_MemberDef);
  taMisc::types.Add(&TA_const_InhibVals);
    TA_const_InhibVals.AddParents(&TA_const, &TA_InhibVals);
  taMisc::types.Add(&TA_const_InhibVals_ref);
    TA_const_InhibVals_ref.AddParents(&TA_const_InhibVals);
  taMisc::types.Add(&TA_LayerLink);
    TAI_LayerLink = new LayerLink;
    TA_LayerLink.AddParFormal(&TA_class);
    TA_LayerLink.AddParCache(&TA_taBase);
    TA_LayerLink.AddClassPar(&TA_taOBase,0);
    tac_AddMembers(TA_LayerLink,TA_LayerLink_MemberDef);
  taMisc::types.Add(&TA_taList_LayerLink_);
    TAI_taList_LayerLink_ = new taList<LayerLink>;
    TA_taList_LayerLink_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taList_LayerLink_.AddParCache(&TA_taBase);
    TA_taList_LayerLink_.AddClassPar(&TA_taList,0);
    sbt = new TypeDef("taBase_ptr", 1, 1, 0);
    sbt->AddParents(&TA_taBase);
    TA_taList_LayerLink_.sub_types.Add(sbt);
    sbt = new TypeDef("LayerLink_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LayerLink);
    TA_taList_LayerLink_.sub_types.Add(sbt);
    tac_AddMethods(TA_taList_LayerLink_,TA_taList_LayerLink__MethodDef);
  taMisc::types.Add(&TA_const_LayerLink);
    TA_const_LayerLink.AddParents(&TA_const, &TA_LayerLink);
  taMisc::types.Add(&TA_const_LayerLink_ref);
    TA_const_LayerLink_ref.AddParents(&TA_const_LayerLink);
  taMisc::types.Add(&TA_LayerLink_List);
    TAI_LayerLink_List = new LayerLink_List;
    TA_LayerLink_List.AddParFormal(&TA_class);
    TA_LayerLink_List.AddParCache(&TA_taBase);
    TA_LayerLink_List.AddClassPar(&TA_taList_LayerLink_,0);
  taMisc::types.Add(&TA_LeabraLayerSpec_ptr);
    TA_LeabraLayerSpec_ptr.AddParents(&TA_LeabraLayerSpec);
  taMisc::types.Add(&TA_const_LayerLink_List);
    TA_const_LayerLink_List.AddParents(&TA_const, &TA_LayerLink_List);
  taMisc::types.Add(&TA_const_LeabraInhib);
    TA_const_LeabraInhib.AddParents(&TA_const, &TA_LeabraInhib);
  taMisc::types.Add(&TA_const_LayerLink_List_ref);
    TA_const_LayerLink_List_ref.AddParents(&TA_const_LayerLink_List);
  taMisc::types.Add(&TA_const_LeabraInhib_ref);
    TA_const_LeabraInhib_ref.AddParents(&TA_const_LeabraInhib);
  taMisc::types.Add(&TA_const_LeabraLayer);
    TA_const_LeabraLayer.AddParents(&TA_const, &TA_LeabraLayer);
  taMisc::types.Add(&TA_const_LeabraLayer_ref);
    TA_const_LeabraLayer_ref.AddParents(&TA_const_LeabraLayer);
  taMisc::types.Add(&TA_const_LeabraUnit_Group);
    TA_const_LeabraUnit_Group.AddParents(&TA_const, &TA_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_LeabraUnit_Group_ref);
    TA_const_LeabraUnit_Group_ref.AddParents(&TA_const_LeabraUnit_Group);
  taMisc::types.Add(&TA_LeabraSettle_ptr);
    TA_LeabraSettle_ptr.AddParents(&TA_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraCycle);
    TA_const_LeabraCycle.AddParents(&TA_const, &TA_LeabraCycle);
  taMisc::types.Add(&TA_const_LeabraCycle_ref);
    TA_const_LeabraCycle_ref.AddParents(&TA_const_LeabraCycle);
  taMisc::types.Add(&TA_const_LeabraSettle);
    TA_const_LeabraSettle.AddParents(&TA_const, &TA_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraSettle_ref);
    TA_const_LeabraSettle_ref.AddParents(&TA_const_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraTrial);
    TA_const_LeabraTrial.AddParents(&TA_const, &TA_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraTrial_ref);
    TA_const_LeabraTrial_ref.AddParents(&TA_const_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraMaxDa);
    TA_const_LeabraMaxDa.AddParents(&TA_const, &TA_LeabraMaxDa);
  taMisc::types.Add(&TA_const_LeabraMaxDa_ref);
    TA_const_LeabraMaxDa_ref.AddParents(&TA_const_LeabraMaxDa);
  taMisc::types.Add(&TA_LeabraSE_Stat);
    TAI_LeabraSE_Stat = new LeabraSE_Stat;
    TA_LeabraSE_Stat.AddParFormal(&TA_class);
    TA_LeabraSE_Stat.AddParCache(&TA_taBase);
    TA_LeabraSE_Stat.AddClassPar(&TA_SE_Stat,0);
    tac_AddMembers(TA_LeabraSE_Stat,TA_LeabraSE_Stat_MemberDef);
    tac_AddMethods(TA_LeabraSE_Stat,TA_LeabraSE_Stat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraSE_Stat);
    TA_const_LeabraSE_Stat.AddParents(&TA_const, &TA_LeabraSE_Stat);
  taMisc::types.Add(&TA_LeabraAeSE_Stat);
    TAI_LeabraAeSE_Stat = new LeabraAeSE_Stat;
    TA_LeabraAeSE_Stat.AddParFormal(&TA_class);
    TA_LeabraAeSE_Stat.AddParCache(&TA_taBase);
    TA_LeabraAeSE_Stat.AddClassPar(&TA_LeabraSE_Stat,0);
  taMisc::types.Add(&TA_const_LeabraSE_Stat_ref);
    TA_const_LeabraSE_Stat_ref.AddParents(&TA_const_LeabraSE_Stat);
  taMisc::types.Add(&TA_const_LeabraAeSE_Stat);
    TA_const_LeabraAeSE_Stat.AddParents(&TA_const, &TA_LeabraAeSE_Stat);
  taMisc::types.Add(&TA_const_LeabraAeSE_Stat_ref);
    TA_const_LeabraAeSE_Stat_ref.AddParents(&TA_const_LeabraAeSE_Stat);
  taMisc::types.Add(&TA_LeabraGoodStat);
    TAI_LeabraGoodStat = new LeabraGoodStat;
    TA_LeabraGoodStat.AddParFormal(&TA_class);
    TA_LeabraGoodStat.AddParCache(&TA_taBase);
    TA_LeabraGoodStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraGoodStat,TA_LeabraGoodStat_MemberDef);
    tac_AddMethods(TA_LeabraGoodStat,TA_LeabraGoodStat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraGoodStat);
    TA_const_LeabraGoodStat.AddParents(&TA_const, &TA_LeabraGoodStat);
  taMisc::types.Add(&TA_const_LeabraGoodStat_ref);
    TA_const_LeabraGoodStat_ref.AddParents(&TA_const_LeabraGoodStat);
  taMisc::types.Add(&TA_LeabraSharpStat);
    TAI_LeabraSharpStat = new LeabraSharpStat;
    TA_LeabraSharpStat.AddParFormal(&TA_class);
    TA_LeabraSharpStat.AddParCache(&TA_taBase);
    TA_LeabraSharpStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraSharpStat,TA_LeabraSharpStat_MemberDef);
    tac_AddMethods(TA_LeabraSharpStat,TA_LeabraSharpStat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraSharpStat);
    TA_const_LeabraSharpStat.AddParents(&TA_const, &TA_LeabraSharpStat);
  taMisc::types.Add(&TA_const_LeabraSharpStat_ref);
    TA_const_LeabraSharpStat_ref.AddParents(&TA_const_LeabraSharpStat);
  taMisc::types.Add(&TA_WrongOnStat);
    TAI_WrongOnStat = new WrongOnStat;
    TA_WrongOnStat.AddParFormal(&TA_class);
    TA_WrongOnStat.AddParCache(&TA_taBase);
    TA_WrongOnStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_WrongOnStat,TA_WrongOnStat_MemberDef);
    tac_AddMethods(TA_WrongOnStat,TA_WrongOnStat_MethodDef);
  taMisc::types.Add(&TA_const_WrongOnStat);
    TA_const_WrongOnStat.AddParents(&TA_const, &TA_WrongOnStat);
  taMisc::types.Add(&TA_const_WrongOnStat_ref);
    TA_const_WrongOnStat_ref.AddParents(&TA_const_WrongOnStat);
  taMisc::types.Add(&TA_ACRewSpec);
    TAI_ACRewSpec = new ACRewSpec;
    TA_ACRewSpec.AddParFormal(&TA_class);
    TA_ACRewSpec.AddParCache(&TA_taBase);
    TA_ACRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ACRewSpec,TA_ACRewSpec_MemberDef);
  taMisc::types.Add(&TA_const_ACRewSpec);
    TA_const_ACRewSpec.AddParents(&TA_const, &TA_ACRewSpec);
  taMisc::types.Add(&TA_const_ACRewSpec_ref);
    TA_const_ACRewSpec_ref.AddParents(&TA_const_ACRewSpec);
  taMisc::types.Add(&TA_LeabraACLayerSpec);
    TAI_LeabraACLayerSpec = new LeabraACLayerSpec;
    TA_LeabraACLayerSpec.AddParFormal(&TA_class);
    TA_LeabraACLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraACLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_LeabraACLayerSpec, "TDModType", "", "", "", "", TA_LeabraACLayerSpec_TDModType);
    tac_AddMembers(TA_LeabraACLayerSpec,TA_LeabraACLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraACLayerSpec,TA_LeabraACLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraACLayerSpec);
    TA_const_LeabraACLayerSpec.AddParents(&TA_const, &TA_LeabraACLayerSpec);
  taMisc::types.Add(&TA_const_LeabraACLayerSpec_ref);
    TA_const_LeabraACLayerSpec_ref.AddParents(&TA_const_LeabraACLayerSpec);
  taMisc::types.Add(&TA_LeabraLinUnitSpec);
    TAI_LeabraLinUnitSpec = new LeabraLinUnitSpec;
    TA_LeabraLinUnitSpec.AddParFormal(&TA_class);
    TA_LeabraLinUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraLinUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
  taMisc::types.Add(&TA_const_LeabraLinUnitSpec);
    TA_const_LeabraLinUnitSpec.AddParents(&TA_const, &TA_LeabraLinUnitSpec);
  taMisc::types.Add(&TA_const_LeabraLinUnitSpec_ref);
    TA_const_LeabraLinUnitSpec_ref.AddParents(&TA_const_LeabraLinUnitSpec);
  taMisc::types.Add(&TA_CtxtUpdateSpec);
    TAI_CtxtUpdateSpec = new CtxtUpdateSpec;
    TA_CtxtUpdateSpec.AddParFormal(&TA_class);
    TA_CtxtUpdateSpec.AddParCache(&TA_taBase);
    TA_CtxtUpdateSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_CtxtUpdateSpec,TA_CtxtUpdateSpec_MemberDef);
  taMisc::types.Add(&TA_const_CtxtUpdateSpec);
    TA_const_CtxtUpdateSpec.AddParents(&TA_const, &TA_CtxtUpdateSpec);
  taMisc::types.Add(&TA_const_CtxtUpdateSpec_ref);
    TA_const_CtxtUpdateSpec_ref.AddParents(&TA_const_CtxtUpdateSpec);
  taMisc::types.Add(&TA_LeabraContextLayerSpec);
    TAI_LeabraContextLayerSpec = new LeabraContextLayerSpec;
    TA_LeabraContextLayerSpec.AddParFormal(&TA_class);
    TA_LeabraContextLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraContextLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_LeabraContextLayerSpec,TA_LeabraContextLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraContextLayerSpec,TA_LeabraContextLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraContextLayerSpec);
    TA_const_LeabraContextLayerSpec.AddParents(&TA_const, &TA_LeabraContextLayerSpec);
  taMisc::types.Add(&TA_const_LeabraContextLayerSpec_ref);
    TA_const_LeabraContextLayerSpec_ref.AddParents(&TA_const_LeabraContextLayerSpec);
  taMisc::types.Add(&TA_GateSpec);
    TAI_GateSpec = new GateSpec;
    TA_GateSpec.AddParFormal(&TA_class);
    TA_GateSpec.AddParCache(&TA_taBase);
    TA_GateSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_GateSpec, "MaintMode", "", "", "", "", TA_GateSpec_MaintMode);
    tac_AddEnum(TA_GateSpec, "OutMod", "", "", "", "", TA_GateSpec_OutMod);
    tac_AddMembers(TA_GateSpec,TA_GateSpec_MemberDef);
  taMisc::types.Add(&TA_const_GateSpec);
    TA_const_GateSpec.AddParents(&TA_const, &TA_GateSpec);
  taMisc::types.Add(&TA_const_GateSpec_ref);
    TA_const_GateSpec_ref.AddParents(&TA_const_GateSpec);
  taMisc::types.Add(&TA_GateNoiseSpec);
    TAI_GateNoiseSpec = new GateNoiseSpec;
    TA_GateNoiseSpec.AddParFormal(&TA_class);
    TA_GateNoiseSpec.AddParCache(&TA_taBase);
    TA_GateNoiseSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_GateNoiseSpec,TA_GateNoiseSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraConSpec_ptr);
    TA_LeabraConSpec_ptr.AddParents(&TA_LeabraConSpec);
  taMisc::types.Add(&TA_const_GateNoiseSpec);
    TA_const_GateNoiseSpec.AddParents(&TA_const, &TA_GateNoiseSpec);
  taMisc::types.Add(&TA_const_GateNoiseSpec_ref);
    TA_const_GateNoiseSpec_ref.AddParents(&TA_const_GateNoiseSpec);
  taMisc::types.Add(&TA_LeabraGatedCtxLayerSpec);
    TAI_LeabraGatedCtxLayerSpec = new LeabraGatedCtxLayerSpec;
    TA_LeabraGatedCtxLayerSpec.AddParFormal(&TA_class);
    TA_LeabraGatedCtxLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraGatedCtxLayerSpec.AddClassPar(&TA_LeabraContextLayerSpec,0);
    tac_AddMembers(TA_LeabraGatedCtxLayerSpec,TA_LeabraGatedCtxLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraGatedCtxLayerSpec,TA_LeabraGatedCtxLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraGatedCtxLayerSpec);
    TA_const_LeabraGatedCtxLayerSpec.AddParents(&TA_const, &TA_LeabraGatedCtxLayerSpec);
  taMisc::types.Add(&TA_const_LeabraGatedCtxLayerSpec_ref);
    TA_const_LeabraGatedCtxLayerSpec_ref.AddParents(&TA_const_LeabraGatedCtxLayerSpec);
  taMisc::types.Add(&TA_LeabraACMaintLayerSpec);
    TAI_LeabraACMaintLayerSpec = new LeabraACMaintLayerSpec;
    TA_LeabraACMaintLayerSpec.AddParFormal(&TA_class);
    TA_LeabraACMaintLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraACMaintLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_LeabraACMaintLayerSpec,TA_LeabraACMaintLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraACMaintLayerSpec,TA_LeabraACMaintLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraACMaintLayerSpec);
    TA_const_LeabraACMaintLayerSpec.AddParents(&TA_const, &TA_LeabraACMaintLayerSpec);
  taMisc::types.Add(&TA_const_LeabraACMaintLayerSpec_ref);
    TA_const_LeabraACMaintLayerSpec_ref.AddParents(&TA_const_LeabraACMaintLayerSpec);
  taMisc::types.Add(&TA_PhaseOrderEventSpec);
    TAI_PhaseOrderEventSpec = new PhaseOrderEventSpec;
    TA_PhaseOrderEventSpec.AddParFormal(&TA_class);
    TA_PhaseOrderEventSpec.AddParCache(&TA_taBase);
    TA_PhaseOrderEventSpec.AddClassPar(&TA_EventSpec,0);
    tac_AddEnum(TA_PhaseOrderEventSpec, "PhaseOrder", "", "", "", "", TA_PhaseOrderEventSpec_PhaseOrder);
    tac_AddMembers(TA_PhaseOrderEventSpec,TA_PhaseOrderEventSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraTimeUnit);
    TAI_LeabraTimeUnit = new LeabraTimeUnit;
    TA_LeabraTimeUnit.AddParFormal(&TA_class);
    TA_LeabraTimeUnit.AddParCache(&TA_taBase);
    TA_LeabraTimeUnit.AddClassPar(&TA_LeabraUnit,0);
    tac_AddMembers(TA_LeabraTimeUnit,TA_LeabraTimeUnit_MemberDef);
  taMisc::types.Add(&TA_const_PhaseOrderEventSpec);
    TA_const_PhaseOrderEventSpec.AddParents(&TA_const, &TA_PhaseOrderEventSpec);
  taMisc::types.Add(&TA_LeabraTimeUnitSpec);
    TAI_LeabraTimeUnitSpec = new LeabraTimeUnitSpec;
    TA_LeabraTimeUnitSpec.AddParFormal(&TA_class);
    TA_LeabraTimeUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraTimeUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
    tac_AddMethods(TA_LeabraTimeUnitSpec,TA_LeabraTimeUnitSpec_MethodDef);
  taMisc::types.Add(&TA_const_PhaseOrderEventSpec_ref);
    TA_const_PhaseOrderEventSpec_ref.AddParents(&TA_const_PhaseOrderEventSpec);
  taMisc::types.Add(&TA_LeabraTimeCon_Group);
    TAI_LeabraTimeCon_Group = new LeabraTimeCon_Group;
    TA_LeabraTimeCon_Group.AddParFormal(&TA_class);
    TA_LeabraTimeCon_Group.AddParCache(&TA_taBase);
    TA_LeabraTimeCon_Group.AddClassPar(&TA_LeabraCon_Group,0);
  taMisc::types.Add(&TA_const_LeabraTimeUnit);
    TA_const_LeabraTimeUnit.AddParents(&TA_const, &TA_LeabraTimeUnit);
  taMisc::types.Add(&TA_const_LeabraTimeCon_Group);
    TA_const_LeabraTimeCon_Group.AddParents(&TA_const, &TA_LeabraTimeCon_Group);
  taMisc::types.Add(&TA_const_LeabraTimeUnit_ref);
    TA_const_LeabraTimeUnit_ref.AddParents(&TA_const_LeabraTimeUnit);
  taMisc::types.Add(&TA_const_LeabraTimeCon_Group_ref);
    TA_const_LeabraTimeCon_Group_ref.AddParents(&TA_const_LeabraTimeCon_Group);
  taMisc::types.Add(&TA_const_LeabraTimeUnitSpec);
    TA_const_LeabraTimeUnitSpec.AddParents(&TA_const, &TA_LeabraTimeUnitSpec);
  taMisc::types.Add(&TA_const_LeabraTimeUnitSpec_ref);
    TA_const_LeabraTimeUnitSpec_ref.AddParents(&TA_const_LeabraTimeUnitSpec);
  taMisc::types.Add(&TA_TimeMixSpec);
    TAI_TimeMixSpec = new TimeMixSpec;
    TA_TimeMixSpec.AddParFormal(&TA_class);
    TA_TimeMixSpec.AddParCache(&TA_taBase);
    TA_TimeMixSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_TimeMixSpec,TA_TimeMixSpec_MemberDef);
  taMisc::types.Add(&TA_const_TimeMixSpec);
    TA_const_TimeMixSpec.AddParents(&TA_const, &TA_TimeMixSpec);
  taMisc::types.Add(&TA_LeabraTimeConSpec);
    TAI_LeabraTimeConSpec = new LeabraTimeConSpec;
    TA_LeabraTimeConSpec.AddParFormal(&TA_class);
    TA_LeabraTimeConSpec.AddParCache(&TA_taBase);
    TA_LeabraTimeConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_LeabraTimeConSpec,TA_LeabraTimeConSpec_MemberDef);
    tac_AddMethods(TA_LeabraTimeConSpec,TA_LeabraTimeConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TimeMixSpec_ref);
    TA_const_TimeMixSpec_ref.AddParents(&TA_const_TimeMixSpec);
  taMisc::types.Add(&TA_const_LeabraTimeConSpec);
    TA_const_LeabraTimeConSpec.AddParents(&TA_const, &TA_LeabraTimeConSpec);
  taMisc::types.Add(&TA_const_LeabraTimeConSpec_ref);
    TA_const_LeabraTimeConSpec_ref.AddParents(&TA_const_LeabraTimeConSpec);
  taMisc::types.Add(&TA_LeabraNegBiasSpec);
    TAI_LeabraNegBiasSpec = new LeabraNegBiasSpec;
    TA_LeabraNegBiasSpec.AddParFormal(&TA_class);
    TA_LeabraNegBiasSpec.AddParCache(&TA_taBase);
    TA_LeabraNegBiasSpec.AddClassPar(&TA_LeabraBiasSpec,0);
    tac_AddMembers(TA_LeabraNegBiasSpec,TA_LeabraNegBiasSpec_MemberDef);
  taMisc::types.Add(&TA_const_LeabraNegBiasSpec);
    TA_const_LeabraNegBiasSpec.AddParents(&TA_const, &TA_LeabraNegBiasSpec);
  taMisc::types.Add(&TA_const_LeabraNegBiasSpec_ref);
    TA_const_LeabraNegBiasSpec_ref.AddParents(&TA_const_LeabraNegBiasSpec);
  taMisc::types.Add(&TA_LeabraMaintConSpec);
    TAI_LeabraMaintConSpec = new LeabraMaintConSpec;
    TA_LeabraMaintConSpec.AddParFormal(&TA_class);
    TA_LeabraMaintConSpec.AddParCache(&TA_taBase);
    TA_LeabraMaintConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_LeabraMaintConSpec,TA_LeabraMaintConSpec_MemberDef);
    tac_AddMethods(TA_LeabraMaintConSpec,TA_LeabraMaintConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraMaintConSpec);
    TA_const_LeabraMaintConSpec.AddParents(&TA_const, &TA_LeabraMaintConSpec);
  taMisc::types.Add(&TA_const_LeabraMaintConSpec_ref);
    TA_const_LeabraMaintConSpec_ref.AddParents(&TA_const_LeabraMaintConSpec);
  taMisc::types.Add(&TA_LeabraNetConSpec);
    TAI_LeabraNetConSpec = new LeabraNetConSpec;
    TA_LeabraNetConSpec.AddParFormal(&TA_class);
    TA_LeabraNetConSpec.AddParCache(&TA_taBase);
    TA_LeabraNetConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_LeabraNetConSpec,TA_LeabraNetConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraNetConSpec);
    TA_const_LeabraNetConSpec.AddParents(&TA_const, &TA_LeabraNetConSpec);
  taMisc::types.Add(&TA_const_LeabraNetConSpec_ref);
    TA_const_LeabraNetConSpec_ref.AddParents(&TA_const_LeabraNetConSpec);
  taMisc::types.Add(&TA_PhaseDWtConSpec);
    TAI_PhaseDWtConSpec = new PhaseDWtConSpec;
    TA_PhaseDWtConSpec.AddParFormal(&TA_class);
    TA_PhaseDWtConSpec.AddParCache(&TA_taBase);
    TA_PhaseDWtConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddEnum(TA_PhaseDWtConSpec, "dWtPhase", "", "", "", "", TA_PhaseDWtConSpec_dWtPhase);
    tac_AddMembers(TA_PhaseDWtConSpec,TA_PhaseDWtConSpec_MemberDef);
  taMisc::types.Add(&TA_const_PhaseDWtConSpec);
    TA_const_PhaseDWtConSpec.AddParents(&TA_const, &TA_PhaseDWtConSpec);
  taMisc::types.Add(&TA_const_PhaseDWtConSpec_ref);
    TA_const_PhaseDWtConSpec_ref.AddParents(&TA_const_PhaseDWtConSpec);
  taMisc::types.Add(&TA_PhaseDWtUnitSpec);
    TAI_PhaseDWtUnitSpec = new PhaseDWtUnitSpec;
    TA_PhaseDWtUnitSpec.AddParFormal(&TA_class);
    TA_PhaseDWtUnitSpec.AddParCache(&TA_taBase);
    TA_PhaseDWtUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
    tac_AddEnum(TA_PhaseDWtUnitSpec, "dWtPhase", "", "", "", "", TA_PhaseDWtUnitSpec_dWtPhase);
    tac_AddMembers(TA_PhaseDWtUnitSpec,TA_PhaseDWtUnitSpec_MemberDef);
  taMisc::types.Add(&TA_const_PhaseDWtUnitSpec);
    TA_const_PhaseDWtUnitSpec.AddParents(&TA_const, &TA_PhaseDWtUnitSpec);
  taMisc::types.Add(&TA_const_PhaseDWtUnitSpec_ref);
    TA_const_PhaseDWtUnitSpec_ref.AddParents(&TA_const_PhaseDWtUnitSpec);
  taMisc::types.Add(&TA_LeabraTabledConSpec);
    TAI_LeabraTabledConSpec = new LeabraTabledConSpec;
    TA_LeabraTabledConSpec.AddParFormal(&TA_class);
    TA_LeabraTabledConSpec.AddParCache(&TA_taBase);
    TA_LeabraTabledConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddEnum(TA_LeabraTabledConSpec, "TableType", "", "", "", "", TA_LeabraTabledConSpec_TableType);
    tac_AddEnum(TA_LeabraTabledConSpec, "Squashing", "", "", "", "", TA_LeabraTabledConSpec_Squashing);
    tac_AddMembers(TA_LeabraTabledConSpec,TA_LeabraTabledConSpec_MemberDef);
    tac_AddMethods(TA_LeabraTabledConSpec,TA_LeabraTabledConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraTabledConSpec);
    TA_const_LeabraTabledConSpec.AddParents(&TA_const, &TA_LeabraTabledConSpec);
  taMisc::types.Add(&TA_TrialSynDepCon);
    TAI_TrialSynDepCon = new TrialSynDepCon;
    TA_TrialSynDepCon.AddParFormal(&TA_class);
    TA_TrialSynDepCon.AddParCache(&TA_taBase);
    TA_TrialSynDepCon.AddClassPar(&TA_LeabraCon,0);
    tac_AddMembers(TA_TrialSynDepCon,TA_TrialSynDepCon_MemberDef);
  taMisc::types.Add(&TA_const_LeabraTabledConSpec_ref);
    TA_const_LeabraTabledConSpec_ref.AddParents(&TA_const_LeabraTabledConSpec);
  taMisc::types.Add(&TA_const_TrialSynDepCon);
    TA_const_TrialSynDepCon.AddParents(&TA_const, &TA_TrialSynDepCon);
  taMisc::types.Add(&TA_const_TrialSynDepCon_ref);
    TA_const_TrialSynDepCon_ref.AddParents(&TA_const_TrialSynDepCon);
  taMisc::types.Add(&TA_SynDepSpec);
    TAI_SynDepSpec = new SynDepSpec;
    TA_SynDepSpec.AddParFormal(&TA_class);
    TA_SynDepSpec.AddParCache(&TA_taBase);
    TA_SynDepSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SynDepSpec,TA_SynDepSpec_MemberDef);
  taMisc::types.Add(&TA_TrialSynDepCon_ptr);
    TA_TrialSynDepCon_ptr.AddParents(&TA_TrialSynDepCon);
  taMisc::types.Add(&TA_const_SynDepSpec);
    TA_const_SynDepSpec.AddParents(&TA_const, &TA_SynDepSpec);
  taMisc::types.Add(&TA_const_SynDepSpec_ref);
    TA_const_SynDepSpec_ref.AddParents(&TA_const_SynDepSpec);
  taMisc::types.Add(&TA_TrialSynDepConSpec);
    TAI_TrialSynDepConSpec = new TrialSynDepConSpec;
    TA_TrialSynDepConSpec.AddParFormal(&TA_class);
    TA_TrialSynDepConSpec.AddParCache(&TA_taBase);
    TA_TrialSynDepConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_TrialSynDepConSpec,TA_TrialSynDepConSpec_MemberDef);
    tac_AddMethods(TA_TrialSynDepConSpec,TA_TrialSynDepConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TrialSynDepConSpec);
    TA_const_TrialSynDepConSpec.AddParents(&TA_const, &TA_TrialSynDepConSpec);
  taMisc::types.Add(&TA_const_TrialSynDepConSpec_ref);
    TA_const_TrialSynDepConSpec_ref.AddParents(&TA_const_TrialSynDepConSpec);
  taMisc::types.Add(&TA_FastWtCon);
    TAI_FastWtCon = new FastWtCon;
    TA_FastWtCon.AddParFormal(&TA_class);
    TA_FastWtCon.AddParCache(&TA_taBase);
    TA_FastWtCon.AddClassPar(&TA_LeabraCon,0);
    tac_AddMembers(TA_FastWtCon,TA_FastWtCon_MemberDef);
  taMisc::types.Add(&TA_const_FastWtCon);
    TA_const_FastWtCon.AddParents(&TA_const, &TA_FastWtCon);
  taMisc::types.Add(&TA_const_FastWtCon_ref);
    TA_const_FastWtCon_ref.AddParents(&TA_const_FastWtCon);
  taMisc::types.Add(&TA_FastWtSpec);
    TAI_FastWtSpec = new FastWtSpec;
    TA_FastWtSpec.AddParFormal(&TA_class);
    TA_FastWtSpec.AddParCache(&TA_taBase);
    TA_FastWtSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_FastWtSpec, "DecayMode", "", "", "", "", TA_FastWtSpec_DecayMode);
    tac_AddMembers(TA_FastWtSpec,TA_FastWtSpec_MemberDef);
  taMisc::types.Add(&TA_FastWtCon_ptr);
    TA_FastWtCon_ptr.AddParents(&TA_FastWtCon);
  taMisc::types.Add(&TA_const_FastWtSpec);
    TA_const_FastWtSpec.AddParents(&TA_const, &TA_FastWtSpec);
  taMisc::types.Add(&TA_const_FastWtSpec_ref);
    TA_const_FastWtSpec_ref.AddParents(&TA_const_FastWtSpec);
  taMisc::types.Add(&TA_FastWtConSpec);
    TAI_FastWtConSpec = new FastWtConSpec;
    TA_FastWtConSpec.AddParFormal(&TA_class);
    TA_FastWtConSpec.AddParCache(&TA_taBase);
    TA_FastWtConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_FastWtConSpec,TA_FastWtConSpec_MemberDef);
    tac_AddMethods(TA_FastWtConSpec,TA_FastWtConSpec_MethodDef);
  taMisc::types.Add(&TA_const_FastWtConSpec);
    TA_const_FastWtConSpec.AddParents(&TA_const, &TA_FastWtConSpec);
  taMisc::types.Add(&TA_const_FastWtConSpec_ref);
    TA_const_FastWtConSpec_ref.AddParents(&TA_const_FastWtConSpec);
  taMisc::types.Add(&TA_LeabraNewHebbConSpec);
    TAI_LeabraNewHebbConSpec = new LeabraNewHebbConSpec;
    TA_LeabraNewHebbConSpec.AddParFormal(&TA_class);
    TA_LeabraNewHebbConSpec.AddParCache(&TA_taBase);
    TA_LeabraNewHebbConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddEnum(TA_LeabraNewHebbConSpec, "HebbFun", "", "", "", "", TA_LeabraNewHebbConSpec_HebbFun);
    tac_AddMembers(TA_LeabraNewHebbConSpec,TA_LeabraNewHebbConSpec_MemberDef);
    tac_AddMethods(TA_LeabraNewHebbConSpec,TA_LeabraNewHebbConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraNewHebbConSpec);
    TA_const_LeabraNewHebbConSpec.AddParents(&TA_const, &TA_LeabraNewHebbConSpec);
  taMisc::types.Add(&TA_const_LeabraNewHebbConSpec_ref);
    TA_const_LeabraNewHebbConSpec_ref.AddParents(&TA_const_LeabraNewHebbConSpec);
  taMisc::types.Add(&TA_SigAmpSpec);
    TAI_SigAmpSpec = new SigAmpSpec;
    TA_SigAmpSpec.AddParFormal(&TA_class);
    TA_SigAmpSpec.AddParCache(&TA_taBase);
    TA_SigAmpSpec.AddClassPar(&TA_SigmoidSpec,0);
    tac_AddMembers(TA_SigAmpSpec,TA_SigAmpSpec_MemberDef);
    tac_AddMethods(TA_SigAmpSpec,TA_SigAmpSpec_MethodDef);
  taMisc::types.Add(&TA_const_SigAmpSpec);
    TA_const_SigAmpSpec.AddParents(&TA_const, &TA_SigAmpSpec);
  taMisc::types.Add(&TA_const_SigAmpSpec_ref);
    TA_const_SigAmpSpec_ref.AddParents(&TA_const_SigAmpSpec);
  taMisc::types.Add(&TA_LeabraSigHebbConSpec);
    TAI_LeabraSigHebbConSpec = new LeabraSigHebbConSpec;
    TA_LeabraSigHebbConSpec.AddParFormal(&TA_class);
    TA_LeabraSigHebbConSpec.AddParCache(&TA_taBase);
    TA_LeabraSigHebbConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_LeabraSigHebbConSpec,TA_LeabraSigHebbConSpec_MemberDef);
    tac_AddMethods(TA_LeabraSigHebbConSpec,TA_LeabraSigHebbConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraSigHebbConSpec);
    TA_const_LeabraSigHebbConSpec.AddParents(&TA_const, &TA_LeabraSigHebbConSpec);
  taMisc::types.Add(&TA_const_LeabraSigHebbConSpec_ref);
    TA_const_LeabraSigHebbConSpec_ref.AddParents(&TA_const_LeabraSigHebbConSpec);
  taMisc::types.Add(&TA_ScalarValSpec);
    TAI_ScalarValSpec = new ScalarValSpec;
    TA_ScalarValSpec.AddParFormal(&TA_class);
    TA_ScalarValSpec.AddParCache(&TA_taBase);
    TA_ScalarValSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ScalarValSpec, "RepType", "", "", "", "", TA_ScalarValSpec_RepType);
    tac_AddMembers(TA_ScalarValSpec,TA_ScalarValSpec_MemberDef);
    tac_AddMethods(TA_ScalarValSpec,TA_ScalarValSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValSpec);
    TA_const_ScalarValSpec.AddParents(&TA_const, &TA_ScalarValSpec);
  taMisc::types.Add(&TA_const_ScalarValSpec_ref);
    TA_const_ScalarValSpec_ref.AddParents(&TA_const_ScalarValSpec);
  taMisc::types.Add(&TA_ScalarValBias);
    TAI_ScalarValBias = new ScalarValBias;
    TA_ScalarValBias.AddParFormal(&TA_class);
    TA_ScalarValBias.AddParCache(&TA_taBase);
    TA_ScalarValBias.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ScalarValBias, "UnitBias", " bias on individual units", "", "", "", TA_ScalarValBias_UnitBias);
    tac_AddEnum(TA_ScalarValBias, "BiasShape", " shape of the bias pattern", "", "", "", TA_ScalarValBias_BiasShape);
    tac_AddEnum(TA_ScalarValBias, "WeightBias", " bias on weights into units", "", "", "", TA_ScalarValBias_WeightBias);
    tac_AddMembers(TA_ScalarValBias,TA_ScalarValBias_MemberDef);
  taMisc::types.Add(&TA_const_ScalarValBias);
    TA_const_ScalarValBias.AddParents(&TA_const, &TA_ScalarValBias);
  taMisc::types.Add(&TA_const_ScalarValBias_ref);
    TA_const_ScalarValBias_ref.AddParents(&TA_const_ScalarValBias);
  taMisc::types.Add(&TA_ScalarValLayerSpec);
    TAI_ScalarValLayerSpec = new ScalarValLayerSpec;
    TA_ScalarValLayerSpec.AddParFormal(&TA_class);
    TA_ScalarValLayerSpec.AddParCache(&TA_taBase);
    TA_ScalarValLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_ScalarValLayerSpec,TA_ScalarValLayerSpec_MemberDef);
    tac_AddMethods(TA_ScalarValLayerSpec,TA_ScalarValLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValLayerSpec);
    TA_const_ScalarValLayerSpec.AddParents(&TA_const, &TA_ScalarValLayerSpec);
  taMisc::types.Add(&TA_const_ScalarValLayerSpec_ref);
    TA_const_ScalarValLayerSpec_ref.AddParents(&TA_const_ScalarValLayerSpec);
  taMisc::types.Add(&TA_ScalarValSelfPrjnSpec);
    TAI_ScalarValSelfPrjnSpec = new ScalarValSelfPrjnSpec;
    TA_ScalarValSelfPrjnSpec.AddParFormal(&TA_class);
    TA_ScalarValSelfPrjnSpec.AddParCache(&TA_taBase);
    TA_ScalarValSelfPrjnSpec.AddClassPar(&TA_ProjectionSpec,0);
    tac_AddMembers(TA_ScalarValSelfPrjnSpec,TA_ScalarValSelfPrjnSpec_MemberDef);
    tac_AddMethods(TA_ScalarValSelfPrjnSpec,TA_ScalarValSelfPrjnSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValSelfPrjnSpec);
    TA_const_ScalarValSelfPrjnSpec.AddParents(&TA_const, &TA_ScalarValSelfPrjnSpec);
  taMisc::types.Add(&TA_const_ScalarValSelfPrjnSpec_ref);
    TA_const_ScalarValSelfPrjnSpec_ref.AddParents(&TA_const_ScalarValSelfPrjnSpec);
  taMisc::types.Add(&TA_MarkerConSpec);
    TAI_MarkerConSpec = new MarkerConSpec;
    TA_MarkerConSpec.AddParFormal(&TA_class);
    TA_MarkerConSpec.AddParCache(&TA_taBase);
    TA_MarkerConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_MarkerConSpec,TA_MarkerConSpec_MethodDef);
  taMisc::types.Add(&TA_const_MarkerConSpec);
    TA_const_MarkerConSpec.AddParents(&TA_const, &TA_MarkerConSpec);
  taMisc::types.Add(&TA_const_MarkerConSpec_ref);
    TA_const_MarkerConSpec_ref.AddParents(&TA_const_MarkerConSpec);
  taMisc::types.Add(&TA_DaModUnit);
    TAI_DaModUnit = new DaModUnit;
    TA_DaModUnit.AddParFormal(&TA_class);
    TA_DaModUnit.AddParCache(&TA_taBase);
    TA_DaModUnit.AddClassPar(&TA_LeabraUnit,0);
    tac_AddMembers(TA_DaModUnit,TA_DaModUnit_MemberDef);
  taMisc::types.Add(&TA_const_DaModUnit);
    TA_const_DaModUnit.AddParents(&TA_const, &TA_DaModUnit);
  taMisc::types.Add(&TA_const_DaModUnit_ref);
    TA_const_DaModUnit_ref.AddParents(&TA_const_DaModUnit);
  taMisc::types.Add(&TA_DaModSpec);
    TAI_DaModSpec = new DaModSpec;
    TA_DaModSpec.AddParFormal(&TA_class);
    TA_DaModSpec.AddParCache(&TA_taBase);
    TA_DaModSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DaModSpec,TA_DaModSpec_MemberDef);
  taMisc::types.Add(&TA_const_DaModSpec);
    TA_const_DaModSpec.AddParents(&TA_const, &TA_DaModSpec);
  taMisc::types.Add(&TA_const_DaModSpec_ref);
    TA_const_DaModSpec_ref.AddParents(&TA_const_DaModSpec);
  taMisc::types.Add(&TA_DaModUnitSpec);
    TAI_DaModUnitSpec = new DaModUnitSpec;
    TA_DaModUnitSpec.AddParFormal(&TA_class);
    TA_DaModUnitSpec.AddParCache(&TA_taBase);
    TA_DaModUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
    tac_AddMembers(TA_DaModUnitSpec,TA_DaModUnitSpec_MemberDef);
    tac_AddMethods(TA_DaModUnitSpec,TA_DaModUnitSpec_MethodDef);
  taMisc::types.Add(&TA_const_DaModUnitSpec);
    TA_const_DaModUnitSpec.AddParents(&TA_const, &TA_DaModUnitSpec);
  taMisc::types.Add(&TA_const_DaModUnitSpec_ref);
    TA_const_DaModUnitSpec_ref.AddParents(&TA_const_DaModUnitSpec);
  taMisc::types.Add(&TA_AvgExtRewSpec);
    TAI_AvgExtRewSpec = new AvgExtRewSpec;
    TA_AvgExtRewSpec.AddParFormal(&TA_class);
    TA_AvgExtRewSpec.AddParCache(&TA_taBase);
    TA_AvgExtRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AvgExtRewSpec,TA_AvgExtRewSpec_MemberDef);
  taMisc::types.Add(&TA_const_AvgExtRewSpec);
    TA_const_AvgExtRewSpec.AddParents(&TA_const, &TA_AvgExtRewSpec);
  taMisc::types.Add(&TA_const_AvgExtRewSpec_ref);
    TA_const_AvgExtRewSpec_ref.AddParents(&TA_const_AvgExtRewSpec);
  taMisc::types.Add(&TA_OutErrSpec);
    TAI_OutErrSpec = new OutErrSpec;
    TA_OutErrSpec.AddParFormal(&TA_class);
    TA_OutErrSpec.AddParCache(&TA_taBase);
    TA_OutErrSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_OutErrSpec,TA_OutErrSpec_MemberDef);
  taMisc::types.Add(&TA_const_OutErrSpec);
    TA_const_OutErrSpec.AddParents(&TA_const, &TA_OutErrSpec);
  taMisc::types.Add(&TA_const_OutErrSpec_ref);
    TA_const_OutErrSpec_ref.AddParents(&TA_const_OutErrSpec);
  taMisc::types.Add(&TA_ExtRewSpec);
    TAI_ExtRewSpec = new ExtRewSpec;
    TA_ExtRewSpec.AddParFormal(&TA_class);
    TA_ExtRewSpec.AddParCache(&TA_taBase);
    TA_ExtRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ExtRewSpec,TA_ExtRewSpec_MemberDef);
  taMisc::types.Add(&TA_DaModUnit_ptr);
    TA_DaModUnit_ptr.AddParents(&TA_DaModUnit);
  taMisc::types.Add(&TA_const_ExtRewSpec);
    TA_const_ExtRewSpec.AddParents(&TA_const, &TA_ExtRewSpec);
  taMisc::types.Add(&TA_const_ExtRewSpec_ref);
    TA_const_ExtRewSpec_ref.AddParents(&TA_const_ExtRewSpec);
  taMisc::types.Add(&TA_ExtRewLayerSpec);
    TAI_ExtRewLayerSpec = new ExtRewLayerSpec;
    TA_ExtRewLayerSpec.AddParFormal(&TA_class);
    TA_ExtRewLayerSpec.AddParCache(&TA_taBase);
    TA_ExtRewLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddEnum(TA_ExtRewLayerSpec, "RewardType", " how do we get the reward values?", "", "", "", TA_ExtRewLayerSpec_RewardType);
    tac_AddMembers(TA_ExtRewLayerSpec,TA_ExtRewLayerSpec_MemberDef);
    tac_AddMethods(TA_ExtRewLayerSpec,TA_ExtRewLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_ExtRewLayerSpec);
    TA_const_ExtRewLayerSpec.AddParents(&TA_const, &TA_ExtRewLayerSpec);
  taMisc::types.Add(&TA_const_ExtRewLayerSpec_ref);
    TA_const_ExtRewLayerSpec_ref.AddParents(&TA_const_ExtRewLayerSpec);
  taMisc::types.Add(&TA_ExtRew_Stat);
    TAI_ExtRew_Stat = new ExtRew_Stat;
    TA_ExtRew_Stat.AddParFormal(&TA_class);
    TA_ExtRew_Stat.AddParCache(&TA_taBase);
    TA_ExtRew_Stat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_ExtRew_Stat,TA_ExtRew_Stat_MemberDef);
    tac_AddMethods(TA_ExtRew_Stat,TA_ExtRew_Stat_MethodDef);
  taMisc::types.Add(&TA_const_ExtRew_Stat);
    TA_const_ExtRew_Stat.AddParents(&TA_const, &TA_ExtRew_Stat);
  taMisc::types.Add(&TA_const_ExtRew_Stat_ref);
    TA_const_ExtRew_Stat_ref.AddParents(&TA_const_ExtRew_Stat);
  taMisc::types.Add(&TA_TDRewPredConSpec);
    TAI_TDRewPredConSpec = new TDRewPredConSpec;
    TA_TDRewPredConSpec.AddParFormal(&TA_class);
    TA_TDRewPredConSpec.AddParCache(&TA_taBase);
    TA_TDRewPredConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_TDRewPredConSpec,TA_TDRewPredConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewPredConSpec);
    TA_const_TDRewPredConSpec.AddParents(&TA_const, &TA_TDRewPredConSpec);
  taMisc::types.Add(&TA_const_TDRewPredConSpec_ref);
    TA_const_TDRewPredConSpec_ref.AddParents(&TA_const_TDRewPredConSpec);
  taMisc::types.Add(&TA_TDRewPredLayerSpec);
    TAI_TDRewPredLayerSpec = new TDRewPredLayerSpec;
    TA_TDRewPredLayerSpec.AddParFormal(&TA_class);
    TA_TDRewPredLayerSpec.AddParCache(&TA_taBase);
    TA_TDRewPredLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMethods(TA_TDRewPredLayerSpec,TA_TDRewPredLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewPredLayerSpec);
    TA_const_TDRewPredLayerSpec.AddParents(&TA_const, &TA_TDRewPredLayerSpec);
  taMisc::types.Add(&TA_const_TDRewPredLayerSpec_ref);
    TA_const_TDRewPredLayerSpec_ref.AddParents(&TA_const_TDRewPredLayerSpec);
  taMisc::types.Add(&TA_TDRewIntegSpec);
    TAI_TDRewIntegSpec = new TDRewIntegSpec;
    TA_TDRewIntegSpec.AddParFormal(&TA_class);
    TA_TDRewIntegSpec.AddParCache(&TA_taBase);
    TA_TDRewIntegSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_TDRewIntegSpec,TA_TDRewIntegSpec_MemberDef);
  taMisc::types.Add(&TA_const_TDRewIntegSpec);
    TA_const_TDRewIntegSpec.AddParents(&TA_const, &TA_TDRewIntegSpec);
  taMisc::types.Add(&TA_const_TDRewIntegSpec_ref);
    TA_const_TDRewIntegSpec_ref.AddParents(&TA_const_TDRewIntegSpec);
  taMisc::types.Add(&TA_TDRewIntegLayerSpec);
    TAI_TDRewIntegLayerSpec = new TDRewIntegLayerSpec;
    TA_TDRewIntegLayerSpec.AddParFormal(&TA_class);
    TA_TDRewIntegLayerSpec.AddParCache(&TA_taBase);
    TA_TDRewIntegLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_TDRewIntegLayerSpec,TA_TDRewIntegLayerSpec_MemberDef);
    tac_AddMethods(TA_TDRewIntegLayerSpec,TA_TDRewIntegLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewIntegLayerSpec);
    TA_const_TDRewIntegLayerSpec.AddParents(&TA_const, &TA_TDRewIntegLayerSpec);
  taMisc::types.Add(&TA_const_TDRewIntegLayerSpec_ref);
    TA_const_TDRewIntegLayerSpec_ref.AddParents(&TA_const_TDRewIntegLayerSpec);
  taMisc::types.Add(&TA_TdLayerSpec);
    TAI_TdLayerSpec = new TdLayerSpec;
    TA_TdLayerSpec.AddParFormal(&TA_class);
    TA_TdLayerSpec.AddParCache(&TA_taBase);
    TA_TdLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMethods(TA_TdLayerSpec,TA_TdLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TdLayerSpec);
    TA_const_TdLayerSpec.AddParents(&TA_const, &TA_TdLayerSpec);
  taMisc::types.Add(&TA_const_TdLayerSpec_ref);
    TA_const_TdLayerSpec_ref.AddParents(&TA_const_TdLayerSpec);
  taMisc::types.Add(&TA_LVConSpec);
    TAI_LVConSpec = new LVConSpec;
    TA_LVConSpec.AddParFormal(&TA_class);
    TA_LVConSpec.AddParCache(&TA_taBase);
    TA_LVConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_LVConSpec,TA_LVConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LVConSpec);
    TA_const_LVConSpec.AddParents(&TA_const, &TA_LVConSpec);
  taMisc::types.Add(&TA_const_LVConSpec_ref);
    TA_const_LVConSpec_ref.AddParents(&TA_const_LVConSpec);
  taMisc::types.Add(&TA_LVSpec);
    TAI_LVSpec = new LVSpec;
    TA_LVSpec.AddParFormal(&TA_class);
    TA_LVSpec.AddParCache(&TA_taBase);
    TA_LVSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LVSpec,TA_LVSpec_MemberDef);
  taMisc::types.Add(&TA_const_LVSpec);
    TA_const_LVSpec.AddParents(&TA_const, &TA_LVSpec);
  taMisc::types.Add(&TA_const_LVSpec_ref);
    TA_const_LVSpec_ref.AddParents(&TA_const_LVSpec);
  taMisc::types.Add(&TA_LVLayerSpec);
    TAI_LVLayerSpec = new LVLayerSpec;
    TA_LVLayerSpec.AddParFormal(&TA_class);
    TA_LVLayerSpec.AddParCache(&TA_taBase);
    TA_LVLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_LVLayerSpec,TA_LVLayerSpec_MemberDef);
    tac_AddMethods(TA_LVLayerSpec,TA_LVLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LVLayerSpec);
    TA_const_LVLayerSpec.AddParents(&TA_const, &TA_LVLayerSpec);
  taMisc::types.Add(&TA_const_LVLayerSpec_ref);
    TA_const_LVLayerSpec_ref.AddParents(&TA_const_LVLayerSpec);
  taMisc::types.Add(&TA_PVConSpec);
    TAI_PVConSpec = new PVConSpec;
    TA_PVConSpec.AddParFormal(&TA_class);
    TA_PVConSpec.AddParCache(&TA_taBase);
    TA_PVConSpec.AddClassPar(&TA_TrialSynDepConSpec,0);
    tac_AddMethods(TA_PVConSpec,TA_PVConSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVConSpec);
    TA_const_PVConSpec.AddParents(&TA_const, &TA_PVConSpec);
  taMisc::types.Add(&TA_const_PVConSpec_ref);
    TA_const_PVConSpec_ref.AddParents(&TA_const_PVConSpec);
  taMisc::types.Add(&TA_PVSpec);
    TAI_PVSpec = new PVSpec;
    TA_PVSpec.AddParFormal(&TA_class);
    TA_PVSpec.AddParCache(&TA_taBase);
    TA_PVSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PVSpec, "LearnMode", "", "", "", "", TA_PVSpec_LearnMode);
    tac_AddMembers(TA_PVSpec,TA_PVSpec_MemberDef);
  taMisc::types.Add(&TA_const_PVSpec);
    TA_const_PVSpec.AddParents(&TA_const, &TA_PVSpec);
  taMisc::types.Add(&TA_const_PVSpec_ref);
    TA_const_PVSpec_ref.AddParents(&TA_const_PVSpec);
  taMisc::types.Add(&TA_PVLayerSpec);
    TAI_PVLayerSpec = new PVLayerSpec;
    TA_PVLayerSpec.AddParFormal(&TA_class);
    TA_PVLayerSpec.AddParCache(&TA_taBase);
    TA_PVLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_PVLayerSpec,TA_PVLayerSpec_MemberDef);
    tac_AddMethods(TA_PVLayerSpec,TA_PVLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVLayerSpec);
    TA_const_PVLayerSpec.AddParents(&TA_const, &TA_PVLayerSpec);
  taMisc::types.Add(&TA_const_PVLayerSpec_ref);
    TA_const_PVLayerSpec_ref.AddParents(&TA_const_PVLayerSpec);
  taMisc::types.Add(&TA_PVSLayerSpec);
    TAI_PVSLayerSpec = new PVSLayerSpec;
    TA_PVSLayerSpec.AddParFormal(&TA_class);
    TA_PVSLayerSpec.AddParCache(&TA_taBase);
    TA_PVSLayerSpec.AddClassPar(&TA_PVLayerSpec,0);
  taMisc::types.Add(&TA_const_PVSLayerSpec);
    TA_const_PVSLayerSpec.AddParents(&TA_const, &TA_PVSLayerSpec);
  taMisc::types.Add(&TA_const_PVSLayerSpec_ref);
    TA_const_PVSLayerSpec_ref.AddParents(&TA_const_PVSLayerSpec);
  taMisc::types.Add(&TA_PVLVDaSpec);
    TAI_PVLVDaSpec = new PVLVDaSpec;
    TA_PVLVDaSpec.AddParFormal(&TA_class);
    TA_PVLVDaSpec.AddParCache(&TA_taBase);
    TA_PVLVDaSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PVLVDaSpec, "DaMode", "", "", "", "", TA_PVLVDaSpec_DaMode);
    tac_AddMembers(TA_PVLVDaSpec,TA_PVLVDaSpec_MemberDef);
  taMisc::types.Add(&TA_const_PVLVDaSpec);
    TA_const_PVLVDaSpec.AddParents(&TA_const, &TA_PVLVDaSpec);
  taMisc::types.Add(&TA_const_PVLVDaSpec_ref);
    TA_const_PVLVDaSpec_ref.AddParents(&TA_const_PVLVDaSpec);
  taMisc::types.Add(&TA_PVLVDaLayerSpec);
    TAI_PVLVDaLayerSpec = new PVLVDaLayerSpec;
    TA_PVLVDaLayerSpec.AddParFormal(&TA_class);
    TA_PVLVDaLayerSpec.AddParCache(&TA_taBase);
    TA_PVLVDaLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_PVLVDaLayerSpec,TA_PVLVDaLayerSpec_MemberDef);
    tac_AddMethods(TA_PVLVDaLayerSpec,TA_PVLVDaLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVLVDaLayerSpec);
    TA_const_PVLVDaLayerSpec.AddParents(&TA_const, &TA_PVLVDaLayerSpec);
  taMisc::types.Add(&TA_const_PVLVDaLayerSpec_ref);
    TA_const_PVLVDaLayerSpec_ref.AddParents(&TA_const_PVLVDaLayerSpec);
  taMisc::types.Add(&TA_PatchLayerSpec);
    TAI_PatchLayerSpec = new PatchLayerSpec;
    TA_PatchLayerSpec.AddParFormal(&TA_class);
    TA_PatchLayerSpec.AddParCache(&TA_taBase);
    TA_PatchLayerSpec.AddClassPar(&TA_PVLayerSpec,0);
  taMisc::types.Add(&TA_const_PatchLayerSpec);
    TA_const_PatchLayerSpec.AddParents(&TA_const, &TA_PatchLayerSpec);
  taMisc::types.Add(&TA_const_PatchLayerSpec_ref);
    TA_const_PatchLayerSpec_ref.AddParents(&TA_const_PatchLayerSpec);
  taMisc::types.Add(&TA_SNcMiscSpec);
    TAI_SNcMiscSpec = new SNcMiscSpec;
    TA_SNcMiscSpec.AddParFormal(&TA_class);
    TA_SNcMiscSpec.AddParCache(&TA_taBase);
    TA_SNcMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_SNcMiscSpec, "PatchMode", "", "", "", "", TA_SNcMiscSpec_PatchMode);
    tac_AddMembers(TA_SNcMiscSpec,TA_SNcMiscSpec_MemberDef);
  taMisc::types.Add(&TA_const_SNcMiscSpec);
    TA_const_SNcMiscSpec.AddParents(&TA_const, &TA_SNcMiscSpec);
  taMisc::types.Add(&TA_const_SNcMiscSpec_ref);
    TA_const_SNcMiscSpec_ref.AddParents(&TA_const_SNcMiscSpec);
  taMisc::types.Add(&TA_SNcLayerSpec);
    TAI_SNcLayerSpec = new SNcLayerSpec;
    TA_SNcLayerSpec.AddParFormal(&TA_class);
    TA_SNcLayerSpec.AddParCache(&TA_taBase);
    TA_SNcLayerSpec.AddClassPar(&TA_PVLVDaLayerSpec,0);
    tac_AddMembers(TA_SNcLayerSpec,TA_SNcLayerSpec_MemberDef);
    tac_AddMethods(TA_SNcLayerSpec,TA_SNcLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_SNcLayerSpec);
    TA_const_SNcLayerSpec.AddParents(&TA_const, &TA_SNcLayerSpec);
  taMisc::types.Add(&TA_const_SNcLayerSpec_ref);
    TA_const_SNcLayerSpec_ref.AddParents(&TA_const_SNcLayerSpec);
  taMisc::types.Add(&TA_MatrixConSpec);
    TAI_MatrixConSpec = new MatrixConSpec;
    TA_MatrixConSpec.AddParFormal(&TA_class);
    TA_MatrixConSpec.AddParCache(&TA_taBase);
    TA_MatrixConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddEnum(TA_MatrixConSpec, "LearnRule", "", "", "", "", TA_MatrixConSpec_LearnRule);
    tac_AddMembers(TA_MatrixConSpec,TA_MatrixConSpec_MemberDef);
    tac_AddMethods(TA_MatrixConSpec,TA_MatrixConSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixConSpec);
    TA_const_MatrixConSpec.AddParents(&TA_const, &TA_MatrixConSpec);
  taMisc::types.Add(&TA_const_MatrixConSpec_ref);
    TA_const_MatrixConSpec_ref.AddParents(&TA_const_MatrixConSpec);
  taMisc::types.Add(&TA_MatrixBiasSpec);
    TAI_MatrixBiasSpec = new MatrixBiasSpec;
    TA_MatrixBiasSpec.AddParFormal(&TA_class);
    TA_MatrixBiasSpec.AddParCache(&TA_taBase);
    TA_MatrixBiasSpec.AddClassPar(&TA_LeabraBiasSpec,0);
    tac_AddEnum(TA_MatrixBiasSpec, "LearnRule", "", "", "", "", TA_MatrixBiasSpec_LearnRule);
    tac_AddMembers(TA_MatrixBiasSpec,TA_MatrixBiasSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixBiasSpec);
    TA_const_MatrixBiasSpec.AddParents(&TA_const, &TA_MatrixBiasSpec);
  taMisc::types.Add(&TA_const_MatrixBiasSpec_ref);
    TA_const_MatrixBiasSpec_ref.AddParents(&TA_const_MatrixBiasSpec);
  taMisc::types.Add(&TA_MatrixUnitSpec);
    TAI_MatrixUnitSpec = new MatrixUnitSpec;
    TA_MatrixUnitSpec.AddParFormal(&TA_class);
    TA_MatrixUnitSpec.AddParCache(&TA_taBase);
    TA_MatrixUnitSpec.AddClassPar(&TA_DaModUnitSpec,0);
    tac_AddMembers(TA_MatrixUnitSpec,TA_MatrixUnitSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixUnitSpec);
    TA_const_MatrixUnitSpec.AddParents(&TA_const, &TA_MatrixUnitSpec);
  taMisc::types.Add(&TA_const_MatrixUnitSpec_ref);
    TA_const_MatrixUnitSpec_ref.AddParents(&TA_const_MatrixUnitSpec);
  taMisc::types.Add(&TA_ContrastSpec);
    TAI_ContrastSpec = new ContrastSpec;
    TA_ContrastSpec.AddParFormal(&TA_class);
    TA_ContrastSpec.AddParCache(&TA_taBase);
    TA_ContrastSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ContrastSpec,TA_ContrastSpec_MemberDef);
  taMisc::types.Add(&TA_const_ContrastSpec);
    TA_const_ContrastSpec.AddParents(&TA_const, &TA_ContrastSpec);
  taMisc::types.Add(&TA_const_ContrastSpec_ref);
    TA_const_ContrastSpec_ref.AddParents(&TA_const_ContrastSpec);
  taMisc::types.Add(&TA_MatrixRndGoSpec);
    TAI_MatrixRndGoSpec = new MatrixRndGoSpec;
    TA_MatrixRndGoSpec.AddParFormal(&TA_class);
    TA_MatrixRndGoSpec.AddParCache(&TA_taBase);
    TA_MatrixRndGoSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixRndGoSpec,TA_MatrixRndGoSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixRndGoSpec);
    TA_const_MatrixRndGoSpec.AddParents(&TA_const, &TA_MatrixRndGoSpec);
  taMisc::types.Add(&TA_const_MatrixRndGoSpec_ref);
    TA_const_MatrixRndGoSpec_ref.AddParents(&TA_const_MatrixRndGoSpec);
  taMisc::types.Add(&TA_MatrixRndGoThrSpec);
    TAI_MatrixRndGoThrSpec = new MatrixRndGoThrSpec;
    TA_MatrixRndGoThrSpec.AddParFormal(&TA_class);
    TA_MatrixRndGoThrSpec.AddParCache(&TA_taBase);
    TA_MatrixRndGoThrSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixRndGoThrSpec,TA_MatrixRndGoThrSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixRndGoThrSpec);
    TA_const_MatrixRndGoThrSpec.AddParents(&TA_const, &TA_MatrixRndGoThrSpec);
  taMisc::types.Add(&TA_const_MatrixRndGoThrSpec_ref);
    TA_const_MatrixRndGoThrSpec_ref.AddParents(&TA_const_MatrixRndGoThrSpec);
  taMisc::types.Add(&TA_MatrixMiscSpec);
    TAI_MatrixMiscSpec = new MatrixMiscSpec;
    TA_MatrixMiscSpec.AddParFormal(&TA_class);
    TA_MatrixMiscSpec.AddParCache(&TA_taBase);
    TA_MatrixMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixMiscSpec,TA_MatrixMiscSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraUnit_Group_ptr);
    TA_LeabraUnit_Group_ptr.AddParents(&TA_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_MatrixMiscSpec);
    TA_const_MatrixMiscSpec.AddParents(&TA_const, &TA_MatrixMiscSpec);
  taMisc::types.Add(&TA_const_MatrixMiscSpec_ref);
    TA_const_MatrixMiscSpec_ref.AddParents(&TA_const_MatrixMiscSpec);
  taMisc::types.Add(&TA_MatrixLayerSpec);
    TAI_MatrixLayerSpec = new MatrixLayerSpec;
    TA_MatrixLayerSpec.AddParFormal(&TA_class);
    TA_MatrixLayerSpec.AddParCache(&TA_taBase);
    TA_MatrixLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_MatrixLayerSpec, "BGType", " which type of basal ganglia circuit is this?", "", "", "", TA_MatrixLayerSpec_BGType);
    tac_AddMembers(TA_MatrixLayerSpec,TA_MatrixLayerSpec_MemberDef);
    tac_AddMethods(TA_MatrixLayerSpec,TA_MatrixLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixLayerSpec);
    TA_const_MatrixLayerSpec.AddParents(&TA_const, &TA_MatrixLayerSpec);
  taMisc::types.Add(&TA_const_MatrixLayerSpec_ref);
    TA_const_MatrixLayerSpec_ref.AddParents(&TA_const_MatrixLayerSpec);
  taMisc::types.Add(&TA_SNrThalLayerSpec);
    TAI_SNrThalLayerSpec = new SNrThalLayerSpec;
    TA_SNrThalLayerSpec.AddParFormal(&TA_class);
    TA_SNrThalLayerSpec.AddParCache(&TA_taBase);
    TA_SNrThalLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_SNrThalLayerSpec,TA_SNrThalLayerSpec_MemberDef);
    tac_AddMethods(TA_SNrThalLayerSpec,TA_SNrThalLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_SNrThalLayerSpec);
    TA_const_SNrThalLayerSpec.AddParents(&TA_const, &TA_SNrThalLayerSpec);
  taMisc::types.Add(&TA_const_SNrThalLayerSpec_ref);
    TA_const_SNrThalLayerSpec_ref.AddParents(&TA_const_SNrThalLayerSpec);
  taMisc::types.Add(&TA_PFCGateSpec);
    TAI_PFCGateSpec = new PFCGateSpec;
    TA_PFCGateSpec.AddParFormal(&TA_class);
    TA_PFCGateSpec.AddParCache(&TA_taBase);
    TA_PFCGateSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PFCGateSpec, "GateSignal", "", "", "", "", TA_PFCGateSpec_GateSignal);
    tac_AddEnum(TA_PFCGateSpec, "GateState", " what happened on last gating action, stored in misc_state1 on unit group", "", "", "", TA_PFCGateSpec_GateState);
    tac_AddMembers(TA_PFCGateSpec,TA_PFCGateSpec_MemberDef);
  taMisc::types.Add(&TA_const_PFCGateSpec);
    TA_const_PFCGateSpec.AddParents(&TA_const, &TA_PFCGateSpec);
  taMisc::types.Add(&TA_const_PFCGateSpec_ref);
    TA_const_PFCGateSpec_ref.AddParents(&TA_const_PFCGateSpec);
  taMisc::types.Add(&TA_PFCLayerSpec);
    TAI_PFCLayerSpec = new PFCLayerSpec;
    TA_PFCLayerSpec.AddParFormal(&TA_class);
    TA_PFCLayerSpec.AddParCache(&TA_taBase);
    TA_PFCLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_PFCLayerSpec, "MaintUpdtAct", "", "", "", "", TA_PFCLayerSpec_MaintUpdtAct);
    tac_AddMembers(TA_PFCLayerSpec,TA_PFCLayerSpec_MemberDef);
    tac_AddMethods(TA_PFCLayerSpec,TA_PFCLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PFCLayerSpec);
    TA_const_PFCLayerSpec.AddParents(&TA_const, &TA_PFCLayerSpec);
  taMisc::types.Add(&TA_const_PFCLayerSpec_ref);
    TA_const_PFCLayerSpec_ref.AddParents(&TA_const_PFCLayerSpec);
  taMisc::types.Add(&TA_LeabraWiz);
    TAI_LeabraWiz = new LeabraWiz;
    TA_LeabraWiz.AddParFormal(&TA_class);
    TA_LeabraWiz.AddParCache(&TA_taBase);
    TA_LeabraWiz.AddClassPar(&TA_Wizard,0);
    tac_AddMethods(TA_LeabraWiz,TA_LeabraWiz_MethodDef);
  taMisc::types.Add(&TA_const_LeabraWiz);
    TA_const_LeabraWiz.AddParents(&TA_const, &TA_LeabraWiz);
  taMisc::types.Add(&TA_const_LeabraWiz_ref);
    TA_const_LeabraWiz_ref.AddParents(&TA_const_LeabraWiz);


  taMisc::in_init = false;
} 
