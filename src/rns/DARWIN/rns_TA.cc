// File Automatically Generated by MakeTA
// DO NOT EDIT


#include <ta/typea.h>
#include <ta/typea_constr.h>
#include <css/basic_types.h>
#include <css/c_ptr_types.h>
#include <css/ta_css.h>
#include <rns.h>
#include "rns_TA_type.h"
#include "rns_TA_inst.h"


// Types

TypeDef TA_RtCon("RtCon", " Rt connection ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(RtCon), (void**)&TAI_RtCon, 0, 0, 0,1);
TypeDef TA_RtCon_Group("RtCon_Group", " group of Rt connections ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(RtCon_Group), (void**)&TAI_RtCon_Group, 0, 0, 0,1);
TypeDef TA_RtUnit("RtUnit", " basic Rt unit ", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 ", "", sizeof(RtUnit), (void**)&TAI_RtUnit, 0, 0, 0,1);
TypeDef TA_ModelParam("ModelParam", " holds pointers to parameters of model ", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(ModelParam), (void**)&TAI_ModelParam, 1, 0, 0,1);
TypeDef TA_RtUnitSpec("RtUnitSpec", " Real-Time Unit Specification ", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(RtUnitSpec), (void**)&TAI_RtUnitSpec, 1, 0, 0,1);
TypeDef TA_RtTrial("RtTrial", " one presentation of an event to Rt ", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(RtTrial), (void**)&TAI_RtTrial, 1, 0, 0,1);
TypeDef TA_float_DelayBuffer("float_DelayBuffer", " Circular buffer for holding state information ", 
	"", "", "", sizeof(float_DelayBuffer), (void**)&TAI_float_DelayBuffer, 0, 0, 0,1);
TypeDef TA_RtEvent("RtEvent", " Macros ", 
	"SCOPE_Environment EXT_evt NO_UPDATE_AFTER ", "SCOPE_Environment EXT_evt NO_UPDATE_AFTER ", "", sizeof(RtEvent), (void**)&TAI_RtEvent, 0, 0, 0,1);
TypeDef TA_const_float_DelayBuffer("const_float_DelayBuffer", 1, 0, 0, 0,1);
TypeDef TA_const_float_DelayBuffer_ref("const_float_DelayBuffer_ref", 1, 0, 1, 0,1);
TypeDef TA_NeuroModInfo("NeuroModInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(NeuroModInfo), (void**)&TAI_NeuroModInfo, 0, 0, 0,1);
TypeDef TA_const_NeuroModInfo("const_NeuroModInfo", 1, 0, 0, 0,1);
TypeDef TA_NMDAInfo("NMDAInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(NMDAInfo), (void**)&TAI_NMDAInfo, 0, 0, 0,1);
TypeDef TA_const_NeuroModInfo_ref("const_NeuroModInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_const_NMDAInfo("const_NMDAInfo", 1, 0, 0, 0,1);
TypeDef TA_const_NMDAInfo_ref("const_NMDAInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_HabitInfo("HabitInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(HabitInfo), (void**)&TAI_HabitInfo, 0, 0, 0,1);
TypeDef TA_const_HabitInfo("const_HabitInfo", 1, 0, 0, 0,1);
TypeDef TA_const_HabitInfo_ref("const_HabitInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_ActInfo("ActInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ActInfo), (void**)&TAI_ActInfo, 0, 0, 0,1);
TypeDef TA_const_ActInfo("const_ActInfo", 1, 0, 0, 0,1);
TypeDef TA_const_ActInfo_ref("const_ActInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_ActTraceInfo("ActTraceInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ActTraceInfo), (void**)&TAI_ActTraceInfo, 0, 0, 0,1);
TypeDef TA_const_ActTraceInfo("const_ActTraceInfo", 1, 0, 0, 0,1);
TypeDef TA_const_ActTraceInfo_ref("const_ActTraceInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_RecExcInfo("RecExcInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE ", "", sizeof(RecExcInfo), (void**)&TAI_RecExcInfo, 0, 0, 0,1);
TypeDef TA_const_RecExcInfo("const_RecExcInfo", 1, 0, 0, 0,1);
TypeDef TA_const_RecExcInfo_ref("const_RecExcInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_SoftClampInfo("SoftClampInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SoftClampInfo), (void**)&TAI_SoftClampInfo, 0, 0, 0,1);
TypeDef TA_const_SoftClampInfo("const_SoftClampInfo", 1, 0, 0, 0,1);
TypeDef TA_const_SoftClampInfo_ref("const_SoftClampInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_NormInfo("NormInfo", " inline class to keep track of neuromodulator effects ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(NormInfo), (void**)&TAI_NormInfo, 0, 0, 0,1);
TypeDef TA_const_NormInfo("const_NormInfo", 1, 0, 0, 0,1);
TypeDef TA_const_NormInfo_ref("const_NormInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_SpikeInfo("SpikeInfo", " inline class to keep track of spiking properties", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SpikeInfo), (void**)&TAI_SpikeInfo, 0, 0, 0,1);
TypeDef TA_const_SpikeInfo("const_SpikeInfo", 1, 0, 0, 0,1);
TypeDef TA_const_SpikeInfo_ref("const_SpikeInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_RandLearnInfoSpec("RandLearnInfoSpec", " inline class to keep track of postsynaptic learning threshold changes for random sample learning ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(RandLearnInfoSpec), (void**)&TAI_RandLearnInfoSpec, 0, 0, 0,1);
TypeDef TA_const_RandLearnInfoSpec("const_RandLearnInfoSpec", 1, 0, 0, 0,1);
TypeDef TA_const_RandLearnInfoSpec_ref("const_RandLearnInfoSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_VectAssocMapInfo("VectAssocMapInfo", " if active, causes cells to respond only to certain *ranges* of net_input intensity. (e.g. If response desired ONLY if net_excit in [0.4, 0.6], set peak = 0.5 and hwidth = 0.1) Creates symmetric triangular tuning curve. ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(VectAssocMapInfo), (void**)&TAI_VectAssocMapInfo, 0, 0, 0,1);
TypeDef TA_RtUnitSpec_ptr("RtUnitSpec_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_VectAssocMapInfo("const_VectAssocMapInfo", 1, 0, 0, 0,1);
TypeDef TA_RtUnit_ptr("RtUnit_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_VectAssocMapInfo_ref("const_VectAssocMapInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_const_RtUnitSpec("const_RtUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_RtUnitSpec_ref("const_RtUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_RtUnit("const_RtUnit", 1, 0, 0, 0,1);
TypeDef TA_const_RtUnit_ref("const_RtUnit_ref", 1, 0, 1, 0,1);
TypeDef TA_const_RtCon("const_RtCon", 1, 0, 0, 0,1);
TypeDef TA_const_RtCon_ref("const_RtCon_ref", 1, 0, 1, 0,1);
TypeDef TA_SigFuncInfo("SigFuncInfo", " signal function; defines threshold for presynaptic cells", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(SigFuncInfo), (void**)&TAI_SigFuncInfo, 0, 0, 0,1);
TypeDef TA_const_SigFuncInfo("const_SigFuncInfo", 1, 0, 0, 0,1);
TypeDef TA_EligTraceInfo("EligTraceInfo", " governs synaptic eligibility trace", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(EligTraceInfo), (void**)&TAI_EligTraceInfo, 0, 0, 0,1);
TypeDef TA_const_SigFuncInfo_ref("const_SigFuncInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_const_EligTraceInfo("const_EligTraceInfo", 1, 0, 0, 0,1);
TypeDef TA_const_EligTraceInfo_ref("const_EligTraceInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_ModLearnInfo("ModLearnInfo", " governs modular learning laws", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ModLearnInfo), (void**)&TAI_ModLearnInfo, 0, 0, 0,1);
TypeDef TA_const_ModLearnInfo("const_ModLearnInfo", 1, 0, 0, 0,1);
TypeDef TA_const_ModLearnInfo_ref("const_ModLearnInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_ModLearnDecayInfo("ModLearnDecayInfo", " governs modular learning law passive decay", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ModLearnDecayInfo), (void**)&TAI_ModLearnDecayInfo, 0, 0, 0,1);
TypeDef TA_const_ModLearnDecayInfo("const_ModLearnDecayInfo", 1, 0, 0, 0,1);
TypeDef TA_const_ModLearnDecayInfo_ref("const_ModLearnDecayInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_ExcludeNormInfo("ExcludeNormInfo", " keeps track of which weights should be excluded from weight normalization", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ExcludeNormInfo), (void**)&TAI_ExcludeNormInfo, 0, 0, 0,1);
TypeDef TA_RtCon_ptr("RtCon_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_ExcludeNormInfo("const_ExcludeNormInfo", 1, 0, 0, 0,1);
TypeDef TA_const_ExcludeNormInfo_ref("const_ExcludeNormInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_ModLearnInfo_ptr("ModLearnInfo_ptr", 1, 1, 0, 0,1);
TypeDef TA_RtConSpec("RtConSpec", " Rt connection specifications ", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(RtConSpec), (void**)&TAI_RtConSpec, 1, 0, 0,1);
TypeDef TA_const_RtCon_Group("const_RtCon_Group", 1, 0, 0, 0,1);
TypeDef TA_const_RtConSpec("const_RtConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_RtCon_Group_ref("const_RtCon_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_const_RtConSpec_ref("const_RtConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_RtTrial("const_RtTrial", 1, 0, 0, 0,1);
TypeDef TA_const_RtTrial_ref("const_RtTrial_ref", 1, 0, 1, 0,1);
TypeDef TA_RtEvent_ptr("RtEvent_ptr", 1, 1, 0, 0,1);
TypeDef TA_RtEpoch("RtEpoch", "", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(RtEpoch), (void**)&TAI_RtEpoch, 1, 0, 0,1);
TypeDef TA_Trigger("Trigger", " ////// Response Stat /////////// ", 
	"", "", "", sizeof(Trigger), (void**)&TAI_Trigger, 1, 0, 0,1);
TypeDef TA_const_RtEpoch("const_RtEpoch", 1, 0, 0, 0,1);
TypeDef TA_const_RtEpoch_ref("const_RtEpoch_ref", 1, 0, 1, 0,1);
TypeDef TA_RtTrial_ptr("RtTrial_ptr", 1, 1, 0, 0,1);
TypeDef TA_Trigger_ptr("Trigger_ptr", 1, 1, 0, 0,1);
TypeDef TA_ResponseStat("ResponseStat", " Reports whether a response has been made, and if so, whether correct. Response occurs when Compare layer unit exceeds threshold. Response correct when corresponding enviro pattern unit non-zero. ", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(ResponseStat), (void**)&TAI_ResponseStat, 1, 0, 0,1);
TypeDef TA_const_ResponseStat("const_ResponseStat", 1, 0, 0, 0,1);
TypeDef TA_TriggerCondition("TriggerCondition", "", 
	"", "", "", sizeof(TriggerCondition), (void**)&TAI_TriggerCondition, 1, 0, 0,1);
TypeDef TA_const_ResponseStat_ref("const_ResponseStat_ref", 1, 0, 1, 0,1);
TypeDef TA_const_Trigger("const_Trigger", 1, 0, 0, 0,1);
TypeDef TA_const_TriggerCondition("const_TriggerCondition", 1, 0, 0, 0,1);
TypeDef TA_const_Trigger_ref("const_Trigger_ref", 1, 0, 1, 0,1);
TypeDef TA_const_TriggerCondition_ref("const_TriggerCondition_ref", 1, 0, 1, 0,1);
TypeDef TA_TransitionProb("TransitionProb", "", 
	"", "", "", sizeof(TransitionProb), (void**)&TAI_TransitionProb, 1, 0, 0,1);
TypeDef TA_taGroup_TransitionProb_("taGroup_TransitionProb_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taGroup<TransitionProb>), (void**)&TAI_taGroup_TransitionProb_, 0, 0, 0,1);
TypeDef TA_const_TransitionProb("const_TransitionProb", 1, 0, 0, 0,1);
TypeDef TA_const_TransitionProb_ref("const_TransitionProb_ref", 1, 0, 1, 0,1);
TypeDef TA_TransitionProb_Group("TransitionProb_Group", " group of objects ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(TransitionProb_Group), (void**)&TAI_TransitionProb_Group, 0, 0, 0,1);
TypeDef TA_const_TransitionProb_Group("const_TransitionProb_Group", 1, 0, 0, 0,1);
TypeDef TA_eventTransition("eventTransition", "", 
	"", "", "", sizeof(eventTransition), (void**)&TAI_eventTransition, 1, 0, 0,1);
TypeDef TA_const_TransitionProb_Group_ref("const_TransitionProb_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_const_eventTransition("const_eventTransition", 1, 0, 0, 0,1);
TypeDef TA_const_eventTransition_ref("const_eventTransition_ref", 1, 0, 1, 0,1);
TypeDef TA_RtPatternSpec("RtPatternSpec", "", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Environment ", "EXT_spec MEMB_IN_GPMENU SCOPE_Environment ", "", sizeof(RtPatternSpec), (void**)&TAI_RtPatternSpec, 1, 0, 0,1);
TypeDef TA_const_RtPatternSpec("const_RtPatternSpec", 1, 0, 0, 0,1);
TypeDef TA_const_RtPatternSpec_ref("const_RtPatternSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_NextEventInfo("NextEventInfo", "", 
	"", "", "", sizeof(NextEventInfo), (void**)&TAI_NextEventInfo, 1, 0, 0,1);
TypeDef TA_taGroup_Trigger_("taGroup_Trigger_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taGroup<Trigger>), (void**)&TAI_taGroup_Trigger_, 0, 0, 0,1);
TypeDef TA_const_NextEventInfo("const_NextEventInfo", 1, 0, 0, 0,1);
TypeDef TA_const_NextEventInfo_ref("const_NextEventInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_Trigger_Group("Trigger_Group", " group of objects ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(Trigger_Group), (void**)&TAI_Trigger_Group, 0, 0, 0,1);
TypeDef TA_taGroup_NextEventInfo_("taGroup_NextEventInfo_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taGroup<NextEventInfo>), (void**)&TAI_taGroup_NextEventInfo_, 0, 0, 0,1);
TypeDef TA_const_Trigger_Group("const_Trigger_Group", 1, 0, 0, 0,1);
TypeDef TA_const_Trigger_Group_ref("const_Trigger_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_NextEventInfo_Group("NextEventInfo_Group", " group of objects ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(NextEventInfo_Group), (void**)&TAI_NextEventInfo_Group, 0, 0, 0,1);
TypeDef TA_const_NextEventInfo_Group("const_NextEventInfo_Group", 1, 0, 0, 0,1);
TypeDef TA_const_NextEventInfo_Group_ref("const_NextEventInfo_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_RtEventSpec("RtEventSpec", "", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Environment IMMEDIATE_UPDATE ", "EXT_spec MEMB_IN_GPMENU SCOPE_Environment IMMEDIATE_UPDATE ", "", sizeof(RtEventSpec), (void**)&TAI_RtEventSpec, 1, 0, 0,1);
TypeDef TA_NextEventInfo_ptr("NextEventInfo_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_RtEventSpec("const_RtEventSpec", 1, 0, 0, 0,1);
TypeDef TA_NextEventInfo_Group_ptr("NextEventInfo_Group_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_RtEventSpec_ref("const_RtEventSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_RtEvent("const_RtEvent", 1, 0, 0, 0,1);
TypeDef TA_const_RtEvent_ref("const_RtEvent_ref", 1, 0, 1, 0,1);
TypeDef TA_RtConstraintInfo("RtConstraintInfo", " typedef taGroup<RtConstraintInfo> RtConstraintInfo_Group;  For now, only tracks one value, applied to an individual element (unit or con), or else uniformly to the entire group (layer or projection) ", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(RtConstraintInfo), (void**)&TAI_RtConstraintInfo, 1, 0, 0,1);
TypeDef TA_RtConstraintInfo_Group("RtConstraintInfo_Group", "", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(RtConstraintInfo_Group), (void**)&TAI_RtConstraintInfo_Group, 0, 0, 0,1);
TypeDef TA_RtConstraintInfo_Group_ptr("RtConstraintInfo_Group_ptr", 1, 1, 0, 0,1);
TypeDef TA_RtConstraintInfo_ptr("RtConstraintInfo_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_RtConstraintInfo("const_RtConstraintInfo", 1, 0, 0, 0,1);
TypeDef TA_const_RtConstraintInfo_ref("const_RtConstraintInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_RtConstraintSpec("RtConstraintSpec", "", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(RtConstraintSpec), (void**)&TAI_RtConstraintSpec, 1, 0, 0,1);
TypeDef TA_FitDataInfo("FitDataInfo", "", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(FitDataInfo), (void**)&TAI_FitDataInfo, 1, 0, 0,1);
TypeDef TA_const_RtConstraintSpec("const_RtConstraintSpec", 1, 0, 0, 0,1);
TypeDef TA_FitDataInfo_Group("FitDataInfo_Group", " This class keeps track of one piece of data to be fit by the model. It specifies the data and also specifies the input/state constraints on the network under which the network should fit the data ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(FitDataInfo_Group), (void**)&TAI_FitDataInfo_Group, 0, 0, 0,1);
TypeDef TA_const_RtConstraintSpec_ref("const_RtConstraintSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_FitDataInfo("const_FitDataInfo", 1, 0, 0, 0,1);
TypeDef TA_const_FitDataInfo_ref("const_FitDataInfo_ref", 1, 0, 1, 0,1);
TypeDef TA_FitDataSpec("FitDataSpec", "", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(FitDataSpec), (void**)&TAI_FitDataSpec, 1, 0, 0,1);
TypeDef TA_float_Array_ptr("float_Array_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_FitDataSpec("const_FitDataSpec", 1, 0, 0, 0,1);
TypeDef TA_const_FitDataSpec_ref("const_FitDataSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_optim("optim", "", 
	"", "", "", sizeof(optim), (void**)&TAI_optim, 1, 0, 0,1);
TypeDef TA_const_optim("const_optim", 1, 0, 0, 0,1);
TypeDef TA_simplex("simplex", "", 
	"", "", "", sizeof(simplex), (void**)&TAI_simplex, 1, 0, 0,1);
TypeDef TA_const_optim_ref("const_optim_ref", 1, 0, 1, 0,1);
TypeDef TA_const_simplex("const_simplex", 1, 0, 0, 0,1);
TypeDef TA_const_simplex_ref("const_simplex_ref", 1, 0, 1, 0,1);
TypeDef TA_subplex("subplex", " set stepsizes ", 
	"", "", "", sizeof(subplex), (void**)&TAI_subplex, 1, 0, 0,1);
TypeDef TA_FitDataInfo_Group_ptr("FitDataInfo_Group_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_subplex("const_subplex", 1, 0, 0, 0,1);
TypeDef TA_const_subplex_ref("const_subplex_ref", 1, 0, 1, 0,1);
TypeDef TA_RtDistFitMgr("RtDistFitMgr", "", 
	"", "", "", sizeof(RtDistFitMgr), (void**)&TAI_RtDistFitMgr, 1, 0, 0,1);
TypeDef TA_ModelParam_ptr("ModelParam_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_RtDistFitMgr("const_RtDistFitMgr", 1, 0, 0, 0,1);
TypeDef TA_FitDataSpec_ptr("FitDataSpec_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_RtDistFitMgr_ref("const_RtDistFitMgr_ref", 1, 0, 1, 0,1);
TypeDef TA_RtConstrain("RtConstrain", "", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(RtConstrain), (void**)&TAI_RtConstrain, 1, 0, 0,1);
TypeDef TA_const_RtConstrain("const_RtConstrain", 1, 0, 0, 0,1);
TypeDef TA_MPESubNameSpec("MPESubNameSpec", " inline subclass specification for ModelParamEntry ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(MPESubNameSpec), (void**)&TAI_MPESubNameSpec, 0, 0, 0,1);
TypeDef TA_const_RtConstrain_ref("const_RtConstrain_ref", 1, 0, 1, 0,1);
TypeDef TA_const_MPESubNameSpec("const_MPESubNameSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MPESubNameSpec_ref("const_MPESubNameSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_MPELimitSpec("MPELimitSpec", " inline subclass specification for ModelParamEntry ", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(MPELimitSpec), (void**)&TAI_MPELimitSpec, 0, 0, 0,1);
TypeDef TA_const_MPELimitSpec("const_MPELimitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_MPELimitSpec_ref("const_MPELimitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_ModelParamEntry("ModelParamEntry", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(ModelParamEntry), (void**)&TAI_ModelParamEntry, 1, 0, 0,1);
TypeDef TA_taGroup_ModelParamEntry_("taGroup_ModelParamEntry_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taGroup<ModelParamEntry>), (void**)&TAI_taGroup_ModelParamEntry_, 0, 0, 0,1);
TypeDef TA_const_ModelParamEntry("const_ModelParamEntry", 1, 0, 0, 0,1);
TypeDef TA_const_ModelParamEntry_ref("const_ModelParamEntry_ref", 1, 0, 1, 0,1);
TypeDef TA_ModelParamEntry_Group("ModelParamEntry_Group", " group of objects ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(ModelParamEntry_Group), (void**)&TAI_ModelParamEntry_Group, 0, 0, 0,1);
TypeDef TA_ModelParamEntry_ptr("ModelParamEntry_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_ModelParamEntry_Group("const_ModelParamEntry_Group", 1, 0, 0, 0,1);
TypeDef TA_const_ModelParam("const_ModelParam", 1, 0, 0, 0,1);
TypeDef TA_const_ModelParamEntry_Group_ref("const_ModelParamEntry_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_const_ModelParam_ref("const_ModelParam_ref", 1, 0, 1, 0,1);

// Instances

  static cssEl* cssElCFun_Rt_Shunting_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)Rt_Shunting((RtUnitSpec*)(void*)*arg[1], (RtUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_Rt_Tracking_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)Rt_Tracking((RtUnitSpec*)(void*)*arg[1], (RtUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_Rt_Additive_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)Rt_Additive((RtUnitSpec*)(void*)*arg[1], (RtUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_Rt_Usher_Mc_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)Rt_Usher_Mc((RtUnitSpec*)(void*)*arg[1], (RtUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_Rt_Cust_Script_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)Rt_Cust_Script((RtUnitSpec*)(void*)*arg[1], (RtUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_RtSetParams_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    RtSetParams((void*)(void*)*arg[1], (float_Array*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_RtGetParams_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    RtGetParams((void*)(void*)*arg[1], (float_Array*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_RtFitObjFunc_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)RtFitObjFunc((void*)(void*)*arg[1], (float_Array*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_RtFitCalcGrad_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    RtFitCalcGrad((void*)(void*)*arg[1], (float_Array*)(void*)*arg[2], (float_Array*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_RtSaveParams_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    RtSaveParams((void*)(void*)*arg[1]);
    return rval;}
RtCon*		 TAI_RtCon=NULL;
RtCon_Group*		 TAI_RtCon_Group=NULL;
  static cssEl* cssElCFun_RtCon_Group_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtCon_Group*)ths)->Compute_Net((RtUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_RtCon_Group_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtCon_Group*)ths)->Compute_dWt((RtUnit*)(void*)*arg[1]);
    return rval;}
RtUnit*		 TAI_RtUnit=NULL;
  static cssEl* cssElCFun_RtUnit_Prep_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnit*)ths)->Prep_Compute_Net((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtUnit_StoreState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnit*)ths)->StoreState();
    return rval;}
ModelParam*		 TAI_ModelParam=NULL;
  static cssEl* cssElCFun_ModelParam_findParam_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((ModelParam*)ths)->findParam(arg[1]->GetStr(), arg[2]->GetStr(), arg[3]->GetStr()), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_ModelParam_updateParamsFromObj_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ModelParam*)ths)->updateParamsFromObj(arg[1]->GetStr(), arg[2]->GetStr(), arg[3]->GetStr(), (float*)(void*)*arg[4], (bool)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_ModelParam_updateParamList_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ModelParam*)ths)->updateParamList();
    return rval;}
  static cssEl* cssElCFun_ModelParam_updateParamList_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ModelParam*)ths)->updateParamList_impl((BaseSpec_MGroup*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ModelParam_updateParamsFromSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ModelParam*)ths)->updateParamsFromSpec((taBase*)(void*)*arg[1]);
    return rval;}
RtUnitSpec*		 TAI_RtUnitSpec=NULL;
  static cssEl* cssElCFun_RtUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtUnitSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->Compute_Net((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtUnitSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->Compute_Act((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->Compute_dWt((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtUnitSpec_Prep_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->Prep_Compute_Net((RtUnit*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_RtUnitSpec_Compute_Wt_Norm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->Compute_Wt_Norm((RtUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtUnitSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtUnitSpec*)ths)->Compute_Act_impl((RtUnit*)(void*)*arg[1]);
    return rval;}
RtTrial*		 TAI_RtTrial=NULL;
  static cssEl* cssElCFun_RtTrial_GenCntrLog_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->GenCntrLog((LogData*)(void*)*arg[1], (bool)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_RtTrial_setFixedWts_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->setFixedWts((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtTrial_fixWts_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->fixWts();
    return rval;}
  static cssEl* cssElCFun_RtTrial_unclampWts_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->unclampWts();
    return rval;}
  static cssEl* cssElCFun_RtTrial_UpdateDt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->UpdateDt((BaseSpec_MGroup*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtTrial_Prep_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->Prep_Compute_Net();
    return rval;}
  static cssEl* cssElCFun_RtTrial_Compute_Act_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->Compute_Act();
    return rval;}
  static cssEl* cssElCFun_RtTrial_Compute_Wt_Norm_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->Compute_Wt_Norm();
    return rval;}
  static cssEl* cssElCFun_RtTrial_StoreState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtTrial*)ths)->StoreState();
    return rval;}
  static cssEl* cssElCFun_RtTrial_GetUnitBufSize_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((RtTrial*)ths)->GetUnitBufSize());}
    if(na == 1) {
      rval=new cssInt((int)((RtTrial*)ths)->GetUnitBufSize((bool)*arg[1]));}
    return rval;}
float_DelayBuffer*		 TAI_float_DelayBuffer=NULL;
  static cssEl* cssElCFun_float_DelayBuffer_SetSize_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((float_DelayBuffer*)ths)->SetSize((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_float_DelayBuffer_PushHead_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((float_DelayBuffer*)ths)->PushHead((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_float_DelayBuffer_ReadDelayed_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((float_DelayBuffer*)ths)->ReadDelayed((int)*arg[1]));
    return rval;}
RtEvent*		 TAI_RtEvent=NULL;
  static cssEl* cssElCFun_RtEvent_getNextEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((RtEvent*)ths)->getNextEvent((bool)*arg[1]), 1, &TA_RtEvent);
    return rval;}
NeuroModInfo*		 TAI_NeuroModInfo=NULL;
NMDAInfo*		 TAI_NMDAInfo=NULL;
HabitInfo*		 TAI_HabitInfo=NULL;
ActInfo*		 TAI_ActInfo=NULL;
ActTraceInfo*		 TAI_ActTraceInfo=NULL;
RecExcInfo*		 TAI_RecExcInfo=NULL;
SoftClampInfo*		 TAI_SoftClampInfo=NULL;
NormInfo*		 TAI_NormInfo=NULL;
SpikeInfo*		 TAI_SpikeInfo=NULL;
RandLearnInfoSpec*		 TAI_RandLearnInfoSpec=NULL;
VectAssocMapInfo*		 TAI_VectAssocMapInfo=NULL;
SigFuncInfo*		 TAI_SigFuncInfo=NULL;
EligTraceInfo*		 TAI_EligTraceInfo=NULL;
ModLearnInfo*		 TAI_ModLearnInfo=NULL;
ModLearnDecayInfo*		 TAI_ModLearnDecayInfo=NULL;
ExcludeNormInfo*		 TAI_ExcludeNormInfo=NULL;
RtConSpec*		 TAI_RtConSpec=NULL;
  static cssEl* cssElCFun_RtConSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtConSpec*)ths)->C_InitWtState((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_RtConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConSpec*)ths)->C_Compute_Net((Connection*)(void*)*arg[1], (RtUnit*)(void*)*arg[2], (RtUnit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_RtConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_RtConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtConSpec*)ths)->C_Compute_dWt((Connection*)(void*)*arg[1], (RtUnit*)(void*)*arg[2], (RtUnit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_RtConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_RtConSpec_updateDt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtConSpec*)ths)->updateDt((float)*arg[1], (bool)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_RtConSpec_doRWtNorm_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((RtConSpec*)ths)->doRWtNorm());
    return rval;}
  static cssEl* cssElCFun_RtConSpec_doSWtNorm_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((RtConSpec*)ths)->doSWtNorm());
    return rval;}
  static cssEl* cssElCFun_RtConSpec_Compute_Cooked_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConSpec*)ths)->Compute_Cooked_Act((Connection*)(void*)*arg[1], (RtUnit*)(void*)*arg[2], (RtUnit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_RtConSpec_ComputeModDwEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConSpec*)ths)->ComputeModDwEl((float)*arg[1], (float)*arg[2], (float)*arg[3], (RtUnit*)(void*)*arg[4], (ModLearnInfo*)(void*)*arg[5], (float)*arg[6]));
    return rval;}
  static cssEl* cssElCFun_RtConSpec_ComputeModDw_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConSpec*)ths)->ComputeModDw((float)*arg[1], (float)*arg[2], (float)*arg[3], (RtUnit*)(void*)*arg[4], (float)*arg[5]));
    return rval;}
RtEpoch*		 TAI_RtEpoch=NULL;
  static cssEl* cssElCFun_RtEpoch_specNextEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtEpoch*)ths)->specNextEvent((RtEvent*)(void*)*arg[1]);
    return rval;}
Trigger*		 TAI_Trigger=NULL;
  static cssEl* cssElCFun_Trigger_isTrig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((Trigger*)ths)->isTrig());
    return rval;}
  static cssEl* cssElCFun_Trigger_reset_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((Trigger*)ths)->reset();
    return rval;}
ResponseStat*		 TAI_ResponseStat=NULL;
  static cssEl* cssElCFun_ResponseStat_Unit_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ResponseStat*)ths)->Unit_Run((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ResponseStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ResponseStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ResponseStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ResponseStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ResponseStat_TrialInit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ResponseStat*)ths)->TrialInit();
    return rval;}
  static cssEl* cssElCFun_ResponseStat_ProcessResponse_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ResponseStat*)ths)->ProcessResponse((Unit*)(void*)*arg[1]);
    return rval;}
TriggerCondition*		 TAI_TriggerCondition=NULL;
TransitionProb*		 TAI_TransitionProb=NULL;
taGroup<TransitionProb>*		 TAI_taGroup_TransitionProb_=NULL;
  static cssEl* cssElCFun_taGroup_TransitionProb__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<TransitionProb>*)ths)->MoveBefore((TransitionProb*)(void*)*arg[1], (TransitionProb*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<TransitionProb>*)ths)->MoveAfter((TransitionProb*)(void*)*arg[1], (TransitionProb*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->SafeEl((int)*arg[1]), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FastEl((int)*arg[1]), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->DefaultEl(), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->Edit_El((TransitionProb*)(void*)*arg[1]), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->Leaf((int)*arg[1]), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__LeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->LeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FirstEl(refarg_0), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NextEl(refarg_0), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NewEl(), 1, &TA_TransitionProb);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NewEl((int)*arg[1]), 1, &TA_TransitionProb);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_TransitionProb);}
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindName((const char*)*arg[1]), 1, &TA_TransitionProb);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_TransitionProb);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_TransitionProb);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_TransitionProb);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->Pop(), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->Peek(), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->AddUniqNameOld((TransitionProb*)(void*)*arg[1]), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->LinkUniqNameOld((TransitionProb*)(void*)*arg[1]), 1, &TA_TransitionProb);
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_TransitionProb);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_TransitionProb);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_TransitionProb__FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_TransitionProb);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<TransitionProb>*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_TransitionProb);    *arg[2]=(Int)refarg_1;
}
    return rval;}
TransitionProb_Group*		 TAI_TransitionProb_Group=NULL;
eventTransition*		 TAI_eventTransition=NULL;
RtPatternSpec*		 TAI_RtPatternSpec=NULL;
  static cssEl* cssElCFun_RtPatternSpec_ApplyPattern_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtPatternSpec*)ths)->ApplyPattern((Pattern*)(void*)*arg[1]);
    return rval;}
NextEventInfo*		 TAI_NextEventInfo=NULL;
  static cssEl* cssElCFun_NextEventInfo_getNextEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((NextEventInfo*)ths)->getNextEvent((RtUnit*)(void*)*arg[1], (bool)*arg[2]), 1, &TA_RtEvent);
    return rval;}
taGroup<Trigger>*		 TAI_taGroup_Trigger_=NULL;
  static cssEl* cssElCFun_taGroup_Trigger__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<Trigger>*)ths)->MoveBefore((Trigger*)(void*)*arg[1], (Trigger*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<Trigger>*)ths)->MoveAfter((Trigger*)(void*)*arg[1], (Trigger*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->SafeEl((int)*arg[1]), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FastEl((int)*arg[1]), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->DefaultEl(), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->Edit_El((Trigger*)(void*)*arg[1]), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->Leaf((int)*arg[1]), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__LeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->LeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FirstEl(refarg_0), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NextEl(refarg_0), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NewEl(), 1, &TA_Trigger);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NewEl((int)*arg[1]), 1, &TA_Trigger);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_Trigger);}
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindName((const char*)*arg[1]), 1, &TA_Trigger);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_Trigger);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_Trigger);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_Trigger);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->Pop(), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->Peek(), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->AddUniqNameOld((Trigger*)(void*)*arg[1]), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->LinkUniqNameOld((Trigger*)(void*)*arg[1]), 1, &TA_Trigger);
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_Trigger);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_Trigger);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_Trigger__FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_Trigger);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<Trigger>*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_Trigger);    *arg[2]=(Int)refarg_1;
}
    return rval;}
Trigger_Group*		 TAI_Trigger_Group=NULL;
taGroup<NextEventInfo>*		 TAI_taGroup_NextEventInfo_=NULL;
  static cssEl* cssElCFun_taGroup_NextEventInfo__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<NextEventInfo>*)ths)->MoveBefore((NextEventInfo*)(void*)*arg[1], (NextEventInfo*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<NextEventInfo>*)ths)->MoveAfter((NextEventInfo*)(void*)*arg[1], (NextEventInfo*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->SafeEl((int)*arg[1]), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FastEl((int)*arg[1]), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->DefaultEl(), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->Edit_El((NextEventInfo*)(void*)*arg[1]), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->Leaf((int)*arg[1]), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__LeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->LeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FirstEl(refarg_0), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NextEl(refarg_0), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NewEl(), 1, &TA_NextEventInfo);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NewEl((int)*arg[1]), 1, &TA_NextEventInfo);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_NextEventInfo);}
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindName((const char*)*arg[1]), 1, &TA_NextEventInfo);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_NextEventInfo);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_NextEventInfo);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_NextEventInfo);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->Pop(), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->Peek(), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->AddUniqNameOld((NextEventInfo*)(void*)*arg[1]), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->LinkUniqNameOld((NextEventInfo*)(void*)*arg[1]), 1, &TA_NextEventInfo);
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_NextEventInfo);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_NextEventInfo);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_NextEventInfo__FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_NextEventInfo);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<NextEventInfo>*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_NextEventInfo);    *arg[2]=(Int)refarg_1;
}
    return rval;}
NextEventInfo_Group*		 TAI_NextEventInfo_Group=NULL;
RtEventSpec*		 TAI_RtEventSpec=NULL;
  static cssEl* cssElCFun_RtEventSpec_CheckTriggers_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((RtEventSpec*)ths)->CheckTriggers((Network*)(void*)*arg[1], (RtTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_RtEventSpec_ResetTriggers_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtEventSpec*)ths)->ResetTriggers();
    return rval;}
  static cssEl* cssElCFun_RtEventSpec_ZeroInputLayers_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtEventSpec*)ths)->ZeroInputLayers((Network*)(void*)*arg[1]);
    return rval;}
RtConstraintInfo*		 TAI_RtConstraintInfo=NULL;
  static cssEl* cssElCFun_RtConstraintInfo_ReadFromNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstraintInfo*)ths)->ReadFromNet();
    return rval;}
  static cssEl* cssElCFun_RtConstraintInfo_ApplyToNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstraintInfo*)ths)->ApplyToNet();
    return rval;}
  static cssEl* cssElCFun_RtConstraintInfo_RestoreNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstraintInfo*)ths)->RestoreNet();
    return rval;}
  static cssEl* cssElCFun_RtConstraintInfo_FindConstraints_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstraintInfo*)ths)->FindConstraints();
    return rval;}
  static cssEl* cssElCFun_RtConstraintInfo_LinkConstraint_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstraintInfo*)ths)->LinkConstraint();
    return rval;}
RtConstraintInfo_Group*		 TAI_RtConstraintInfo_Group=NULL;
RtConstraintSpec*		 TAI_RtConstraintSpec=NULL;
FitDataInfo*		 TAI_FitDataInfo=NULL;
  static cssEl* cssElCFun_FitDataInfo_FindConstraints_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((FitDataInfo*)ths)->FindConstraints();
    return rval;}
  static cssEl* cssElCFun_FitDataInfo_LinkEvent_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((FitDataInfo*)ths)->LinkEvent();
    return rval;}
  static cssEl* cssElCFun_FitDataInfo_LinearInterpModel_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FitDataInfo*)ths)->LinearInterpModel((float)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_FitDataInfo_CalcCellTypeFitError_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FitDataInfo*)ths)->CalcCellTypeFitError());
    return rval;}
FitDataInfo_Group*		 TAI_FitDataInfo_Group=NULL;
FitDataSpec*		 TAI_FitDataSpec=NULL;
  static cssEl* cssElCFun_FitDataSpec_CalcRSquare_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FitDataSpec*)ths)->CalcRSquare());
    return rval;}
  static cssEl* cssElCFun_FitDataSpec_DumpData_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((FitDataSpec*)ths)->DumpData();
    return rval;}
  static cssEl* cssElCFun_FitDataSpec_MakeRandEv_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((FitDataSpec*)ths)->MakeRandEv();
    return rval;}
optim*		 TAI_optim=NULL;
  static cssEl* cssElCFun_optim_setNumParams_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->setNumParams((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_optim_setDataObj_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->setDataObj((void*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_optim_Init_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->Init();
    return rval;}
  static cssEl* cssElCFun_optim_ReInit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->ReInit();
    return rval;}
  static cssEl* cssElCFun_optim_finishOpt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->finishOpt();
    return rval;}
  static cssEl* cssElCFun_optim_doOptStep_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->doOptStep();
    return rval;}
  static cssEl* cssElCFun_optim_doLineSrch_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((optim*)ths)->doLineSrch((int)*arg[1], (float_Array*)(void*)*arg[2], (float)*arg[3], (float_Array*)(void*)*arg[4], (float_Array*)(void*)*arg[5], (float_Array*)(void*)*arg[6], (float*)(void*)*arg[7], (float)*arg[8], (int*)(void*)*arg[9]);
    return rval;}
simplex*		 TAI_simplex=NULL;
  static cssEl* cssElCFun_simplex_setNumParams_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->setNumParams((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_simplex_resetActiveParams_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->resetActiveParams();
    return rval;}
  static cssEl* cssElCFun_simplex_setAllParamsActive_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->setAllParamsActive();
    return rval;}
  static cssEl* cssElCFun_simplex_setParamActive_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->setParamActive((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_simplex_setDataObj_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->setDataObj((void*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_simplex_Init_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->Init();
    return rval;}
  static cssEl* cssElCFun_simplex_ReInit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->ReInit();
    return rval;}
  static cssEl* cssElCFun_simplex_InitSimplex_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->InitSimplex();
    return rval;}
  static cssEl* cssElCFun_simplex_checkInitSimplex_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->checkInitSimplex();
    return rval;}
  static cssEl* cssElCFun_simplex_sortFVals_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->sortFVals();
    return rval;}
  static cssEl* cssElCFun_simplex_checkCrit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((simplex*)ths)->checkCrit());
    return rval;}
  static cssEl* cssElCFun_simplex_checkForceStop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((simplex*)ths)->checkForceStop());
    return rval;}
  static cssEl* cssElCFun_simplex_doOptStep_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->doOptStep();
    return rval;}
  static cssEl* cssElCFun_simplex_putBestPtInP_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->putBestPtInP();
    return rval;}
  static cssEl* cssElCFun_simplex_simplexCrit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((simplex*)ths)->simplexCrit());
    return rval;}
  static cssEl* cssElCFun_simplex_initStepSize_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((simplex*)ths)->initStepSize((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_simplex_calcPsum_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((simplex*)ths)->calcPsum();
    return rval;}
  static cssEl* cssElCFun_simplex_stepSimplex_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((simplex*)ths)->stepSimplex((float)*arg[1]));
    return rval;}
subplex*		 TAI_subplex=NULL;
  static cssEl* cssElCFun_subplex_useSubspace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((subplex*)ths)->useSubspace((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_subplex_updateStepVec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((subplex*)ths)->updateStepVec();
    return rval;}
  static cssEl* cssElCFun_subplex_setSubsp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((subplex*)ths)->setSubsp();
    return rval;}
  static cssEl* cssElCFun_subplex_computeSimplexSize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((subplex*)ths)->computeSimplexSize());
    return rval;}
  static cssEl* cssElCFun_subplex_subplexOuterCrit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((subplex*)ths)->subplexOuterCrit());
    return rval;}
RtDistFitMgr*		 TAI_RtDistFitMgr=NULL;
  static cssEl* cssElCFun_RtDistFitMgr_setNumParams_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->setNumParams((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtDistFitMgr_setNumConstr_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->setNumConstr((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtDistFitMgr_setDataObj_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->setDataObj((void*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtDistFitMgr_DirectSlaves_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->DirectSlaves();
    return rval;}
  static cssEl* cssElCFun_RtDistFitMgr_ReceiveOrders_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->ReceiveOrders();
    return rval;}
  static cssEl* cssElCFun_RtDistFitMgr_ReportToMaster_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->ReportToMaster((FitDataInfo_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_RtDistFitMgr_GetFromSlaves_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((RtDistFitMgr*)ths)->GetFromSlaves((FitDataInfo_Group*)(void*)*arg[1]);
    return rval;}
RtConstrain*		 TAI_RtConstrain=NULL;
  static cssEl* cssElCFun_RtConstrain_fitEnergy_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConstrain*)ths)->fitEnergy());
    return rval;}
  static cssEl* cssElCFun_RtConstrain_SaveParams_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstrain*)ths)->SaveParams();
    return rval;}
  static cssEl* cssElCFun_RtConstrain_PrepDoFit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstrain*)ths)->PrepDoFit();
    return rval;}
  static cssEl* cssElCFun_RtConstrain_ForceStop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((RtConstrain*)ths)->ForceStop();
    return rval;}
  static cssEl* cssElCFun_RtConstrain_CalcObjFunc_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((RtConstrain*)ths)->CalcObjFunc());
    return rval;}
MPESubNameSpec*		 TAI_MPESubNameSpec=NULL;
MPELimitSpec*		 TAI_MPELimitSpec=NULL;
ModelParamEntry*		 TAI_ModelParamEntry=NULL;
  static cssEl* cssElCFun_ModelParamEntry_setVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ModelParamEntry*)ths)->setVal((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ModelParamEntry_getVal_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ModelParamEntry*)ths)->getVal());
    return rval;}
taGroup<ModelParamEntry>*		 TAI_taGroup_ModelParamEntry_=NULL;
  static cssEl* cssElCFun_taGroup_ModelParamEntry__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<ModelParamEntry>*)ths)->MoveBefore((ModelParamEntry*)(void*)*arg[1], (ModelParamEntry*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taGroup<ModelParamEntry>*)ths)->MoveAfter((ModelParamEntry*)(void*)*arg[1], (ModelParamEntry*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->SafeEl((int)*arg[1]), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FastEl((int)*arg[1]), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->DefaultEl(), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->Edit_El((ModelParamEntry*)(void*)*arg[1]), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->Leaf((int)*arg[1]), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__LeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->LeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FirstEl(refarg_0), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NextEl(refarg_0), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NewEl(), 1, &TA_ModelParamEntry);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NewEl((int)*arg[1]), 1, &TA_ModelParamEntry);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_ModelParamEntry);}
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindName((const char*)*arg[1]), 1, &TA_ModelParamEntry);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_ModelParamEntry);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_ModelParamEntry);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_ModelParamEntry);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->Pop(), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->Peek(), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->AddUniqNameOld((ModelParamEntry*)(void*)*arg[1]), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->LinkUniqNameOld((ModelParamEntry*)(void*)*arg[1]), 1, &TA_ModelParamEntry);
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_ModelParamEntry);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_ModelParamEntry);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taGroup_ModelParamEntry__FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_ModelParamEntry);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taGroup<ModelParamEntry>*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_ModelParamEntry);    *arg[2]=(Int)refarg_1;
}
    return rval;}
ModelParamEntry_Group*		 TAI_ModelParamEntry_Group=NULL;

// Type Data

static MethodArgs_data TA_taRegFun_Rt_Shunting_MethArgs[]={
  {&TA_RtUnitSpec_ptr,NULL,"spec",""},
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_taRegFun_Rt_Tracking_MethArgs[]={
  {&TA_RtUnitSpec_ptr,NULL,"spec",""},
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_taRegFun_Rt_Additive_MethArgs[]={
  {&TA_RtUnitSpec_ptr,NULL,"spec",""},
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_taRegFun_Rt_Usher_Mc_MethArgs[]={
  {&TA_RtUnitSpec_ptr,NULL,"spec",""},
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_taRegFun_Rt_Cust_Script_MethArgs[]={
  {&TA_RtUnitSpec_ptr,NULL,"spec",""},
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_taRegFun_RtSetParams_MethArgs[]={
  {&TA_void_ptr,NULL,"data",""},
  {&TA_float_Array_ptr,NULL,"p",""},
  NULL};
static MethodArgs_data TA_taRegFun_RtGetParams_MethArgs[]={
  {&TA_void_ptr,NULL,"data",""},
  {&TA_float_Array_ptr,NULL,"p",""},
  NULL};
static MethodArgs_data TA_taRegFun_RtFitObjFunc_MethArgs[]={
  {&TA_void_ptr,NULL,"data",""},
  {&TA_float_Array_ptr,NULL,"p",""},
  NULL};
static MethodArgs_data TA_taRegFun_RtFitCalcGrad_MethArgs[]={
  {&TA_void_ptr,NULL,"data",""},
  {&TA_float_Array_ptr,NULL,"p",""},
  {&TA_float_Array_ptr,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taRegFun_RtSaveParams_MethArgs[]={
  {&TA_void_ptr,NULL,"data",""},
  NULL};
static MethodDef_data TA_taRegFun_MethodDef[]={
  {&TA_float,NULL,"Rt_Shunting"," Full Shunting Equations ","","RtConSpecGovEq ",
    0,2,-1,1,(ta_void_fun)(Rt_Shunting),cssElCFun_Rt_Shunting_stub,TA_taRegFun_Rt_Shunting_MethArgs},
  {&TA_float,NULL,"Rt_Tracking"," Unit follows linear sum of excit, inhib inputs only ","","RtConSpecGovEq ",
    0,2,-1,1,(ta_void_fun)(Rt_Tracking),cssElCFun_Rt_Tracking_stub,TA_taRegFun_Rt_Tracking_MethArgs},
  {&TA_float,NULL,"Rt_Additive"," Unit simply adds excitation and inhibition ","","RtConSpecGovEq ",
    0,2,-1,1,(ta_void_fun)(Rt_Additive),cssElCFun_Rt_Additive_stub,TA_taRegFun_Rt_Additive_MethArgs},
  {&TA_float,NULL,"Rt_Usher_Mc"," Usher-McClelland Equations","","RtConSpecGovEq ",
    0,2,-1,1,(ta_void_fun)(Rt_Usher_Mc),cssElCFun_Rt_Usher_Mc_stub,TA_taRegFun_Rt_Usher_Mc_MethArgs},
  {&TA_float,NULL,"Rt_Cust_Script"," User-specified script governing eqn ","","RtConSpecGovEq ",
    0,2,-1,1,(ta_void_fun)(Rt_Cust_Script),cssElCFun_Rt_Cust_Script_stub,TA_taRegFun_Rt_Cust_Script_MethArgs},
  {&TA_void,NULL,"RtSetParams","","","",
    0,2,-1,1,(ta_void_fun)(RtSetParams),cssElCFun_RtSetParams_stub,TA_taRegFun_RtSetParams_MethArgs},
  {&TA_void,NULL,"RtGetParams","","","",
    0,2,-1,1,(ta_void_fun)(RtGetParams),cssElCFun_RtGetParams_stub,TA_taRegFun_RtGetParams_MethArgs},
  {&TA_float,NULL,"RtFitObjFunc","","","",
    0,2,-1,1,(ta_void_fun)(RtFitObjFunc),cssElCFun_RtFitObjFunc_stub,TA_taRegFun_RtFitObjFunc_MethArgs},
  {&TA_void,NULL,"RtFitCalcGrad","","","",
    0,3,-1,1,(ta_void_fun)(RtFitCalcGrad),cssElCFun_RtFitCalcGrad_stub,TA_taRegFun_RtFitCalcGrad_MethArgs},
  {&TA_void,NULL,"RtSaveParams","","","",
    0,1,-1,1,(ta_void_fun)(RtSaveParams),cssElCFun_RtSaveParams_stub,TA_taRegFun_RtSaveParams_MethArgs},
  NULL};
static int RtCon::* TA_RtCon_MbrOff;
static MemberDef_data TA_RtCon_MemberDef[]={
  {&TA_float,NULL,"dwt"," Change in weight ","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_RtCon_MbrOff=(int RtCon::*)(&RtCon::dwt))),0,NULL,0},
  {&TA_float,NULL,"elig"," Eligibility trace for connection ","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_RtCon_MbrOff=(int RtCon::*)(&RtCon::elig))),0,NULL,0},
  {&TA_bool,NULL,"isClamp"," Is the weight fixed for data fitting? ","","",
    *((ta_memb_ptr*)&(TA_RtCon_MbrOff=(int RtCon::*)(&RtCon::isClamp))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtCon_Group_Compute_Net_MethArgs[]={
  {&TA_RtUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_RtCon_Group_Compute_dWt_MethArgs[]={
  {&TA_RtUnit_ptr,NULL,"ru",""},
  NULL};
static MethodDef_data TA_RtCon_Group_MethodDef[]={
  {&TA_float,NULL,"Compute_Net","","","",
    1,1,-1,0,NULL,cssElCFun_RtCon_Group_Compute_Net_stub,TA_RtCon_Group_Compute_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,1,-1,0,NULL,cssElCFun_RtCon_Group_Compute_dWt_stub,TA_RtCon_Group_Compute_dWt_MethArgs},
  NULL};
static int RtUnit::* TA_RtUnit_MbrOff;
static MemberDef_data TA_RtUnit_MemberDef[]={
  {&TA_float,NULL,"da"," delta-activation (change in activation value) ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::da))),0,NULL,0},
  {&TA_float,NULL,"net_excit"," excitatory input to unit ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_excit))),0,NULL,0},
  {&TA_float,NULL,"net_inhib"," inhibitory input to unit ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_inhib))),0,NULL,0},
  {&TA_float,NULL,"net_d1"," net dopamine D1 signal -- deprecated","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_d1))),0,NULL,0},
  {&TA_float,NULL,"net_d2"," net dopamine D2 signal -- deprecated","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_d2))),0,NULL,0},
  {&TA_float,NULL,"net_ne"," net norepinephrine signal ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_ne))),0,NULL,0},
  {&TA_float,NULL,"net_ach"," net acetylcholine signal","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_ach))),0,NULL,0},
  {&TA_float,NULL,"net_sero"," net serotonin signal","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_sero))),0,NULL,0},
  {&TA_float,NULL,"net_dopa"," net dopamine signal","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::net_dopa))),0,NULL,0},
  {&TA_float,NULL,"sum_in_wt"," sum of incoming excit. weights, for normaliz'n ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::sum_in_wt))),0,NULL,0},
  {&TA_float,NULL,"sum_out_wt"," sum of outgoing excit. weights, for normaliz'n ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::sum_out_wt))),0,NULL,0},
  {&TA_float,NULL,"prv_targ"," previous target value ","NO_VIEW HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::prv_targ))),0,NULL,0},
  {&TA_float,NULL,"prv_ext"," previous external input value ","NO_VIEW HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::prv_ext))),0,NULL,0},
  {&TA_float,NULL,"prv_act"," previous activation value ","NO_VIEW HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::prv_act))),0,NULL,0},
  {&TA_float,NULL,"act_raw"," current raw activation value ","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::act_raw))),0,NULL,0},
  {&TA_float,NULL,"prv_net"," previous net-input value ","NO_VIEW HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::prv_net))),0,NULL,0},
  {&TA_float,NULL,"habit"," habituation or xmtr depletion -- decays to zero with cell activity, returns to maximum 1.0 with cell inactivity ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::habit))),0,NULL,0},
  {&TA_float,NULL,"act_trace"," slowly-decaying, rapidly tracks maximum act ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::act_trace))),0,NULL,0},
  {&TA_bool,NULL,"isLearnEvent"," is a stochastic learning sample currently active? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::isLearnEvent))),0,NULL,0},
  {&TA_float,NULL,"lEvStart"," when did the learning event start? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::lEvStart))),0,NULL,0},
  {&TA_float_DelayBuffer,NULL,"ext_flags"," array of external_flag values ","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::ext_flags))),0,NULL,0},
  {&TA_float_DelayBuffer,NULL,"targs"," array of target values ","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::targs))),0,NULL,0},
  {&TA_float_DelayBuffer,NULL,"exts"," array of external input values ","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::exts))),0,NULL,0},
  {&TA_float_DelayBuffer,NULL,"acts"," array of activation values ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::acts))),0,NULL,0},
  {&TA_bool,NULL,"volt_clamp"," artificially clamp act at current level ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::volt_clamp))),0,NULL,0},
  {&TA_int,NULL,"max_axon_delay"," longest possible axon delay to receipients, in ticks ","","",
    *((ta_memb_ptr*)&(TA_RtUnit_MbrOff=(int RtUnit::*)(&RtUnit::max_axon_delay))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtUnit_Prep_Compute_Net_MethArgs[]={
  {&TA_float,NULL,"abs_time",""},
  NULL};
static MethodDef_data TA_RtUnit_MethodDef[]={
  {&TA_void,NULL,"Prep_Compute_Net","","","",
    0,1,-1,0,NULL,cssElCFun_RtUnit_Prep_Compute_Net_stub,TA_RtUnit_Prep_Compute_Net_MethArgs},
  {&TA_void,NULL,"StoreState","","","",
    0,0,-1,0,NULL,cssElCFun_RtUnit_StoreState_stub,NULL},
  NULL};
static int ModelParam::* TA_ModelParam_MbrOff;
static MemberDef_data TA_ModelParam_MemberDef[]={
  {&TA_int,NULL,"changeCount"," How many times param entries been edited? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_ModelParam_MbrOff=(int ModelParam::*)(&ModelParam::changeCount))),0,NULL,0},
  {&TA_int_Array,NULL,"fitIndices"," Which param entries are actively being fit? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_ModelParam_MbrOff=(int ModelParam::*)(&ModelParam::fitIndices))),0,NULL,0},
  {&TA_ModelParamEntry_Group,NULL,"paramMembers","","","",
    *((ta_memb_ptr*)&(TA_ModelParam_MbrOff=(int ModelParam::*)(&ModelParam::paramMembers))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ModelParam_findParam_MethArgs[]={
  {&TA_taString,NULL,"SpecName",""},
  {&TA_taString,NULL,"MemberName",""},
  {&TA_taString,NULL,"SubMemberName",""},
  NULL};
static MethodArgs_data TA_ModelParam_updateParamsFromObj_MethArgs[]={
  {&TA_taString,NULL,"SpecName",""},
  {&TA_taString,NULL,"MemberName",""},
  {&TA_taString,NULL,"SubMemberName",""},
  {&TA_float_ptr,NULL,"pval",""},
  {&TA_bool,NULL,"isDefaultParam",""},
  NULL};
static MethodArgs_data TA_ModelParam_updateParamList_impl_MethArgs[]={
  {&TA_BaseSpec_MGroup_ptr,NULL,"source",""},
  NULL};
static MethodArgs_data TA_ModelParam_updateParamsFromSpec_MethArgs[]={
  {&TA_TAPtr,NULL,"aSpec",""},
  NULL};
static MethodDef_data TA_ModelParam_MethodDef[]={
  {&TA_ModelParamEntry_ptr,NULL,"findParam","","","",
    0,3,-1,0,NULL,cssElCFun_ModelParam_findParam_stub,TA_ModelParam_findParam_MethArgs},
  {&TA_void,NULL,"updateParamsFromObj","","","",
    0,5,-1,0,NULL,cssElCFun_ModelParam_updateParamsFromObj_stub,TA_ModelParam_updateParamsFromObj_MethArgs},
  {&TA_void,NULL,"updateParamList"," gets parameter list from specs ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_ModelParam_updateParamList_stub,NULL},
  {&TA_void,NULL,"updateParamList_impl","","","",
    0,1,-1,0,NULL,cssElCFun_ModelParam_updateParamList_impl_stub,TA_ModelParam_updateParamList_impl_MethArgs},
  {&TA_void,NULL,"updateParamsFromSpec","","","",
    0,1,-1,0,NULL,cssElCFun_ModelParam_updateParamsFromSpec_stub,TA_ModelParam_updateParamsFromSpec_MethArgs},
  NULL};
static int RtUnitSpec::* TA_RtUnitSpec_MbrOff;
static MemberDef_data TA_RtUnitSpec_MemberDef[]={
  {&TA_float,NULL,"govern_eq"," ","","RtConSpecGovEq ",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::govern_eq))),0,NULL,1},
  {&TA_Script,NULL,"custGovEq"," Script for custom objective function -- script should find RtUnitSpec *spec = *owner; access unit as spec->custom_script_u; then set spec->custom_script_da = return value of the equation.","CONDEDIT_ON_govern_eq:Rt_Cust_Script ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::custGovEq))),0,NULL,0},
  {&TA_RtUnit_ptr,NULL,"custom_script_u"," only used with script governing eqn to hold reference to current RtUnit","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::custom_script_u))),0,NULL,0},
  {&TA_float,NULL,"custom_script_da"," only used with script governing eqn's to hold return values.","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::custom_script_da))),0,NULL,0},
  {&TA_ActInfo,NULL,"gov"," governing equation parameters ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::gov))),0,NULL,0},
  {&TA_RecExcInfo,NULL,"rec_excit"," recurrent excitation parameters ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::rec_excit))),0,NULL,0},
  {&TA_NMDAInfo,NULL,"nmda"," NMDA receptors","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::nmda))),0,NULL,0},
  {&TA_NeuroModInfo,NULL,"dopa"," Dopamine ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::dopa))),0,NULL,0},
  {&TA_NeuroModInfo,NULL,"ne"," Norepinephrine ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::ne))),0,NULL,0},
  {&TA_NeuroModInfo,NULL,"ach"," Acetylcholine ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::ach))),0,NULL,0},
  {&TA_NeuroModInfo,NULL,"sero"," Serotonin ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::sero))),0,NULL,0},
  {&TA_ActTraceInfo,NULL,"act_trace"," Keeps a slowly-decaying trace of max cell activity ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::act_trace))),0,NULL,0},
  {&TA_HabitInfo,NULL,"habit"," Habituation -- internal var decays with activity ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::habit))),0,NULL,0},
  {&TA_SoftClampInfo,NULL,"softclamp"," If external input is soft-clamped ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::softclamp))),0,NULL,0},
  {&TA_NormInfo,NULL,"wt_norm"," whether to normalize *excitatory* input and output weights ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::wt_norm))),0,NULL,0},
  {&TA_bool,NULL,"useDA_NMDA_gain"," DA potentiates NMDA? ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::useDA_NMDA_gain))),0,NULL,0},
  {&TA_float,NULL,"DA_NMDA_gain"," multiplicative effect of DA on NMDA gain ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::DA_NMDA_gain))),0,NULL,0},
  {&TA_float,NULL,"D2_inhib_habit_thresh"," If (1-habit) > this thresh, then inhibit cell (rect thresh) ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::D2_inhib_habit_thresh))),0,NULL,0},
  {&TA_float,NULL,"D2_inhib_habit_gain"," If (1-habit) > above thresh, then inhibit cell (rect thresh) with this gain ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::D2_inhib_habit_gain))),0,NULL,0},
  {&TA_Random,NULL,"initial_act"," initial activation value ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::initial_act))),0,NULL,0},
  {&TA_bool,NULL,"legacy_norm"," should set to false unless doing so breaks old sims ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::legacy_norm))),0,NULL,0},
  {&TA_bool,NULL,"addNoise"," Should add noise to state var? ","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::addNoise))),0,NULL,0},
  {&TA_Random,NULL,"noise"," what kind of noise to add to activations ","CONDEDIT_ON_addNoise:true ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::noise))),0,NULL,0},
  {&TA_float,NULL,"sqrt_dt"," square-root of dt for noise ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::sqrt_dt))),0,NULL,0},
  {&TA_float,NULL,"dt"," set by RtTrial::Run() grain of time computing on (must be in [0..1] range) ","READ_ONLY HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::dt))),0,NULL,0},
  {&TA_RandLearnInfoSpec,NULL,"samp_learn"," supports learning representations by stochastic sampling of input ","INLINE ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::samp_learn))),0,NULL,0},
  {&TA_SpikeInfo,NULL,"Spiking"," Can set cells to spike instead of rate coding","","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::Spiking))),0,NULL,0},
  {&TA_VectAssocMapInfo,NULL,"VectorMap"," Makes cells selective for only a specific intensity range of net_excit ","INLINE ","",
    *((ta_memb_ptr*)&(TA_RtUnitSpec_MbrOff=(int RtUnitSpec::*)(&RtUnitSpec::VectorMap))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_RtUnitSpec_Compute_Net_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_RtUnitSpec_Compute_Act_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_RtUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_RtUnitSpec_Prep_Compute_Net_MethArgs[]={
  {&TA_RtUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"abs_time",""},
  NULL};
static MethodArgs_data TA_RtUnitSpec_Compute_Wt_Norm_MethArgs[]={
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_RtUnitSpec_Compute_Act_impl_MethArgs[]={
  {&TA_RtUnit_ptr,NULL,"u",""},
  NULL};
static MethodDef_data TA_RtUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    1,1,-1,0,NULL,cssElCFun_RtUnitSpec_InitState_stub,TA_RtUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_Net","","","",
    1,1,-1,0,NULL,cssElCFun_RtUnitSpec_Compute_Net_stub,TA_RtUnitSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act","","","",
    1,1,-1,0,NULL,cssElCFun_RtUnitSpec_Compute_Act_stub,TA_RtUnitSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    1,1,-1,0,NULL,cssElCFun_RtUnitSpec_Compute_dWt_stub,TA_RtUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Prep_Compute_Net"," Initialize state of net b4 iter ","","",
    0,2,-1,0,NULL,cssElCFun_RtUnitSpec_Prep_Compute_Net_stub,TA_RtUnitSpec_Prep_Compute_Net_MethArgs},
  {&TA_void,NULL,"Compute_Wt_Norm","","","",
    0,1,-1,0,NULL,cssElCFun_RtUnitSpec_Compute_Wt_Norm_stub,TA_RtUnitSpec_Compute_Wt_Norm_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl","","","",
    0,1,-1,0,NULL,cssElCFun_RtUnitSpec_Compute_Act_impl_stub,TA_RtUnitSpec_Compute_Act_impl_MethArgs},
  NULL};
static int RtTrial::* TA_RtTrial_MbrOff;
static MemberDef_data TA_RtTrial_MemberDef[]={
  {&TA_bool,NULL,"responseMade"," did an output unit exceed threshold? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::responseMade))),0,NULL,0},
  {&TA_bool,NULL,"responseCorrect"," whether unit over threshold was correct ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::responseCorrect))),0,NULL,0},
  {&TA_float,NULL,"responseTime"," response time in task ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::responseTime))),0,NULL,0},
  {&TA_bool,NULL,"rewardIfCorrect"," whether to reward if response correct ","","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::rewardIfCorrect))),0,NULL,0},
  {&TA_bool,NULL,"trialEnded"," stop looping? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::trialEnded))),0,NULL,0},
  {&TA_bool,NULL,"useFixedWts"," whether to substitute fixed weights for computing network -- this is for constraint fitting ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::useFixedWts))),0,NULL,0},
  {&TA_float,NULL,"abs_time"," absolute time ","","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::abs_time))),0,NULL,0},
  {&TA_float,NULL,"trial_time"," relative to start of trial ","","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::trial_time))),0,NULL,0},
  {&TA_float,NULL,"dt"," each 'cycle' corresponds to dt (in seconds) ","","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::dt))),0,NULL,0},
  {&TA_bool,NULL,"legacy_ignore_dt"," should be set to true, i.e. governing eqns updates are mult'd by dt -- only set to false if necessary to avoid breaking old legacy simulations that were built with false ","","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::legacy_ignore_dt))),0,NULL,0},
  {&TA_int,NULL,"update_period_ticks"," update display after how many cycles? ","","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::update_period_ticks))),0,NULL,0},
  {&TA_int,NULL,"update_countdown"," how many cycles till update? ","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtTrial_MbrOff=(int RtTrial::*)(&RtTrial::update_countdown))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtTrial_GenCntrLog_MethArgs[]={
  {&TA_LogData_ptr,NULL,"ld",""},
  {&TA_bool,NULL,"gen",""},
  NULL};
static MethodArgs_data TA_RtTrial_setFixedWts_MethArgs[]={
  {&TA_bool,NULL,"isFixed",""},
  NULL};
static MethodArgs_data TA_RtTrial_UpdateDt_MethArgs[]={
  {&TA_BaseSpec_MGroup_ptr,NULL,"specs",""},
  NULL};
static MethodArgs_data TA_RtTrial_GetUnitBufSize_MethArgs[]={
  {&TA_bool,NULL,"in_updt_after"," 0"},
  NULL};
static MethodDef_data TA_RtTrial_MethodDef[]={
  {&TA_void,NULL,"GenCntrLog"," generate log data for the counters","","",
    1,2,-1,0,NULL,cssElCFun_RtTrial_GenCntrLog_stub,TA_RtTrial_GenCntrLog_MethArgs},
  {&TA_void,NULL,"setFixedWts","","","",
    0,1,-1,0,NULL,cssElCFun_RtTrial_setFixedWts_stub,TA_RtTrial_setFixedWts_MethArgs},
  {&TA_void,NULL,"fixWts"," for constraint fitting ","","",
    0,0,-1,0,NULL,cssElCFun_RtTrial_fixWts_stub,NULL},
  {&TA_void,NULL,"unclampWts"," for normal running ","","",
    0,0,-1,0,NULL,cssElCFun_RtTrial_unclampWts_stub,NULL},
  {&TA_void,NULL,"UpdateDt"," virtual void	Compute_dWt(); //Is this necessary??? ","","",
    0,1,-1,0,NULL,cssElCFun_RtTrial_UpdateDt_stub,TA_RtTrial_UpdateDt_MethArgs},
  {&TA_void,NULL,"Prep_Compute_Net","","","",
    0,0,-1,0,NULL,cssElCFun_RtTrial_Prep_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Compute_Act","","","",
    0,0,-1,0,NULL,cssElCFun_RtTrial_Compute_Act_stub,NULL},
  {&TA_void,NULL,"Compute_Wt_Norm","","","",
    0,0,-1,0,NULL,cssElCFun_RtTrial_Compute_Wt_Norm_stub,NULL},
  {&TA_void,NULL,"StoreState"," store current state of network in buffers ","","",
    0,0,-1,0,NULL,cssElCFun_RtTrial_StoreState_stub,NULL},
  {&TA_int,NULL,"GetUnitBufSize"," finds first unit in first layer and gets current buffer size of that unit ","","",
    0,1,0,0,NULL,cssElCFun_RtTrial_GetUnitBufSize_stub,TA_RtTrial_GetUnitBufSize_MethArgs},
  NULL};
static int float_DelayBuffer::* TA_float_DelayBuffer_MbrOff;
static MemberDef_data TA_float_DelayBuffer_MemberDef[]={
  {&TA_int,NULL,"head"," JWB -- most recent datum index ","","",
    *((ta_memb_ptr*)&(TA_float_DelayBuffer_MbrOff=(int float_DelayBuffer::*)(&float_DelayBuffer::head))),0,NULL,0},
  {&TA_int,NULL,"max_len"," JWB -- longest lag ","","",
    *((ta_memb_ptr*)&(TA_float_DelayBuffer_MbrOff=(int float_DelayBuffer::*)(&float_DelayBuffer::max_len))),0,NULL,0},
  NULL};
static MethodArgs_data TA_float_DelayBuffer_SetSize_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_float_DelayBuffer_PushHead_MethArgs[]={
  {&TA_const_float_ref,NULL,"item",""},
  NULL};
static MethodArgs_data TA_float_DelayBuffer_ReadDelayed_MethArgs[]={
  {&TA_int,NULL,"aDelay",""},
  NULL};
static MethodDef_data TA_float_DelayBuffer_MethodDef[]={
  {&TA_void,NULL,"SetSize","","","",
    0,1,-1,0,NULL,cssElCFun_float_DelayBuffer_SetSize_stub,TA_float_DelayBuffer_SetSize_MethArgs},
  {&TA_void,NULL,"PushHead"," JWB ","","",
    0,1,-1,0,NULL,cssElCFun_float_DelayBuffer_PushHead_stub,TA_float_DelayBuffer_PushHead_MethArgs},
  {&TA_float,NULL,"ReadDelayed","","","",
    0,1,-1,0,NULL,cssElCFun_float_DelayBuffer_ReadDelayed_stub,TA_float_DelayBuffer_ReadDelayed_MethArgs},
  NULL};
static int RtEvent::* TA_RtEvent_MbrOff;
static MemberDef_data TA_RtEvent_MemberDef[]={
  {&TA_NextEventInfo_ptr,NULL,"nextEventInfo"," ","FROM_GROUP_nei_mirror ","",
    *((ta_memb_ptr*)&(TA_RtEvent_MbrOff=(int RtEvent::*)(&RtEvent::nextEventInfo))),0,NULL,0},
  {&TA_NextEventInfo_Group_ptr,NULL,"nei_mirror"," mirrors spec eventTransitions ","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtEvent_MbrOff=(int RtEvent::*)(&RtEvent::nei_mirror))),0,NULL,0},
  {&TA_bool,NULL,"isConstraint"," mirros spec isConstraint ","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtEvent_MbrOff=(int RtEvent::*)(&RtEvent::isConstraint))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtEvent_getNextEvent_MethArgs[]={
  {&TA_bool,NULL,"isCorrect",""},
  NULL};
static MethodDef_data TA_RtEvent_MethodDef[]={
  {&TA_RtEvent_ptr,NULL,"getNextEvent","","","",
    0,1,-1,0,NULL,cssElCFun_RtEvent_getNextEvent_stub,TA_RtEvent_getNextEvent_MethArgs},
  NULL};
static int NeuroModInfo::* TA_NeuroModInfo_MbrOff;
static MemberDef_data TA_NeuroModInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," Will this be applied? ","","",
    *((ta_memb_ptr*)&(TA_NeuroModInfo_MbrOff=(int NeuroModInfo::*)(&NeuroModInfo::used))),0,NULL,0},
  {&TA_float,NULL,"ex_wt"," multiply signal by this wt and add as excitation ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_NeuroModInfo_MbrOff=(int NeuroModInfo::*)(&NeuroModInfo::ex_wt))),0,NULL,0},
  {&TA_float,NULL,"ex_mult"," multiply net_excit by (1+ex_mult*signal)","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_NeuroModInfo_MbrOff=(int NeuroModInfo::*)(&NeuroModInfo::ex_mult))),0,NULL,0},
  {&TA_float,NULL,"inh_wt"," multiply signal by this wt and add as inhibition ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_NeuroModInfo_MbrOff=(int NeuroModInfo::*)(&NeuroModInfo::inh_wt))),0,NULL,0},
  {&TA_float,NULL,"inh_mult"," multiply net_inhib by (1+inh_mult*signal) ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_NeuroModInfo_MbrOff=(int NeuroModInfo::*)(&NeuroModInfo::inh_mult))),0,NULL,0},
  NULL};
static int NMDAInfo::* TA_NMDAInfo_MbrOff;
static MemberDef_data TA_NMDAInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," Compute NMDA effects? ","","",
    *((ta_memb_ptr*)&(TA_NMDAInfo_MbrOff=(int NMDAInfo::*)(&NMDAInfo::used))),0,NULL,0},
  {&TA_float,NULL,"NMDA_gain"," multiply net_excit by this if act above thresh ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_NMDAInfo_MbrOff=(int NMDAInfo::*)(&NMDAInfo::NMDA_gain))),0,NULL,0},
  {&TA_float,NULL,"NMDA_thresh"," act threshold for NMDA gain ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_NMDAInfo_MbrOff=(int NMDAInfo::*)(&NMDAInfo::NMDA_thresh))),0,NULL,0},
  NULL};
static int HabitInfo::* TA_HabitInfo_MbrOff;
static MemberDef_data TA_HabitInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," Will this be applied? ","","",
    *((ta_memb_ptr*)&(TA_HabitInfo_MbrOff=(int HabitInfo::*)(&HabitInfo::used))),0,NULL,0},
  {&TA_float,NULL,"rate"," rate of habituation ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_HabitInfo_MbrOff=(int HabitInfo::*)(&HabitInfo::rate))),0,NULL,0},
  {&TA_bool,NULL,"time_const"," overall rate of habituation,recovery ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_HabitInfo_MbrOff=(int HabitInfo::*)(&HabitInfo::time_const))),0,NULL,0},
  {&TA_float,NULL,"thresh"," activity must exceed thresh to initiate habituation ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_HabitInfo_MbrOff=(int HabitInfo::*)(&HabitInfo::thresh))),0,NULL,0},
  NULL};
static int ActInfo::* TA_ActInfo_MbrOff;
static MemberDef_data TA_ActInfo_MemberDef[]={
  {&TA_float,NULL,"time_const"," overall rate of change ","","",
    *((ta_memb_ptr*)&(TA_ActInfo_MbrOff=(int ActInfo::*)(&ActInfo::time_const))),0,NULL,0},
  {&TA_float,NULL,"pass_decay"," rate of passive decay","","",
    *((ta_memb_ptr*)&(TA_ActInfo_MbrOff=(int ActInfo::*)(&ActInfo::pass_decay))),0,NULL,0},
  {&TA_float,NULL,"bias_excit"," bias excitation signal","","",
    *((ta_memb_ptr*)&(TA_ActInfo_MbrOff=(int ActInfo::*)(&ActInfo::bias_excit))),0,NULL,0},
  {&TA_float,NULL,"hyperpol"," lower asymptote (for shunting equation) ","","",
    *((ta_memb_ptr*)&(TA_ActInfo_MbrOff=(int ActInfo::*)(&ActInfo::hyperpol))),0,NULL,0},
  NULL};
static int ActTraceInfo::* TA_ActTraceInfo_MbrOff;
static MemberDef_data TA_ActTraceInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," Will activity trace be computed?","","",
    *((ta_memb_ptr*)&(TA_ActTraceInfo_MbrOff=(int ActTraceInfo::*)(&ActTraceInfo::used))),0,NULL,0},
  {&TA_float,NULL,"rise_rate"," how quickly does trace rise?","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_ActTraceInfo_MbrOff=(int ActTraceInfo::*)(&ActTraceInfo::rise_rate))),0,NULL,0},
  {&TA_float,NULL,"decay_rate"," how quickly does trace decay?","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_ActTraceInfo_MbrOff=(int ActTraceInfo::*)(&ActTraceInfo::decay_rate))),0,NULL,0},
  NULL};
static EnumDef_data TA_RecExcInfo_RecurExcitType[]={
  {"NONE"," No recurrent excitation ","",0},
  {"LINEAR"," f(x) = n*(x-a) if (x-a > 0), else 0 ","",1},
  {"STEP"," f(x) = n if (x >= a), else 0 ","",2},
  {"SQUELCH"," f(x) = nx if (x >=a), else 0 ","",3},
  {"XSQUARED"," f(x) = nx^2 ","",4},
  {"SIGMOID"," f(x) = x^n/(x^n+a^n) ","",5},
  NULL};
static int RecExcInfo::* TA_RecExcInfo_MbrOff;
static MemberDef_data TA_RecExcInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," Compute recurrent excitation term?","","",
    *((ta_memb_ptr*)&(TA_RecExcInfo_MbrOff=(int RecExcInfo::*)(&RecExcInfo::used))),0,NULL,0},
  {NULL,"::RecurExcitType","type"," ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_RecExcInfo_MbrOff=(int RecExcInfo::*)(&RecExcInfo::type))),0,NULL,0},
  {&TA_float,NULL,"n"," gain","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_RecExcInfo_MbrOff=(int RecExcInfo::*)(&RecExcInfo::n))),0,NULL,0},
  {&TA_float,NULL,"a"," level","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_RecExcInfo_MbrOff=(int RecExcInfo::*)(&RecExcInfo::a))),0,NULL,0},
  {&TA_float,NULL,"wt"," strength of recurrent excitation","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_RecExcInfo_MbrOff=(int RecExcInfo::*)(&RecExcInfo::wt))),0,NULL,0},
  {&TA_float,NULL,"re_a_pow_n"," a^n, for recur_excit sigmoid ","HIDDEN READONLY ","",
    *((ta_memb_ptr*)&(TA_RecExcInfo_MbrOff=(int RecExcInfo::*)(&RecExcInfo::re_a_pow_n))),0,NULL,0},
  NULL};
static int SoftClampInfo::* TA_SoftClampInfo_MbrOff;
static MemberDef_data TA_SoftClampInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," Should input be soft-clamped?","","",
    *((ta_memb_ptr*)&(TA_SoftClampInfo_MbrOff=(int SoftClampInfo::*)(&SoftClampInfo::used))),0,NULL,0},
  {&TA_float,NULL,"gain"," wt of external input if soft-clamped ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_SoftClampInfo_MbrOff=(int SoftClampInfo::*)(&SoftClampInfo::gain))),0,NULL,0},
  NULL};
static int NormInfo::* TA_NormInfo_MbrOff;
static MemberDef_data TA_NormInfo_MemberDef[]={
  {&TA_bool,NULL,"input"," Normalize input weights to a unit?","","",
    *((ta_memb_ptr*)&(TA_NormInfo_MbrOff=(int NormInfo::*)(&NormInfo::input))),0,NULL,0},
  {&TA_bool,NULL,"output"," Normalize output weights from a unit?","","",
    *((ta_memb_ptr*)&(TA_NormInfo_MbrOff=(int NormInfo::*)(&NormInfo::output))),0,NULL,0},
  NULL};
static int SpikeInfo::* TA_SpikeInfo_MbrOff;
static MemberDef_data TA_SpikeInfo_MemberDef[]={
  {&TA_bool,NULL,"doIntAndFire"," Should cells do integrate-and-fire?","","",
    *((ta_memb_ptr*)&(TA_SpikeInfo_MbrOff=(int SpikeInfo::*)(&SpikeInfo::doIntAndFire))),0,NULL,0},
  {&TA_float,NULL,"iafThresh"," act threshold for spike","CONDEDIT_ON_doIntAndFire:true ","",
    *((ta_memb_ptr*)&(TA_SpikeInfo_MbrOff=(int SpikeInfo::*)(&SpikeInfo::iafThresh))),0,NULL,0},
  NULL};
static int RandLearnInfoSpec::* TA_RandLearnInfoSpec_MbrOff;
static MemberDef_data TA_RandLearnInfoSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," Should RtUnit sample input stochastically to learn? ","","",
    *((ta_memb_ptr*)&(TA_RandLearnInfoSpec_MbrOff=(int RandLearnInfoSpec::*)(&RandLearnInfoSpec::on))),0,NULL,0},
  {&TA_float,NULL,"prob"," Probability of learning event per cell per second? (e.g. 0.01) ","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_RandLearnInfoSpec_MbrOff=(int RandLearnInfoSpec::*)(&RandLearnInfoSpec::prob))),0,NULL,0},
  {&TA_float,NULL,"dur"," duration of sampling in seconds ","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_RandLearnInfoSpec_MbrOff=(int RandLearnInfoSpec::*)(&RandLearnInfoSpec::dur))),0,NULL,0},
  {&TA_float,NULL,"dpost_l"," How much to lower postsynaptic learning threshold? ","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_RandLearnInfoSpec_MbrOff=(int RandLearnInfoSpec::*)(&RandLearnInfoSpec::dpost_l))),0,NULL,0},
  NULL};
static int VectAssocMapInfo::* TA_VectAssocMapInfo_MbrOff;
static MemberDef_data TA_VectAssocMapInfo_MemberDef[]={
  {&TA_bool,NULL,"active"," Should the unit be selective for a certain intensity range? ","","",
    *((ta_memb_ptr*)&(TA_VectAssocMapInfo_MbrOff=(int VectAssocMapInfo::*)(&VectAssocMapInfo::active))),0,NULL,0},
  {&TA_float,NULL,"peak"," what net_excit to respond to maximally? ","CONDEDIT_ON_active:true ","",
    *((ta_memb_ptr*)&(TA_VectAssocMapInfo_MbrOff=(int VectAssocMapInfo::*)(&VectAssocMapInfo::peak))),0,NULL,0},
  {&TA_float,NULL,"hwidth"," half width of the tuning curve ","CONDEDIT_ON_active:true ","",
    *((ta_memb_ptr*)&(TA_VectAssocMapInfo_MbrOff=(int VectAssocMapInfo::*)(&VectAssocMapInfo::hwidth))),0,NULL,0},
  {&TA_float,NULL,"gain"," how strongly cell responds to input in range ","CONDEDIT_ON_active:true ","",
    *((ta_memb_ptr*)&(TA_VectAssocMapInfo_MbrOff=(int VectAssocMapInfo::*)(&VectAssocMapInfo::gain))),0,NULL,0},
  NULL};
static EnumDef_data TA_SigFuncInfo_SigFuncType[]={
  {"RECT"," subtract threshold, and set floor at zero ","",0},
  {"SQUELCH"," set input to zero if below threshold, else no change ","",1},
  NULL};
static int SigFuncInfo::* TA_SigFuncInfo_MbrOff;
static MemberDef_data TA_SigFuncInfo_MemberDef[]={
  {NULL,"::SigFuncType","sig_type"," What is the nature of the signal function?","","",
    *((ta_memb_ptr*)&(TA_SigFuncInfo_MbrOff=(int SigFuncInfo::*)(&SigFuncInfo::sig_type))),0,NULL,0},
  {&TA_float,NULL,"thresh"," threshold of presynaptic activity; meaning depends on sig_type","","",
    *((ta_memb_ptr*)&(TA_SigFuncInfo_MbrOff=(int SigFuncInfo::*)(&SigFuncInfo::thresh))),0,NULL,0},
  NULL};
static EnumDef_data TA_EligTraceInfo_EligType[]={
  {"TRACK_ONE"," The eligibility trace rises to one, regardless of pre*post ","",0},
  {"TRACK_ONE_RAW_PRESYN"," use raw, not cooked presynaptic activity ","",1},
  {"SBA_ELIG"," Use Sutton, Barto, Anderson, eqn, which tracks pre*post ","",2},
  NULL};
static int EligTraceInfo::* TA_EligTraceInfo_MbrOff;
static MemberDef_data TA_EligTraceInfo_MemberDef[]={
  {&TA_bool,NULL,"used"," is eligibility trace computed?","","",
    *((ta_memb_ptr*)&(TA_EligTraceInfo_MbrOff=(int EligTraceInfo::*)(&EligTraceInfo::used))),0,NULL,0},
  {NULL,"::EligType","elig_type"," Eligibility trace law ","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_EligTraceInfo_MbrOff=(int EligTraceInfo::*)(&EligTraceInfo::elig_type))),0,NULL,0},
  {&TA_float,NULL,"rise"," rate of eligibility increase","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_EligTraceInfo_MbrOff=(int EligTraceInfo::*)(&EligTraceInfo::rise))),0,NULL,0},
  {&TA_float,NULL,"decay"," rate of eligibility decrease","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_EligTraceInfo_MbrOff=(int EligTraceInfo::*)(&EligTraceInfo::decay))),0,NULL,0},
  {&TA_float,NULL,"inhib"," rate of eligibility decrease due to inhibitory input","CONDEDIT_ON_used:true ","",
    *((ta_memb_ptr*)&(TA_EligTraceInfo_MbrOff=(int EligTraceInfo::*)(&EligTraceInfo::inhib))),0,NULL,0},
  NULL};
static EnumDef_data TA_ModLearnInfo_TermType[]={
  {"PRExPOST"," product of pre- and post-synaptic activity","",0},
  {"PRE_ONLY"," equal to pre-synaptic activity","",1},
  {"POST_ONLY"," equal to post-synaptic activity","",2},
  {"ELIG"," equal to synaptic eligibility","",3},
  {"ONE"," equal to unity","",4},
  NULL};
static EnumDef_data TA_ModLearnInfo_NMODType[]={
  {"NONE"," Do not use neuromodulator gating","",0},
  {"DOPA"," Dopamine","",1},
  {"SERO"," Serotonin","",2},
  {"ACH"," Acetylcholine","",3},
  {"NE"," Norepinephrine","",4},
  NULL};
static EnumDef_data TA_ModLearnInfo_aboveBelow[]={
  {"ABOVE","","",0},
  {"BELOW","","",1},
  NULL};
static int ModLearnInfo::* TA_ModLearnInfo_MbrOff;
static MemberDef_data TA_ModLearnInfo_MemberDef[]={
  {&TA_float,NULL,"lim"," What is the upper or lower bound?","","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::lim))),0,NULL,0},
  {NULL,"::TermType","lx"," Is the bound modulated (multiplied by term)?","","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::lx))),0,NULL,0},
  {&TA_float,NULL,"rate"," How fast does synaptic wt approach bound?","","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::rate))),0,NULL,0},
  {NULL,"::TermType","rx"," Is the rate modulated (multiplied by term)?","","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::rx))),0,NULL,0},
  {NULL,"::NMODType","allX"," Should learning be gated by a neuromodulator?","","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::allX))),0,NULL,0},
  {NULL,"::aboveBelow","_"," Only allow learning if neuromodulator above or below level?","CONDEDIT_OFF_allX:NONE ","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::_))),0,NULL,0},
  {&TA_float,NULL,"val"," Learning rate multiplied by quantity above or below val","CONDEDIT_OFF_allX:NONE ","",
    *((ta_memb_ptr*)&(TA_ModLearnInfo_MbrOff=(int ModLearnInfo::*)(&ModLearnInfo::val))),0,NULL,0},
  NULL};
static int ModLearnDecayInfo::* TA_ModLearnDecayInfo_MbrOff;
static MemberDef_data TA_ModLearnDecayInfo_MemberDef[]={
  {&TA_bool,NULL,"on"," should weights decay passively?","","",
    *((ta_memb_ptr*)&(TA_ModLearnDecayInfo_MbrOff=(int ModLearnDecayInfo::*)(&ModLearnDecayInfo::on))),0,NULL,0},
  {&TA_float,NULL,"rate"," if so, at what rate?","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_ModLearnDecayInfo_MbrOff=(int ModLearnDecayInfo::*)(&ModLearnDecayInfo::rate))),0,NULL,0},
  {&TA_float,NULL,"baseline"," and toward what baseline?","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_ModLearnDecayInfo_MbrOff=(int ModLearnDecayInfo::*)(&ModLearnDecayInfo::baseline))),0,NULL,0},
  NULL};
static int ExcludeNormInfo::* TA_ExcludeNormInfo_MbrOff;
static MemberDef_data TA_ExcludeNormInfo_MemberDef[]={
  {&TA_bool,NULL,"rwt"," should this connection be excluded from input normalization of postsynaptic weights?","","",
    *((ta_memb_ptr*)&(TA_ExcludeNormInfo_MbrOff=(int ExcludeNormInfo::*)(&ExcludeNormInfo::rwt))),0,NULL,0},
  {&TA_bool,NULL,"swt"," should this connection be excluded from output normalization of presynaptic weights?","","",
    *((ta_memb_ptr*)&(TA_ExcludeNormInfo_MbrOff=(int ExcludeNormInfo::*)(&ExcludeNormInfo::swt))),0,NULL,0},
  NULL};
static EnumDef_data TA_RtConSpec_ConType[]={
  {"UNUSED"," Connection has no effect ","",0},
  {"EXCIT"," Pure (Glut-ergic) excitation ","",1},
  {"INHIB"," Pure (GABA-ergic) inhibition ","",2},
  {"D1"," Dopaminergic signal, acts on postsynaptic D1 receptor ","",3},
  {"D2"," Dopaminergic signal, acts on postsynaptic D2 receptor ","",4},
  {"NE"," Noradrenergic signal","",5},
  {"DOPA"," Dopamine signal","",6},
  {"SERO"," Serotonin signal","",7},
  {"ACH"," Acetylcholine signal","",8},
  NULL};
static EnumDef_data TA_RtConSpec_LearningLaw[]={
  {"NO_LEARNING"," Fixed connection, no learning ","",0},
  {"POST_GATE"," Postsynaptically-gated Hebbian: dw = lrate*post*(pre-w) ","",1},
  {"PRE_GATE"," Presynaptically-gated Hebbian: dw = lrate*pre*(post-w) ","",2},
  {"D1_POST_GATE","","",3},
  {"D2_POST_GATE","","",4},
  {"D1_PRE_GATE","","",5},
  {"D2_PRE_GATE","","",6},
  {"HEBB_DECAY"," Ungated Hebb learning with decay: dw = lrate*pre*post -pass_wt_decay.rate(baseline-w)","",7},
  {"DA_POST_GATE","","",8},
  {"DA_LEARN_REP","","",9},
  {"DA_LEARN_REP2","","",10},
  {"DA_LEARN_REP_IH","","",11},
  {"DA_POST_GATE_AT","","",12},
  {"MODULAR"," use modular equation design-- LTP & LTD fields","",98},
  {"SCRIPT"," uses custom learning law script -- script should get RtConSpec *spec = *owner; use spec->curRu,curSu,curCn; then pass dwt to spec->curDwt","",99},
  NULL};
static int RtConSpec::* TA_RtConSpec_MbrOff;
static MemberDef_data TA_RtConSpec_MemberDef[]={
  {NULL,"::ConType","con_type","","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::con_type))),0,NULL,0},
  {&TA_SigFuncInfo,NULL,"signal_func"," How are signals from the presynaptic cell transformed? ","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::signal_func))),0,NULL,0},
  {&TA_float,NULL,"wt_gain"," fixed multiplier of connection weights","DEFAULT_PARAM ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::wt_gain))),0,NULL,0},
  {&TA_float,NULL,"synapse_sat"," Maximum activation of any one synapse","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::synapse_sat))),0,NULL,0},
  {&TA_float,NULL,"axon_delay"," axonal delay, in seconds","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::axon_delay))),0,NULL,0},
  {NULL,"::LearningLaw","learning_law"," CustLearnLaw if learning_law == SCRIPT","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::learning_law))),0,NULL,0},
  {&TA_Script,NULL,"CustLearnLaw"," if custom learning law script desired","CONDEDIT_ON_learning_law:SCRIPT ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::CustLearnLaw))),0,NULL,0},
  {&TA_float,NULL,"lrate"," learning rate ","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::lrate))),0,NULL,0},
  {&TA_ModLearnInfo,NULL,"LTP"," Controls rate of wt INCREASE","CONDEDIT_ON_learning_law:MODULAR ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::LTP))),0,NULL,0},
  {&TA_ModLearnInfo,NULL,"LTD"," Controls rate of wt DECREASE","CONDEDIT_ON_learning_law:MODULAR ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::LTD))),0,NULL,0},
  {&TA_ModLearnDecayInfo,NULL,"pass_wt_decay"," Controls rate of wt PASSIVE DECAY","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::pass_wt_decay))),0,NULL,0},
  {&TA_float,NULL,"post_lthresh"," Threshold of postsynaptic activity for learning; can be lowered temporarily by samp_learn dpost_l","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::post_lthresh))),0,NULL,0},
  {&TA_EligTraceInfo,NULL,"elig_trace"," governs eligibility traces","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::elig_trace))),0,NULL,0},
  {&TA_ExcludeNormInfo,NULL,"exclude_norm"," keeps weights from being included in normalization","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::exclude_norm))),0,NULL,0},
  {&TA_int,NULL,"delay"," delay between cell & axon terminal, in ticks, calculated from dt and axon_delay","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::delay))),0,NULL,0},
  {&TA_float,NULL,"dt"," set by and from RtTrial::Run() ","READ_ONLY HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::dt))),0,NULL,0},
  {&TA_RtCon_ptr,NULL,"curCon"," used only to pass con to script learning law","HIDDEN READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::curCon))),0,NULL,0},
  {&TA_RtUnit_ptr,NULL,"curSu"," used only to pass su to script learning law","HIDDEN READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::curSu))),0,NULL,0},
  {&TA_RtUnit_ptr,NULL,"curRu"," used only to pass ru to script learning law","HIDDEN READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::curRu))),0,NULL,0},
  {&TA_float,NULL,"curDwt"," used only to receive dwt from script learning law","HIDDEN READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::curDwt))),0,NULL,0},
  {&TA_bool,NULL,"habit_post_learn"," use habituation of postsynaptic eligibility? (also need to turn on calculation of postsynaptic unit habituation) ","","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::habit_post_learn))),0,NULL,0},
  {&TA_float,NULL,"d2n_dw"," for DA_LEARN_REP -- how strongly to decrease wts for d2 activity and high eligibility ","HIDDEN CONDEDIT_ON_learning_law:DA_LEARN_REP ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::d2n_dw))),0,NULL,0},
  {&TA_float,NULL,"d2n_thresh"," for DA_LEARN_REP -- above what eligibility threshold to begin decreasing wts with d2 activity ","HIDDEN CONDEDIT_ON_learning_law:DA_LEARN_REP,DA_LEARN_REP_IH ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::d2n_thresh))),0,NULL,0},
  {&TA_float,NULL,"pos_d2wtgain"," if punish (d2) and dw > 0, then mult by this ","HIDDEN CONDEDIT_ON_learning_law:DA_LEARN_REP ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::pos_d2wtgain))),0,NULL,0},
  {&TA_bool,NULL,"useFixedWts"," set by trial process for constraint fit ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::useFixedWts))),0,NULL,0},
  {&TA_bool,NULL,"legacy_ignore_dt"," set by RtTrial::Run() -- should be true only for old models where dt was not used properly -- to update, mult all RtConSpec lrate's by 1000 and set this to false ","READ_ONLY HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConSpec_MbrOff=(int RtConSpec::*)(&RtConSpec::legacy_ignore_dt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtConSpec_C_InitWtState_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_RtConSpec_C_Compute_Net_MethArgs[]={
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_RtUnit_ptr,NULL,"ru",""},
  {&TA_RtUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_RtConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_RtConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_RtUnit_ptr,NULL,"ru",""},
  {&TA_RtUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_RtConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_RtConSpec_updateDt_MethArgs[]={
  {&TA_float,NULL,"dt",""},
  {&TA_bool,NULL,"legacy_ignore_dt",""},
  NULL};
static MethodArgs_data TA_RtConSpec_Compute_Cooked_Act_MethArgs[]={
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_RtUnit_ptr,NULL,"ru",""},
  {&TA_RtUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_RtConSpec_ComputeModDwEl_MethArgs[]={
  {&TA_float,NULL,"pre",""},
  {&TA_float,NULL,"post",""},
  {&TA_float,NULL,"elig",""},
  {&TA_RtUnit_ptr,NULL,"ru",""},
  {&TA_ModLearnInfo_ptr,NULL,"p",""},
  {&TA_float,NULL,"wt",""},
  NULL};
static MethodArgs_data TA_RtConSpec_ComputeModDw_MethArgs[]={
  {&TA_float,NULL,"pre",""},
  {&TA_float,NULL,"post",""},
  {&TA_float,NULL,"elig",""},
  {&TA_RtUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"wt",""},
  NULL};
static MethodDef_data TA_RtConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtState"," Added by Josh 10/26 ","","",
    1,4,-1,0,NULL,cssElCFun_RtConSpec_C_InitWtState_stub,TA_RtConSpec_C_InitWtState_MethArgs},
  {&TA_float,NULL,"C_Compute_Net","","","",
    1,3,-1,0,NULL,cssElCFun_RtConSpec_C_Compute_Net_stub,TA_RtConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group","","",
    1,2,-1,0,NULL,cssElCFun_RtConSpec_Compute_Net_stub,TA_RtConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt","","","",
    1,3,-1,0,NULL,cssElCFun_RtConSpec_C_Compute_dWt_stub,TA_RtConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change","","",
    1,2,-1,0,NULL,cssElCFun_RtConSpec_Compute_dWt_stub,TA_RtConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"updateDt","","","",
    0,2,-1,0,NULL,cssElCFun_RtConSpec_updateDt_stub,TA_RtConSpec_updateDt_MethArgs},
  {&TA_bool,NULL,"doRWtNorm"," normalize only excit. ","","",
    0,0,-1,0,NULL,cssElCFun_RtConSpec_doRWtNorm_stub,NULL},
  {&TA_bool,NULL,"doSWtNorm"," normalize only excit. ","","",
    0,0,-1,0,NULL,cssElCFun_RtConSpec_doSWtNorm_stub,NULL},
  {&TA_float,NULL,"Compute_Cooked_Act","","","",
    0,3,-1,0,NULL,cssElCFun_RtConSpec_Compute_Cooked_Act_stub,TA_RtConSpec_Compute_Cooked_Act_MethArgs},
  {&TA_float,NULL,"ComputeModDwEl","","","",
    0,6,-1,0,NULL,cssElCFun_RtConSpec_ComputeModDwEl_stub,TA_RtConSpec_ComputeModDwEl_MethArgs},
  {&TA_float,NULL,"ComputeModDw","","","",
    0,5,-1,0,NULL,cssElCFun_RtConSpec_ComputeModDw_stub,TA_RtConSpec_ComputeModDw_MethArgs},
  NULL};
static int RtEpoch::* TA_RtEpoch_MbrOff;
static MemberDef_data TA_RtEpoch_MemberDef[]={
  {&TA_bool,NULL,"isNextSpecified"," if specified ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtEpoch_MbrOff=(int RtEpoch::*)(&RtEpoch::isNextSpecified))),0,NULL,0},
  {&TA_RtEvent_ptr,NULL,"nextEvent","","","",
    *((ta_memb_ptr*)&(TA_RtEpoch_MbrOff=(int RtEpoch::*)(&RtEpoch::nextEvent))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtEpoch_specNextEvent_MethArgs[]={
  {&TA_RtEvent_ptr,NULL,"next",""},
  NULL};
static MethodDef_data TA_RtEpoch_MethodDef[]={
  {&TA_void,NULL,"specNextEvent","","","",
    0,1,-1,0,NULL,cssElCFun_RtEpoch_specNextEvent_stub,TA_RtEpoch_specNextEvent_MethArgs},
  NULL};
static EnumDef_data TA_Trigger_TrigLogic[]={
  {"TRIGGER_AND","","",0},
  {"TRIGGER_OR","","",1},
  NULL};
static EnumDef_data TA_Trigger_TrigAction[]={
  {"PASSIVE"," do nothing; triggers are monitored by other objects ","",0},
  {"TRIAL_END"," signals end of trial ","",1},
  {"TRIAL_END_NEXT_SPEC"," current trial is ended, next event is specified ","",2},
  NULL};
static int Trigger::* TA_Trigger_MbrOff;
static MemberDef_data TA_Trigger_MemberDef[]={
  {&TA_int,NULL,"index"," trigger index ","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_Trigger_MbrOff=(int Trigger::*)(&Trigger::index))),0,NULL,0},
  {&TA_bool,NULL,"isTriggered"," has trigger been activated? ","","",
    *((ta_memb_ptr*)&(TA_Trigger_MbrOff=(int Trigger::*)(&Trigger::isTriggered))),0,NULL,0},
  {&TA_float,NULL,"whenTriggered"," trigger time with respect to start of trial ","USE_RVAL ","",
    *((ta_memb_ptr*)&(TA_Trigger_MbrOff=(int Trigger::*)(&Trigger::whenTriggered))),0,NULL,0},
  {NULL,"::TrigLogic","trigger_logic"," AND = all trigger conditions must be met; OR = any condition met will suffice ","","",
    *((ta_memb_ptr*)&(TA_Trigger_MbrOff=(int Trigger::*)(&Trigger::trigger_logic))),0,NULL,0},
  {NULL,"::TrigAction","trig_action","","","",
    *((ta_memb_ptr*)&(TA_Trigger_MbrOff=(int Trigger::*)(&Trigger::trig_action))),0,NULL,0},
  {&TA_taBase_Group,NULL,"trigCondGroup"," conditions of trigger ","","",
    *((ta_memb_ptr*)&(TA_Trigger_MbrOff=(int Trigger::*)(&Trigger::trigCondGroup))),0,NULL,0},
  NULL};
static MethodDef_data TA_Trigger_MethodDef[]={
  {&TA_bool,NULL,"isTrig"," is the Trigger active? ","","",
    0,0,-1,0,NULL,cssElCFun_Trigger_isTrig_stub,NULL},
  {&TA_void,NULL,"reset"," reset trigger to inactive ","","",
    0,0,-1,0,NULL,cssElCFun_Trigger_reset_stub,NULL},
  NULL};
static EnumDef_data TA_ResponseStat_ResponseType[]={
  {"THRESHOLD"," response when output cell exceeds threshold ","",0},
  {"SETTLE"," response when unit activities stop changing ","",1},
  NULL};
static int ResponseStat::* TA_ResponseStat_MbrOff;
static MemberDef_data TA_ResponseStat_MemberDef[]={
  {NULL,"::ResponseType","response_type"," The criterion for a response ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::response_type))),0,NULL,0},
  {&TA_Layer_ptr,NULL,"trg_lay"," unused, should be deleted ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::trg_lay))),0,NULL,0},
  {&TA_RtTrial_ptr,NULL,"tr"," needed to access trial elapsed time ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::tr))),0,NULL,0},
  {&TA_Trigger_ptr,NULL,"responseSinceWhen"," Response time is relative to time of what trigger? ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::responseSinceWhen))),0,NULL,0},
  {&TA_float,NULL,"minResponseTime"," Response not registered unless specified time elapses since responseSinceWhen ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::minResponseTime))),0,NULL,0},
  {&TA_StatVal,NULL,"resp"," response statistic: resp.val = 0 when no response, 1 if correct, -1 if incorrect ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::resp))),0,NULL,0},
  {&TA_StatVal,NULL,"resp_time"," keeps track of response time ","","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::resp_time))),0,NULL,0},
  {&TA_bool,NULL,"isResponse"," One or more unit currently above threshold ","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::isResponse))),0,NULL,0},
  {&TA_bool,NULL,"isCorrect"," The unit above threshold is correct response ","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::isCorrect))),0,NULL,0},
  {&TA_float,NULL,"lastRt"," Response time from trial onset or given trigger, if specified ","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::lastRt))),0,NULL,0},
  {&TA_float,NULL,"threshold"," activation value to consider unit being on ","CONDEDIT_ON_response_type:THRESHOLD ","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::threshold))),0,NULL,0},
  {&TA_float,NULL,"settle_thresh"," maximum change in activity allowed for any unit when settling complete (as change per second da/dt) ","CONDEDIT_ON_response_type:SETTLE ","",
    *((ta_memb_ptr*)&(TA_ResponseStat_MbrOff=(int ResponseStat::*)(&ResponseStat::settle_thresh))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ResponseStat_Unit_Run_MethArgs[]={
  {&TA_Layer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ResponseStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ResponseStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ResponseStat_ProcessResponse_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodDef_data TA_ResponseStat_MethodDef[]={
  {&TA_void,NULL,"Unit_Run"," Compute over units in a layer","","",
    1,1,-1,0,NULL,cssElCFun_ResponseStat_Unit_Run_stub,TA_ResponseStat_Unit_Run_MethArgs},
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these! ","","",
    1,1,-1,0,NULL,cssElCFun_ResponseStat_RecvCon_Run_stub,TA_ResponseStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_ResponseStat_SendCon_Run_stub,TA_ResponseStat_SendCon_Run_MethArgs},
  {&TA_void,NULL,"TrialInit"," called at start of each trial ","","",
    0,0,-1,0,NULL,cssElCFun_ResponseStat_TrialInit_stub,NULL},
  {&TA_void,NULL,"ProcessResponse","","","",
    0,1,-1,0,NULL,cssElCFun_ResponseStat_ProcessResponse_stub,TA_ResponseStat_ProcessResponse_MethArgs},
  NULL};
static EnumDef_data TA_TriggerCondition_TrigCondType[]={
  {"ELAPSED_TRIAL_START"," time elapsed since start of trial ","",0},
  {"ELAPSED_LAST_TRIG"," time elapsed since a previous trigger ","",1},
  {"LAYER_OVER_THRESH"," an output unit exceeded a threshold ","",2},
  {"CORRECT"," output unit over threshold and correct ","",3},
  {"INCORRECT"," output unit over threshold and incorrect ","",4},
  {"NOT_TRIGGER"," a given trigger has not been activated ","",5},
  NULL};
static int TriggerCondition::* TA_TriggerCondition_MbrOff;
static MemberDef_data TA_TriggerCondition_MemberDef[]={
  {NULL,"::TrigCondType","trig_cond","","","",
    *((ta_memb_ptr*)&(TA_TriggerCondition_MbrOff=(int TriggerCondition::*)(&TriggerCondition::trig_cond))),0,NULL,0},
  {&TA_float,NULL,"elapsed_time"," CONDEDIT_ON_trig_cond:ELAPSED_TRIAL_START,ELAPSED_LAST_TRIG how much time should elapse for trigger? ","USE_RVAL ENVIROVIEW ","",
    *((ta_memb_ptr*)&(TA_TriggerCondition_MbrOff=(int TriggerCondition::*)(&TriggerCondition::elapsed_time))),0,NULL,0},
  {&TA_float,NULL,"thresh"," CONDEDIT_ON_trig_cond:LAYER_OVER_THRESH activity threshold ","USE_RVAL ENVIROVIEW ","",
    *((ta_memb_ptr*)&(TA_TriggerCondition_MbrOff=(int TriggerCondition::*)(&TriggerCondition::thresh))),0,NULL,0},
  {&TA_Layer_ptr,NULL,"aLayer"," not used -- response stat used instead ","ENVIROVIEW CONDEDIT_ON_trig_cond:LAYER_OVER_THRESH NO_NULL ","",
    *((ta_memb_ptr*)&(TA_TriggerCondition_MbrOff=(int TriggerCondition::*)(&TriggerCondition::aLayer))),0,NULL,0},
  {&TA_Trigger_ptr,NULL,"other_trigger"," depends on which other trigger ","ENVIROVIEW CONDEDIT_ON_trig_cond:NOT_TRIGGER,ELAPSED_LAST_TRIG NO_NULL ","",
    *((ta_memb_ptr*)&(TA_TriggerCondition_MbrOff=(int TriggerCondition::*)(&TriggerCondition::other_trigger))),0,NULL,0},
  NULL};
static int TransitionProb::* TA_TransitionProb_MbrOff;
static MemberDef_data TA_TransitionProb_MemberDef[]={
  {&TA_RtEvent_ptr,NULL,"nextEvent"," The next event that may be presented ","","",
    *((ta_memb_ptr*)&(TA_TransitionProb_MbrOff=(int TransitionProb::*)(&TransitionProb::nextEvent))),0,NULL,0},
  {&TA_float,NULL,"probability"," The probability that the event may be presented next ","","",
    *((ta_memb_ptr*)&(TA_TransitionProb_MbrOff=(int TransitionProb::*)(&TransitionProb::probability))),0,NULL,0},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__MoveBefore_MethArgs[]={
  {NULL,"::TransitionProb_ptr","trg",""},
  {NULL,"::TransitionProb_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__MoveAfter_MethArgs[]={
  {NULL,"::TransitionProb_ptr","trg",""},
  {NULL,"::TransitionProb_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__Edit_El_MethArgs[]={
  {NULL,"::TransitionProb_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__LeafGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__AddUniqNameOld_MethArgs[]={
  {NULL,"::TransitionProb_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__LinkUniqNameOld_MethArgs[]={
  {NULL,"::TransitionProb_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_TransitionProb__FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodDef_data TA_taGroup_TransitionProb__MethodDef[]={
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_TransitionProb__MoveBefore_stub,TA_taGroup_TransitionProb__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_TransitionProb__MoveAfter_stub,TA_taGroup_TransitionProb__MoveAfter_MethArgs},
  {NULL,"::TransitionProb_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__SafeEl_stub,TA_taGroup_TransitionProb__SafeEl_MethArgs},
  {NULL,"::TransitionProb_ptr","FastEl"," fast element (no checking)","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__FastEl_stub,TA_taGroup_TransitionProb__FastEl_MethArgs},
  {NULL,"::TransitionProb_ptr","DefaultEl"," returns the element specified as the default for this group","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_TransitionProb__DefaultEl_stub,NULL},
  {NULL,"::TransitionProb_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__Edit_El_stub,TA_taGroup_TransitionProb__Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__SafeGp_stub,TA_taGroup_TransitionProb__SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__FastGp_stub,TA_taGroup_TransitionProb__FastGp_MethArgs},
  {NULL,"::TransitionProb_ptr","Leaf"," get leaf element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__Leaf_stub,TA_taGroup_TransitionProb__Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"LeafGp"," the group containing given leaf","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__LeafGp_stub,TA_taGroup_TransitionProb__LeafGp_MethArgs},
  {NULL,"::TransitionProb_ptr","FirstEl"," returns first leaf element and inits indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__FirstEl_stub,TA_taGroup_TransitionProb__FirstEl_MethArgs},
  {NULL,"::TransitionProb_ptr","NextEl"," returns next leaf element and incs indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__NextEl_stub,TA_taGroup_TransitionProb__NextEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__FirstGp_stub,TA_taGroup_TransitionProb__FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__NextGp_stub,TA_taGroup_TransitionProb__NextGp_MethArgs},
  {NULL,"::TransitionProb_ptr","NewEl"," Create and add (n_els) new element(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_TransitionProb__NewEl_stub,TA_taGroup_TransitionProb__NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_TransitionProb__NewGp_stub,TA_taGroup_TransitionProb__NewGp_MethArgs},
  {NULL,"::TransitionProb_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_TransitionProb__FindName_stub,TA_taGroup_TransitionProb__FindName_MethArgs},
  {NULL,"::TransitionProb_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_TransitionProb__FindType_stub,TA_taGroup_TransitionProb__FindType_MethArgs},
  {NULL,"::TransitionProb_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_TransitionProb__Pop_stub,NULL},
  {NULL,"::TransitionProb_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_TransitionProb__Peek_stub,NULL},
  {NULL,"::TransitionProb_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__AddUniqNameOld_stub,TA_taGroup_TransitionProb__AddUniqNameOld_MethArgs},
  {NULL,"::TransitionProb_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_TransitionProb__LinkUniqNameOld_stub,TA_taGroup_TransitionProb__LinkUniqNameOld_MethArgs},
  {NULL,"::TransitionProb_ptr","FindLeafName"," Find element with given name (el_nm) ","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_taGroup_TransitionProb__FindLeafName_stub,TA_taGroup_TransitionProb__FindLeafName_MethArgs},
  {NULL,"::TransitionProb_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_TransitionProb__FindLeafType_stub,TA_taGroup_TransitionProb__FindLeafType_MethArgs},
  NULL};
static int eventTransition::* TA_eventTransition_MbrOff;
static MemberDef_data TA_eventTransition_MemberDef[]={
  {&TA_TransitionProb_Group,NULL,"transitionProbGroup","","","",
    *((ta_memb_ptr*)&(TA_eventTransition_MbrOff=(int eventTransition::*)(&eventTransition::transitionProbGroup))),0,NULL,0},
  NULL};
static int RtPatternSpec::* TA_RtPatternSpec_MbrOff;
static MemberDef_data TA_RtPatternSpec_MemberDef[]={
  {&TA_bool,NULL,"needsTrigger"," does the pattern require a trigger to be presented? ","","",
    *((ta_memb_ptr*)&(TA_RtPatternSpec_MbrOff=(int RtPatternSpec::*)(&RtPatternSpec::needsTrigger))),0,NULL,0},
  {&TA_Trigger_ptr,NULL,"onTrigger"," the trigger to enable event on ","CONDEDIT_ON_needsTrigger:true ","",
    *((ta_memb_ptr*)&(TA_RtPatternSpec_MbrOff=(int RtPatternSpec::*)(&RtPatternSpec::onTrigger))),0,NULL,0},
  {&TA_bool,NULL,"needsVetoTrigger","","","",
    *((ta_memb_ptr*)&(TA_RtPatternSpec_MbrOff=(int RtPatternSpec::*)(&RtPatternSpec::needsVetoTrigger))),0,NULL,0},
  {&TA_Trigger_ptr,NULL,"vetoTrigger"," if triggered, pattern inactive even if onTrigger active ","CONDEDIT_ON_needsVetoTrigger:true ","",
    *((ta_memb_ptr*)&(TA_RtPatternSpec_MbrOff=(int RtPatternSpec::*)(&RtPatternSpec::vetoTrigger))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtPatternSpec_ApplyPattern_MethArgs[]={
  {&TA_Pattern_ptr,NULL,"pat",""},
  NULL};
static MethodDef_data TA_RtPatternSpec_MethodDef[]={
  {&TA_void,NULL,"ApplyPattern"," apply given pattern to all units (layer must already be set)","","",
    1,1,-1,0,NULL,cssElCFun_RtPatternSpec_ApplyPattern_stub,TA_RtPatternSpec_ApplyPattern_MethArgs},
  NULL};
static EnumDef_data TA_NextEventInfo_NextEventMethod[]={
  {"UNSPEC","","",0},
  {"DETERMINED","","",1},
  {"MARKOV","","",2},
  {"DEPENDS_CORRECT","","",3},
  {"DEPENDS_RESPONSE","","",4},
  {"END_EPOCH","","",5},
  NULL};
static int NextEventInfo::* TA_NextEventInfo_MbrOff;
static MemberDef_data TA_NextEventInfo_MemberDef[]={
  {NULL,"::NextEventMethod","next_event","","","",
    *((ta_memb_ptr*)&(TA_NextEventInfo_MbrOff=(int NextEventInfo::*)(&NextEventInfo::next_event))),0,NULL,0},
  {&TA_RtEvent_ptr,NULL,"nextEvent"," ","CONDEDIT_ON_next_event:DETERMINED ","",
    *((ta_memb_ptr*)&(TA_NextEventInfo_MbrOff=(int NextEventInfo::*)(&NextEventInfo::nextEvent))),0,NULL,0},
  {&TA_RtEvent_ptr,NULL,"nextEventIfCorrect"," ","CONDEDIT_ON_next_event:DEPENDS_CORRECT ","",
    *((ta_memb_ptr*)&(TA_NextEventInfo_MbrOff=(int NextEventInfo::*)(&NextEventInfo::nextEventIfCorrect))),0,NULL,0},
  {&TA_RtEvent_ptr,NULL,"nextEventIfError"," ","CONDEDIT_ON_next_event:DEPENDS_CORRECT ","",
    *((ta_memb_ptr*)&(TA_NextEventInfo_MbrOff=(int NextEventInfo::*)(&NextEventInfo::nextEventIfError))),0,NULL,0},
  {&TA_eventTransition,NULL,"event_trans"," ","CONDEDIT_ON_next_event:MARKOV ","",
    *((ta_memb_ptr*)&(TA_NextEventInfo_MbrOff=(int NextEventInfo::*)(&NextEventInfo::event_trans))),0,NULL,0},
  NULL};
static MethodArgs_data TA_NextEventInfo_getNextEvent_MethArgs[]={
  {&TA_RtUnit_ptr,NULL,"action",""},
  {&TA_bool,NULL,"isReward",""},
  NULL};
static MethodDef_data TA_NextEventInfo_MethodDef[]={
  {&TA_RtEvent_ptr,NULL,"getNextEvent","","","",
    0,2,-1,0,NULL,cssElCFun_NextEventInfo_getNextEvent_stub,TA_NextEventInfo_getNextEvent_MethArgs},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__MoveBefore_MethArgs[]={
  {NULL,"::Trigger_ptr","trg",""},
  {NULL,"::Trigger_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__MoveAfter_MethArgs[]={
  {NULL,"::Trigger_ptr","trg",""},
  {NULL,"::Trigger_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__Edit_El_MethArgs[]={
  {NULL,"::Trigger_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__LeafGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__AddUniqNameOld_MethArgs[]={
  {NULL,"::Trigger_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__LinkUniqNameOld_MethArgs[]={
  {NULL,"::Trigger_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_Trigger__FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodDef_data TA_taGroup_Trigger__MethodDef[]={
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_Trigger__MoveBefore_stub,TA_taGroup_Trigger__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_Trigger__MoveAfter_stub,TA_taGroup_Trigger__MoveAfter_MethArgs},
  {NULL,"::Trigger_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__SafeEl_stub,TA_taGroup_Trigger__SafeEl_MethArgs},
  {NULL,"::Trigger_ptr","FastEl"," fast element (no checking)","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__FastEl_stub,TA_taGroup_Trigger__FastEl_MethArgs},
  {NULL,"::Trigger_ptr","DefaultEl"," returns the element specified as the default for this group","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_Trigger__DefaultEl_stub,NULL},
  {NULL,"::Trigger_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__Edit_El_stub,TA_taGroup_Trigger__Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__SafeGp_stub,TA_taGroup_Trigger__SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__FastGp_stub,TA_taGroup_Trigger__FastGp_MethArgs},
  {NULL,"::Trigger_ptr","Leaf"," get leaf element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__Leaf_stub,TA_taGroup_Trigger__Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"LeafGp"," the group containing given leaf","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__LeafGp_stub,TA_taGroup_Trigger__LeafGp_MethArgs},
  {NULL,"::Trigger_ptr","FirstEl"," returns first leaf element and inits indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__FirstEl_stub,TA_taGroup_Trigger__FirstEl_MethArgs},
  {NULL,"::Trigger_ptr","NextEl"," returns next leaf element and incs indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__NextEl_stub,TA_taGroup_Trigger__NextEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__FirstGp_stub,TA_taGroup_Trigger__FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__NextGp_stub,TA_taGroup_Trigger__NextGp_MethArgs},
  {NULL,"::Trigger_ptr","NewEl"," Create and add (n_els) new element(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_Trigger__NewEl_stub,TA_taGroup_Trigger__NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_Trigger__NewGp_stub,TA_taGroup_Trigger__NewGp_MethArgs},
  {NULL,"::Trigger_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_Trigger__FindName_stub,TA_taGroup_Trigger__FindName_MethArgs},
  {NULL,"::Trigger_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_Trigger__FindType_stub,TA_taGroup_Trigger__FindType_MethArgs},
  {NULL,"::Trigger_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_Trigger__Pop_stub,NULL},
  {NULL,"::Trigger_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_Trigger__Peek_stub,NULL},
  {NULL,"::Trigger_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__AddUniqNameOld_stub,TA_taGroup_Trigger__AddUniqNameOld_MethArgs},
  {NULL,"::Trigger_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_Trigger__LinkUniqNameOld_stub,TA_taGroup_Trigger__LinkUniqNameOld_MethArgs},
  {NULL,"::Trigger_ptr","FindLeafName"," Find element with given name (el_nm) ","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_taGroup_Trigger__FindLeafName_stub,TA_taGroup_Trigger__FindLeafName_MethArgs},
  {NULL,"::Trigger_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_Trigger__FindLeafType_stub,TA_taGroup_Trigger__FindLeafType_MethArgs},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__MoveBefore_MethArgs[]={
  {NULL,"::NextEventInfo_ptr","trg",""},
  {NULL,"::NextEventInfo_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__MoveAfter_MethArgs[]={
  {NULL,"::NextEventInfo_ptr","trg",""},
  {NULL,"::NextEventInfo_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__Edit_El_MethArgs[]={
  {NULL,"::NextEventInfo_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__LeafGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__AddUniqNameOld_MethArgs[]={
  {NULL,"::NextEventInfo_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__LinkUniqNameOld_MethArgs[]={
  {NULL,"::NextEventInfo_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_NextEventInfo__FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodDef_data TA_taGroup_NextEventInfo__MethodDef[]={
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__MoveBefore_stub,TA_taGroup_NextEventInfo__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__MoveAfter_stub,TA_taGroup_NextEventInfo__MoveAfter_MethArgs},
  {NULL,"::NextEventInfo_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__SafeEl_stub,TA_taGroup_NextEventInfo__SafeEl_MethArgs},
  {NULL,"::NextEventInfo_ptr","FastEl"," fast element (no checking)","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__FastEl_stub,TA_taGroup_NextEventInfo__FastEl_MethArgs},
  {NULL,"::NextEventInfo_ptr","DefaultEl"," returns the element specified as the default for this group","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__DefaultEl_stub,NULL},
  {NULL,"::NextEventInfo_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__Edit_El_stub,TA_taGroup_NextEventInfo__Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__SafeGp_stub,TA_taGroup_NextEventInfo__SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__FastGp_stub,TA_taGroup_NextEventInfo__FastGp_MethArgs},
  {NULL,"::NextEventInfo_ptr","Leaf"," get leaf element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__Leaf_stub,TA_taGroup_NextEventInfo__Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"LeafGp"," the group containing given leaf","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__LeafGp_stub,TA_taGroup_NextEventInfo__LeafGp_MethArgs},
  {NULL,"::NextEventInfo_ptr","FirstEl"," returns first leaf element and inits indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__FirstEl_stub,TA_taGroup_NextEventInfo__FirstEl_MethArgs},
  {NULL,"::NextEventInfo_ptr","NextEl"," returns next leaf element and incs indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__NextEl_stub,TA_taGroup_NextEventInfo__NextEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__FirstGp_stub,TA_taGroup_NextEventInfo__FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__NextGp_stub,TA_taGroup_NextEventInfo__NextGp_MethArgs},
  {NULL,"::NextEventInfo_ptr","NewEl"," Create and add (n_els) new element(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_NextEventInfo__NewEl_stub,TA_taGroup_NextEventInfo__NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_NextEventInfo__NewGp_stub,TA_taGroup_NextEventInfo__NewGp_MethArgs},
  {NULL,"::NextEventInfo_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_NextEventInfo__FindName_stub,TA_taGroup_NextEventInfo__FindName_MethArgs},
  {NULL,"::NextEventInfo_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_NextEventInfo__FindType_stub,TA_taGroup_NextEventInfo__FindType_MethArgs},
  {NULL,"::NextEventInfo_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__Pop_stub,NULL},
  {NULL,"::NextEventInfo_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__Peek_stub,NULL},
  {NULL,"::NextEventInfo_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__AddUniqNameOld_stub,TA_taGroup_NextEventInfo__AddUniqNameOld_MethArgs},
  {NULL,"::NextEventInfo_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_NextEventInfo__LinkUniqNameOld_stub,TA_taGroup_NextEventInfo__LinkUniqNameOld_MethArgs},
  {NULL,"::NextEventInfo_ptr","FindLeafName"," Find element with given name (el_nm) ","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_taGroup_NextEventInfo__FindLeafName_stub,TA_taGroup_NextEventInfo__FindLeafName_MethArgs},
  {NULL,"::NextEventInfo_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_NextEventInfo__FindLeafType_stub,TA_taGroup_NextEventInfo__FindLeafType_MethArgs},
  NULL};
static int RtEventSpec::* TA_RtEventSpec_MbrOff;
static MemberDef_data TA_RtEventSpec_MemberDef[]={
  {&TA_Trigger_Group,NULL,"triggers"," events within RtEvent ","","",
    *((ta_memb_ptr*)&(TA_RtEventSpec_MbrOff=(int RtEventSpec::*)(&RtEventSpec::triggers))),0,NULL,0},
  {&TA_NextEventInfo_Group,NULL,"eventTransitions"," specifying next RtEvent ","","",
    *((ta_memb_ptr*)&(TA_RtEventSpec_MbrOff=(int RtEventSpec::*)(&RtEventSpec::eventTransitions))),0,NULL,0},
  NULL};
static MethodArgs_data TA_RtEventSpec_CheckTriggers_MethArgs[]={
  {&TA_Network_ptr,NULL,"network",""},
  {&TA_RtTrial_ptr,NULL,"trial",""},
  NULL};
static MethodArgs_data TA_RtEventSpec_ZeroInputLayers_MethArgs[]={
  {&TA_Network_ptr,NULL,"network",""},
  NULL};
static MethodDef_data TA_RtEventSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckTriggers","","","",
    0,2,-1,0,NULL,cssElCFun_RtEventSpec_CheckTriggers_stub,TA_RtEventSpec_CheckTriggers_MethArgs},
  {&TA_void,NULL,"ResetTriggers","","","",
    0,0,-1,0,NULL,cssElCFun_RtEventSpec_ResetTriggers_stub,NULL},
  {&TA_void,NULL,"ZeroInputLayers"," Housekeeping ","","",
    0,1,-1,0,NULL,cssElCFun_RtEventSpec_ZeroInputLayers_stub,TA_RtEventSpec_ZeroInputLayers_MethArgs},
  NULL};
static EnumDef_data TA_RtConstraintInfo_ConstraintType[]={
  {"INITIAL_CONDITION","","",0},
  {"CLAMP","","",1},
  {"SCRIPT","","",2},
  NULL};
static EnumDef_data TA_RtConstraintInfo_ConstraintObjType[]={
  {"CONSTRAIN_LAYER","","",0},
  {"CONSTRAIN_PROJECTION","","",1},
  NULL};
static EnumDef_data TA_RtConstraintInfo_ConstraintSpecific[]={
  {"CONSTRAIN_UNIFORM","","",0},
  {"CONSTRAIN_INDIVIDUAL","","",1},
  NULL};
static int RtConstraintInfo::* TA_RtConstraintInfo_MbrOff;
static MemberDef_data TA_RtConstraintInfo_MemberDef[]={
  {NULL,"::ConstraintType","constraint_type"," Set only the initial condition, or maintain clamp? ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::constraint_type))),0,NULL,0},
  {NULL,"::ConstraintObjType","constrained_obj"," Is this constraining cell activity or synaptic wts? ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::constrained_obj))),0,NULL,0},
  {&TA_ScriptProcess,NULL,"apply_script"," ","CONDEDIT_ON_constraint_type:SCRIPT ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::apply_script))),0,NULL,0},
  {&TA_Network_ptr,NULL,"whichNetwork"," Network to which the constraint will be applied ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::whichNetwork))),0,NULL,0},
  {&TA_Layer_ptr,NULL,"whichLayer"," if constraining layer ","CONDEDIT_ON_constrained_obj:CONSTRAIN_LAYER ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::whichLayer))),0,NULL,0},
  {&TA_Unit_Group_ptr,NULL,"units"," For TA system -- pointer to units of selected layer ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::units))),0,NULL,0},
  {&TA_RtUnit_ptr,NULL,"whichUnit"," if constraining layer ","CONDEDIT_ON_constrained_obj:CONSTRAIN_LAYER FROM_GROUP_units ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::whichUnit))),0,NULL,0},
  {&TA_Projection_ptr,NULL,"whichProjection"," ","CONDEDIT_ON_constrained_obj:CONSTRAIN_PROJECTION ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::whichProjection))),0,NULL,0},
  {&TA_RtCon_ptr,NULL,"whichCon"," ","CONDEDIT_ON_constrained_obj:CONSTRAIN_PROJECTION ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::whichCon))),0,NULL,0},
  {NULL,"::ConstraintSpecific","how_specific"," Constrain all elements in group the same, or per unit? ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::how_specific))),0,NULL,0},
  {&TA_float,NULL,"val"," value to which element will be constrained ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::val))),0,NULL,0},
  {&TA_bool,NULL,"isApplied"," has the constraint been applied but net state not yet restored? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::isApplied))),0,NULL,0},
  {&TA_bool,NULL,"alreadyAppliedThisRun"," set during application to avoid infinite recursion ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::alreadyAppliedThisRun))),0,NULL,0},
  {&TA_RtConstraintInfo_Group_ptr,NULL,"constraintSource"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::constraintSource))),0,NULL,0},
  {&TA_RtConstraintInfo_ptr,NULL,"constraintToLink"," ","FROM_GROUP_constraintSource ","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::constraintToLink))),0,NULL,0},
  {&TA_RtConstraintInfo_Group,NULL,"sub_constraints"," Other constraints to be applied when this one is applied ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintInfo_MbrOff=(int RtConstraintInfo::*)(&RtConstraintInfo::sub_constraints))),0,NULL,0},
  NULL};
static MethodDef_data TA_RtConstraintInfo_MethodDef[]={
  {&TA_void,NULL,"ReadFromNet"," read unit activity or connection wts from current net state ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_RtConstraintInfo_ReadFromNet_stub,NULL},
  {&TA_void,NULL,"ApplyToNet"," apply this constraint to the network ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_RtConstraintInfo_ApplyToNet_stub,NULL},
  {&TA_void,NULL,"RestoreNet"," restore network to original state before constraint ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_RtConstraintInfo_RestoreNet_stub,NULL},
  {&TA_void,NULL,"FindConstraints"," initializes constraintSource ","","",
    0,0,-1,0,NULL,cssElCFun_RtConstraintInfo_FindConstraints_stub,NULL},
  {&TA_void,NULL,"LinkConstraint"," links constraintToLink into sub_constraints ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_RtConstraintInfo_LinkConstraint_stub,NULL},
  NULL};
static int RtConstraintSpec::* TA_RtConstraintSpec_MbrOff;
static MemberDef_data TA_RtConstraintSpec_MemberDef[]={
  {&TA_RtConstraintInfo_Group,NULL,"constraints"," Group of constraints to be applied by RtConstrain process while fitting data ","","",
    *((ta_memb_ptr*)&(TA_RtConstraintSpec_MbrOff=(int RtConstraintSpec::*)(&RtConstraintSpec::constraints))),0,NULL,0},
  NULL};
static EnumDef_data TA_FitDataInfo_ConstraintType[]={
  {"STATIC_STID"," Minimize Square TIme Derivative for unit ","",0},
  {"STATIC_SEE"," Minimize Squared Equilibrium Error for unit ","",1},
  {"DYN_CELL"," Fit dynamic cell type activity vs. time curve ","",2},
  {"DYN_RT"," Fit reaction-time data ","",3},
  {"DYN_CELL_RT"," Fit both cell type activity and reaction time ","",4},
  {"SCRIPT"," Obj. Func. defined by 'custom' script below ","",5},
  NULL};
static int FitDataInfo::* TA_FitDataInfo_MbrOff;
static MemberDef_data TA_FitDataInfo_MemberDef[]={
  {NULL,"::ConstraintType","constraint_type"," What kind of data constraint? ","","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::constraint_type))),0,NULL,0},
  {&TA_bool,NULL,"isActive"," Is this data point to be fit currently? ","","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::isActive))),0,NULL,0},
  {&TA_Event_MGroup_ptr,NULL,"eventSource"," points to group of environment events ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::eventSource))),0,NULL,0},
  {&TA_Event_ptr,NULL,"eventToLink"," LinkEvent button will add (link) this to events below ","FROM_GROUP_eventSource ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::eventToLink))),0,NULL,0},
  {&TA_taBase_Group,NULL,"events"," Single event, or sequence of events, to be run/applied to generate prediction -- ONLY *LINK* EVENTS TO THIS LIST! (Otherwise, they'll be invisible to the environment) ","","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::events))),0,NULL,0},
  {&TA_float,NULL,"constraint_wt"," How much does this constraint contribute to obj. func.? (should be >= 0) ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::constraint_wt))),0,NULL,0},
  {&TA_Script,NULL,"custom"," used to compute custom value for objective function ","","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::custom))),0,NULL,0},
  {&TA_taString,NULL,"UserData"," May be used to store names, labels, other info, etc. for this constraint -- especially useful for script constraints ","","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::UserData))),0,NULL,0},
  {&TA_float,NULL,"fitEnergyVal"," Script should place raw fit energy here ","","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::fitEnergyVal))),0,NULL,0},
  {&TA_float,NULL,"actualRt"," model output ","CONDEDIT_ON_constraint_type:DYN_RT,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::actualRt))),0,NULL,0},
  {&TA_float,NULL,"desiredRt"," RT to be fit ","CONDEDIT_ON_constraint_type:DYN_RT,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::desiredRt))),0,NULL,0},
  {&TA_bool,NULL,"isCorrect"," Was the model output 'Correct'? ","CONDEDIT_ON_constraint_type:DYN_RT,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::isCorrect))),0,NULL,0},
  {&TA_float,NULL,"desiredAct"," ","CONDEDIT_ON_constraint_type:STATIC_STID,STATIC_SEE ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::desiredAct))),0,NULL,0},
  {&TA_Layer_ptr,NULL,"whichLayerRecorded"," to fit cell type data ","CONDEDIT_OFF_constraint_type:DYN_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::whichLayerRecorded))),0,NULL,0},
  {&TA_Unit_Group_ptr,NULL,"whichLayerUnits"," for TA -- points to units of whichLayerRecorded ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::whichLayerUnits))),0,NULL,0},
  {&TA_Unit_ptr,NULL,"whichUnitRecorded"," to fit celll type data ","CONDEDIT_OFF_constraint_type:DYN_RT FROM_GROUP_whichLayerUnits ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::whichUnitRecorded))),0,NULL,0},
  {&TA_float_Array,NULL,"data_time"," ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::data_time))),0,NULL,0},
  {&TA_float_Array,NULL,"data_act"," ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::data_act))),0,NULL,0},
  {&TA_float_Array,NULL,"model_time"," ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::model_time))),0,NULL,0},
  {&TA_float_Array,NULL,"model_act"," ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::model_act))),0,NULL,0},
  {&TA_float,NULL,"dataAlignTime"," Data alignment point (e.g. if Stimulus presented at t=0.5 in data, then set this to 0.5 to align on stimulus -- t=0.5 will become new t=0 for data) ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::dataAlignTime))),0,NULL,0},
  {&TA_Trigger_ptr,NULL,"align_trigger"," Cell type data aligned such that data point at dataAlignTime coincides with this trigger ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::align_trigger))),0,NULL,0},
  {&TA_float,NULL,"data_gain"," multiply actual firing rates by this ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::data_gain))),0,NULL,0},
  {&TA_bool,NULL,"clampUnitToData"," should the actual firing rate data be reflected in a model cell (for comparison)? ","CONDEDIT_ON_constraint_type:DYN_CELL,DYN_CELL_RT ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::clampUnitToData))),0,NULL,0},
  {&TA_Layer_ptr,NULL,"dataDriveWhichLayer"," which layer should reflect data ","CONDEDIT_ON_clampUnitToData:true ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::dataDriveWhichLayer))),0,NULL,0},
  {&TA_Unit_Group_ptr,NULL,"dataDriveUnits"," for TA -- points to units of dataDriveWhichLayer ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::dataDriveUnits))),0,NULL,0},
  {&TA_Unit_ptr,NULL,"dataDriveWhichUnit"," which unit in the layer should reflect data ","CONDEDIT_ON_clampUnitToData:true FROM_GROUP_dataDriveUnits ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::dataDriveWhichUnit))),0,NULL,0},
  {&TA_RtConstraintInfo_Group_ptr,NULL,"net_state_group"," points to set of possible constraints ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::net_state_group))),0,NULL,0},
  {&TA_RtConstraintInfo_ptr,NULL,"net_state"," specifies state of network for data fitting ","FROM_GROUP_net_state_group ","",
    *((ta_memb_ptr*)&(TA_FitDataInfo_MbrOff=(int FitDataInfo::*)(&FitDataInfo::net_state))),0,NULL,0},
  NULL};
static MethodArgs_data TA_FitDataInfo_LinearInterpModel_MethArgs[]={
  {&TA_float,NULL,"curModelTime",""},
  NULL};
static MethodDef_data TA_FitDataInfo_MethodDef[]={
  {&TA_void,NULL,"FindConstraints","","","",
    0,0,-1,0,NULL,cssElCFun_FitDataInfo_FindConstraints_stub,NULL},
  {&TA_void,NULL,"LinkEvent"," add eventToLink to events ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_FitDataInfo_LinkEvent_stub,NULL},
  {&TA_float,NULL,"LinearInterpModel","","","",
    0,1,-1,0,NULL,cssElCFun_FitDataInfo_LinearInterpModel_stub,TA_FitDataInfo_LinearInterpModel_MethArgs},
  {&TA_float,NULL,"CalcCellTypeFitError","","","",
    0,0,-1,0,NULL,cssElCFun_FitDataInfo_CalcCellTypeFitError_stub,NULL},
  NULL};
static int FitDataSpec::* TA_FitDataSpec_MbrOff;
static MemberDef_data TA_FitDataSpec_MemberDef[]={
  {&TA_FitDataInfo_Group,NULL,"data"," Set of data points to be fit ","","",
    *((ta_memb_ptr*)&(TA_FitDataSpec_MbrOff=(int FitDataSpec::*)(&FitDataSpec::data))),0,NULL,0},
  NULL};
static MethodDef_data TA_FitDataSpec_MethodDef[]={
  {&TA_float,NULL,"CalcRSquare"," ","BUTTON USE_RVAL ","",
    0,0,-1,0,NULL,cssElCFun_FitDataSpec_CalcRSquare_stub,NULL},
  {&TA_void,NULL,"DumpData"," ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_FitDataSpec_DumpData_stub,NULL},
  {&TA_void,NULL,"MakeRandEv"," ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_FitDataSpec_MakeRandEv_stub,NULL},
  NULL};
static int optim::* TA_optim_MbrOff;
static MemberDef_data TA_optim_MemberDef[]={
  {&TA_int,NULL,"maxit"," Maximum allowed iterations ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::maxit))),0,NULL,0},
  {&TA_float,NULL,"machEps"," limit of machine precision ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::machEps))),0,NULL,0},
  {&TA_float,NULL,"optim_tolx"," Convergence criterion on x-values ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::optim_tolx))),0,NULL,0},
  {&TA_float,NULL,"bfgs_max_step"," Scaled maximum step length allowed in line searches. ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::bfgs_max_step))),0,NULL,0},
  {&TA_float,NULL,"ns_tol"," convergence criterion on x for line search (default 1e-7) ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::ns_tol))),0,NULL,0},
  {&TA_float,NULL,"small_f"," ensures sufficient decrease in function value (default 1e-4) ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::small_f))),0,NULL,0},
  {&TA_float_Array,NULL,"p"," Parameters ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::p))),0,NULL,0},
  {&TA_float_Array,NULL,"pnew"," Updated parameters ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::pnew))),0,NULL,0},
  {&TA_float_Array,NULL,"g"," gradient of objFunc in parameter space ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::g))),0,NULL,0},
  {&TA_float_Array,NULL,"delta_g"," diff between old and new gradient vectors ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::delta_g))),0,NULL,0},
  {&TA_float_Array,NULL,"hdelta_g"," dg*hessian ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::hdelta_g))),0,NULL,0},
  {&TA_float_Array,NULL,"xi"," direction of line search (may differ from gradient) ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::xi))),0,NULL,0},
  {&TA_float_Array,NULL,"hessian","","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::hessian))),0,NULL,0},
  {&TA_void_ptr,NULL,"data"," typically a class object ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::data))),0,NULL,0},
  {&TA_int,NULL,"numParams"," How many parameters are being simultaneously fit? ","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::numParams))),0,NULL,0},
  {&TA_bool,NULL,"isRun"," is the optimization in process? ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::isRun))),0,NULL,0},
  {&TA_float,NULL,"den"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::den))),0,NULL,0},
  {&TA_float,NULL,"bfgs_a"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::bfgs_a))),0,NULL,0},
  {&TA_float,NULL,"bfgs_b"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::bfgs_b))),0,NULL,0},
  {&TA_float,NULL,"bfgs_c"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::bfgs_c))),0,NULL,0},
  {&TA_float,NULL,"stpmax"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::stpmax))),0,NULL,0},
  {&TA_float,NULL,"sumdelta_g"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::sumdelta_g))),0,NULL,0},
  {&TA_float,NULL,"sumxi"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::sumxi))),0,NULL,0},
  {&TA_float,NULL,"gtol"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::gtol))),0,NULL,0},
  {&TA_float,NULL,"fp"," last accepted objective function value ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::fp))),0,NULL,0},
  {&TA_int,NULL,"check"," whether minimum might be local ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::check))),0,NULL,0},
  {&TA_int,NULL,"its"," Current number of iterations ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::its))),0,NULL,0},
  {&TA_float,NULL,"curf"," current search of objective function (may not be minimum) ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::curf))),0,NULL,0},
  {&TA_bool,NULL,"forceInitNextRun"," if true, causes Init to recalc gradient before stepping (this is useful if the gradient takes a long time to compute, so you don't have to press Init, wait, and then press Run) ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::forceInitNextRun))),0,NULL,0},
  {&TA_int,NULL,"retries"," Convergence may be spurious, so ignore convergence signal and keep on going this many times (counts down to zero) ","","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::retries))),0,NULL,0},
  {&TA_float,NULL,"objFunc"," returns objective function ","HIDDEN NO_TOKENS ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::objFunc))),0,NULL,1},
  {&TA_void,NULL,"calcGrad"," calculates gradient of objective function -- default can be overridden ","HIDDEN NO_TOKENS ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::calcGrad))),0,NULL,1},
  {&TA_void,NULL,"getParams"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::getParams))),0,NULL,1},
  {&TA_void,NULL,"setParams"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_optim_MbrOff=(int optim::*)(&optim::setParams))),0,NULL,1},
  NULL};
static MethodArgs_data TA_optim_setNumParams_MethArgs[]={
  {&TA_int,NULL,"num",""},
  NULL};
static MethodArgs_data TA_optim_setDataObj_MethArgs[]={
  {&TA_void_ptr,NULL,"theData",""},
  NULL};
static MethodArgs_data TA_optim_doLineSrch_MethArgs[]={
  {&TA_int,NULL,"n",""},
  {&TA_float_Array_ptr,NULL,"xold",""},
  {&TA_float,NULL,"fold",""},
  {&TA_float_Array_ptr,NULL,"g",""},
  {&TA_float_Array_ptr,NULL,"p",""},
  {&TA_float_Array_ptr,NULL,"x",""},
  {&TA_float_ptr,NULL,"f",""},
  {&TA_float,NULL,"stpmax",""},
  {&TA_int_ptr,NULL,"check",""},
  NULL};
static MethodDef_data TA_optim_MethodDef[]={
  {&TA_void,NULL,"setNumParams","","","",
    0,1,-1,0,NULL,cssElCFun_optim_setNumParams_stub,TA_optim_setNumParams_MethArgs},
  {&TA_void,NULL,"setDataObj","","","",
    0,1,-1,0,NULL,cssElCFun_optim_setDataObj_stub,TA_optim_setDataObj_MethArgs},
  {&TA_void,NULL,"Init"," initialize the optimization algorithm ","","",
    0,0,-1,0,NULL,cssElCFun_optim_Init_stub,NULL},
  {&TA_void,NULL,"ReInit"," ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_optim_ReInit_stub,NULL},
  {&TA_void,NULL,"finishOpt","","","",
    0,0,-1,0,NULL,cssElCFun_optim_finishOpt_stub,NULL},
  {&TA_void,NULL,"doOptStep"," The optimization engine; calls doLineSrch ","","",
    0,0,-1,0,NULL,cssElCFun_optim_doOptStep_stub,NULL},
  {&TA_void,NULL,"doLineSrch","","","",
    0,9,-1,0,NULL,cssElCFun_optim_doLineSrch_stub,TA_optim_doLineSrch_MethArgs},
  NULL};
static int simplex::* TA_simplex_MbrOff;
static MemberDef_data TA_simplex_MemberDef[]={
  {&TA_int,NULL,"numParams"," number of parameters ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::numParams))),0,NULL,0},
  {&TA_int,NULL,"numActiveParams"," number of active parameters, in case only a subset should be optimized at a given time (e.g. for subplex)","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::numActiveParams))),0,NULL,0},
  {&TA_int_Array,NULL,"ap"," active params -- indexes the subset of parameters to be optimized -- by default, it is an array of [0..numParams-1]","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::ap))),0,NULL,0},
  {&TA_float,NULL,"init_dp"," characteristic length (used to init simplex vertices: delta p = max(p*init_dp,min_dp)) ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::init_dp))),0,NULL,0},
  {&TA_float,NULL,"min_init_dp"," minimum allowed delta p (only when initializing simplex -- delta p may shrink further after that) ","DETAIL ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::min_init_dp))),0,NULL,0},
  {&TA_float,NULL,"ftol"," convergence criterion ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::ftol))),0,NULL,0},
  {&TA_float,NULL,"ftol_test"," actual convergence metric of current step; will terminate if less than/equal to ftol ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::ftol_test))),0,NULL,0},
  {&TA_int,NULL,"maxitt"," maximum allowed number of iterations ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::maxitt))),0,NULL,0},
  {&TA_int,NULL,"its"," number of iterations so far ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::its))),0,NULL,0},
  {&TA_float_Array,NULL,"p"," array of parameters ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::p))),0,NULL,0},
  {&TA_float_Array,NULL,"psum"," sum of a given parameter element across each vertex of simplex ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::psum))),0,NULL,0},
  {&TA_float_Array,NULL,"fvals"," objective function values at each of the numParams+1 vertices of the simplex ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::fvals))),0,NULL,0},
  {&TA_float_Array,NULL,"s"," matrix -- simplex of parameter vectors ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::s))),0,NULL,0},
  {&TA_void_ptr,NULL,"data"," typically a class object ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::data))),0,NULL,0},
  {&TA_bool,NULL,"isRun"," is the optimization in process? ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::isRun))),0,NULL,0},
  {&TA_bool,NULL,"forceStop"," if true, halt optimization and set model to current best parameter set found ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::forceStop))),0,NULL,0},
  {&TA_bool,NULL,"forceInitNextRun"," if true, causes Init to recalc gradient before stepping (this is useful if the gradient takes a long time to compute, so you don't have to press Init, wait, and then press Run) ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::forceInitNextRun))),0,NULL,0},
  {&TA_int,NULL,"retries"," Convergence may be spurious, so ignore convergence signal and keep on going this many times (counts down to zero) ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::retries))),0,NULL,0},
  {&TA_float,NULL,"f_low"," lowest current value of objective function ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::f_low))),0,NULL,0},
  {&TA_float,NULL,"fsave"," internal temporary variable ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::fsave))),0,NULL,0},
  {&TA_float,NULL,"ftry"," latest attempted function evaluation ","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::ftry))),0,NULL,0},
  {&TA_bool,NULL,"rep_f_low_min"," should f_low be replicated, and the min value used?","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::rep_f_low_min))),0,NULL,0},
  {&TA_int,NULL,"idx_hi","","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::idx_hi))),0,NULL,0},
  {&TA_int,NULL,"idx_lo","","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::idx_lo))),0,NULL,0},
  {&TA_int,NULL,"idx_nhi","","","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::idx_nhi))),0,NULL,0},
  {&TA_int,NULL,"spts"," internal variables ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::spts))),0,NULL,0},
  {&TA_float,NULL,"objFunc"," returns objective function ","HIDDEN NO_TOKENS ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::objFunc))),0,NULL,1},
  {&TA_void,NULL,"getParams"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::getParams))),0,NULL,1},
  {&TA_void,NULL,"setParams"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::setParams))),0,NULL,1},
  {&TA_void,NULL,"saveParams"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_simplex_MbrOff=(int simplex::*)(&simplex::saveParams))),0,NULL,1},
  NULL};
static MethodArgs_data TA_simplex_setNumParams_MethArgs[]={
  {&TA_int,NULL,"num",""},
  NULL};
static MethodArgs_data TA_simplex_setParamActive_MethArgs[]={
  {&TA_int,NULL,"which",""},
  NULL};
static MethodArgs_data TA_simplex_setDataObj_MethArgs[]={
  {&TA_void_ptr,NULL,"theData",""},
  NULL};
static MethodArgs_data TA_simplex_initStepSize_MethArgs[]={
  {&TA_int,NULL,"whichParam",""},
  NULL};
static MethodArgs_data TA_simplex_stepSimplex_MethArgs[]={
  {&TA_float,NULL,"fac",""},
  NULL};
static MethodDef_data TA_simplex_MethodDef[]={
  {&TA_void,NULL,"setNumParams","","","",
    0,1,-1,0,NULL,cssElCFun_simplex_setNumParams_stub,TA_simplex_setNumParams_MethArgs},
  {&TA_void,NULL,"resetActiveParams","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_resetActiveParams_stub,NULL},
  {&TA_void,NULL,"setAllParamsActive","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_setAllParamsActive_stub,NULL},
  {&TA_void,NULL,"setParamActive","","","",
    0,1,-1,0,NULL,cssElCFun_simplex_setParamActive_stub,TA_simplex_setParamActive_MethArgs},
  {&TA_void,NULL,"setDataObj","","","",
    0,1,-1,0,NULL,cssElCFun_simplex_setDataObj_stub,TA_simplex_setDataObj_MethArgs},
  {&TA_void,NULL,"Init","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_Init_stub,NULL},
  {&TA_void,NULL,"ReInit"," Manually flags the optimization algorithm to re-init at start of next run ","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_simplex_ReInit_stub,NULL},
  {&TA_void,NULL,"InitSimplex","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_InitSimplex_stub,NULL},
  {&TA_void,NULL,"checkInitSimplex"," will call InitSimplex() if necessary","","",
    0,0,-1,0,NULL,cssElCFun_simplex_checkInitSimplex_stub,NULL},
  {&TA_void,NULL,"sortFVals"," finds low, hi, nhi, f_low","","",
    0,0,-1,0,NULL,cssElCFun_simplex_sortFVals_stub,NULL},
  {&TA_bool,NULL,"checkCrit","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_checkCrit_stub,NULL},
  {&TA_bool,NULL,"checkForceStop","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_checkForceStop_stub,NULL},
  {&TA_void,NULL,"doOptStep"," The optimization engine ","","",
    0,0,-1,0,NULL,cssElCFun_simplex_doOptStep_stub,NULL},
  {&TA_void,NULL,"putBestPtInP"," saves the best (with lowest obj func) parameter set ","","",
    0,0,-1,0,NULL,cssElCFun_simplex_putBestPtInP_stub,NULL},
  {&TA_bool,NULL,"simplexCrit"," did simplex converge?","","",
    0,0,-1,0,NULL,cssElCFun_simplex_simplexCrit_stub,NULL},
  {&TA_float,NULL,"initStepSize","","","",
    0,1,-1,0,NULL,cssElCFun_simplex_initStepSize_stub,TA_simplex_initStepSize_MethArgs},
  {&TA_void,NULL,"calcPsum","","","",
    0,0,-1,0,NULL,cssElCFun_simplex_calcPsum_stub,NULL},
  {&TA_float,NULL,"stepSimplex","","","",
    0,1,-1,0,NULL,cssElCFun_simplex_stepSimplex_stub,TA_simplex_stepSimplex_MethArgs},
  NULL};
static int subplex::* TA_subplex_MbrOff;
static MemberDef_data TA_subplex_MemberDef[]={
  {&TA_float,NULL,"psi","","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::psi))),0,NULL,0},
  {&TA_float,NULL,"omega","","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::omega))),0,NULL,0},
  {&TA_int,NULL,"nsmin"," minimum subspace dimension ","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::nsmin))),0,NULL,0},
  {&TA_int,NULL,"nsmax"," maximum subspace dimension ","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::nsmax))),0,NULL,0},
  {&TA_int,NULL,"nsp"," number of subspaces ","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::nsp))),0,NULL,0},
  {&TA_int,NULL,"subplexState"," -1 = initializing; 0..nsp = which subspace to optimize","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::subplexState))),0,NULL,0},
  {&TA_bool,NULL,"isSimplexCrit"," Did the current subspace optimization terminate?","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::isSimplexCrit))),0,NULL,0},
  {&TA_int,NULL,"ssoff"," offset of current subspace first element in perm vector","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::ssoff))),0,NULL,0},
  {&TA_bool,NULL,"isFirstSimplexIter"," if so, need to calculate convergence crit","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::isFirstSimplexIter))),0,NULL,0},
  {&TA_float,NULL,"simp_tol"," convergence criterion for each subspace optimization -- set by algorithm","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::simp_tol))),0,NULL,0},
  {&TA_float,NULL,"subp_tol"," convergence criterion for subplex algorithm","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::subp_tol))),0,NULL,0},
  {&TA_float_Array,NULL,"step"," vector of stepsizes, initially set by initStepSize() ","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::step))),0,NULL,0},
  {&TA_float_Array,NULL,"lastxbest"," keeps record of last best value of obj func.","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::lastxbest))),0,NULL,0},
  {&TA_float_Array,NULL,"dx"," progress vector ","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::dx))),0,NULL,0},
  {&TA_int_Array,NULL,"subsp_dims"," keeps track of which subspace [0.. nsp] each element belongs to ","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::subsp_dims))),0,NULL,0},
  {&TA_int_Array,NULL,"perm"," permutation vector, to keep track of which references to subpsaces","","",
    *((ta_memb_ptr*)&(TA_subplex_MbrOff=(int subplex::*)(&subplex::perm))),0,NULL,0},
  NULL};
static MethodArgs_data TA_subplex_useSubspace_MethArgs[]={
  {&TA_int,NULL,"which",""},
  NULL};
static MethodDef_data TA_subplex_MethodDef[]={
  {&TA_void,NULL,"useSubspace","","","",
    0,1,-1,0,NULL,cssElCFun_subplex_useSubspace_stub,TA_subplex_useSubspace_MethArgs},
  {&TA_void,NULL,"updateStepVec","","","",
    0,0,-1,0,NULL,cssElCFun_subplex_updateStepVec_stub,NULL},
  {&TA_void,NULL,"setSubsp","","","",
    0,0,-1,0,NULL,cssElCFun_subplex_setSubsp_stub,NULL},
  {&TA_float,NULL,"computeSimplexSize","","","",
    0,0,-1,0,NULL,cssElCFun_subplex_computeSimplexSize_stub,NULL},
  {&TA_bool,NULL,"subplexOuterCrit","","","",
    0,0,-1,0,NULL,cssElCFun_subplex_subplexOuterCrit_stub,NULL},
  NULL};
static int RtDistFitMgr::* TA_RtDistFitMgr_MbrOff;
static MemberDef_data TA_RtDistFitMgr_MemberDef[]={
  {&TA_bool,NULL,"used"," use distributed fit functions?","","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::used))),0,NULL,0},
  {&TA_bool,NULL,"master"," if true, runs the show -- otherwise, works as slave","","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::master))),0,NULL,0},
  {&TA_int,NULL,"numSlaves"," how many slave processors? Only master needs to know","CONDEDIT_ON_master:true ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::numSlaves))),0,NULL,0},
  {&TA_int,NULL,"numOverlap"," discard first how many constraint in a sub-run (for excluding startup issues with sequential effects)","CONDEDIT_ON_master:true ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::numOverlap))),0,NULL,0},
  {&TA_int,NULL,"slaveID"," must be numbered sequentially 1, 2, 3, ... (master is zero)","","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::slaveID))),0,NULL,0},
  {&TA_int,NULL,"numParams"," set automatically when run","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::numParams))),0,NULL,0},
  {&TA_int,NULL,"numConstr"," set automatically when run","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::numConstr))),0,NULL,0},
  {&TA_float_Array,NULL,"p"," array of parameters","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::p))),0,NULL,0},
  {&TA_int,NULL,"firstConstr"," the first constraint to process","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::firstConstr))),0,NULL,0},
  {&TA_int,NULL,"lastConstr"," the last constraint to process","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::lastConstr))),0,NULL,0},
  {&TA_bool,NULL,"waitLastScript"," set true if last constraint is a script that requires","CONDEDIT_ON_master:true ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::waitLastScript))),0,NULL,0},
  {&TA_void_ptr,NULL,"data"," ","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::data))),0,NULL,0},
  {&TA_void,NULL,"getParams"," ","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::getParams))),0,NULL,1},
  {&TA_void,NULL,"setParams"," ","HIDDEN READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_RtDistFitMgr_MbrOff=(int RtDistFitMgr::*)(&RtDistFitMgr::setParams))),0,NULL,1},
  NULL};
static MethodArgs_data TA_RtDistFitMgr_setNumParams_MethArgs[]={
  {&TA_int,NULL,"num",""},
  NULL};
static MethodArgs_data TA_RtDistFitMgr_setNumConstr_MethArgs[]={
  {&TA_int,NULL,"num",""},
  NULL};
static MethodArgs_data TA_RtDistFitMgr_setDataObj_MethArgs[]={
  {&TA_void_ptr,NULL,"theData",""},
  NULL};
static MethodArgs_data TA_RtDistFitMgr_ReportToMaster_MethArgs[]={
  {&TA_FitDataInfo_Group_ptr,NULL,"data",""},
  NULL};
static MethodArgs_data TA_RtDistFitMgr_GetFromSlaves_MethArgs[]={
  {&TA_FitDataInfo_Group_ptr,NULL,"data",""},
  NULL};
static MethodDef_data TA_RtDistFitMgr_MethodDef[]={
  {&TA_void,NULL,"setNumParams","","","",
    0,1,-1,0,NULL,cssElCFun_RtDistFitMgr_setNumParams_stub,TA_RtDistFitMgr_setNumParams_MethArgs},
  {&TA_void,NULL,"setNumConstr","","","",
    0,1,-1,0,NULL,cssElCFun_RtDistFitMgr_setNumConstr_stub,TA_RtDistFitMgr_setNumConstr_MethArgs},
  {&TA_void,NULL,"setDataObj","","","",
    0,1,-1,0,NULL,cssElCFun_RtDistFitMgr_setDataObj_stub,TA_RtDistFitMgr_setDataObj_MethArgs},
  {&TA_void,NULL,"DirectSlaves"," master sends control signals to slaves","","",
    0,0,-1,0,NULL,cssElCFun_RtDistFitMgr_DirectSlaves_stub,NULL},
  {&TA_void,NULL,"ReceiveOrders"," slaves respond and start working","","",
    0,0,-1,0,NULL,cssElCFun_RtDistFitMgr_ReceiveOrders_stub,NULL},
  {&TA_void,NULL,"ReportToMaster"," slaves report to master","","",
    0,1,-1,0,NULL,cssElCFun_RtDistFitMgr_ReportToMaster_stub,TA_RtDistFitMgr_ReportToMaster_MethArgs},
  {&TA_void,NULL,"GetFromSlaves"," master processes data from slaves","","",
    0,1,-1,0,NULL,cssElCFun_RtDistFitMgr_GetFromSlaves_stub,TA_RtDistFitMgr_GetFromSlaves_MethArgs},
  NULL};
static EnumDef_data TA_RtConstrain_opt_method_type[]={
  {"OPT_BFGS","","",0},
  {"OPT_SIMPLEX","","",1},
  {"OPT_SUBPLEX","","",2},
  NULL};
static EnumDef_data TA_RtConstrain_dp_bound_type[]={
  {"DP_ABS"," spec'd min/max delta_p are absolute ","",0},
  {"DP_FRACTION"," spec'd min/max delta_p are fractions of the corresponding parameter ","",1},
  NULL};
static int RtConstrain::* TA_RtConstrain_MbrOff;
static MemberDef_data TA_RtConstrain_MemberDef[]={
  {NULL,"::opt_method_type","fit_method"," which optimization algorithm to use for data fitting ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::fit_method))),0,NULL,0},
  {&TA_ModelParam_ptr,NULL,"params"," object holding pointers to model parameters ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::params))),0,NULL,0},
  {&TA_int,NULL,"paramSetChangeCount"," how many edits to model param accounted for? ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::paramSetChangeCount))),0,NULL,0},
  {&TA_FitDataSpec_ptr,NULL,"fitData"," Holds data to be fit -- will be evaluated in order listed ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::fitData))),0,NULL,0},
  {&TA_optim,NULL,"op"," BFGS optimization object ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::op))),0,NULL,0},
  {&TA_simplex,NULL,"simp"," Nelder-Mead simplex optimization object ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::simp))),0,NULL,0},
  {&TA_subplex,NULL,"subp"," Rowan (1990) subplex optimization object","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::subp))),0,NULL,0},
  {&TA_RtDistFitMgr,NULL,"dFit"," Manages multi-processor obj func computation","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::dFit))),0,NULL,0},
  {NULL,"::dp_bound_type","dp_bounding"," Are delta_p bounds absolute or relative? ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::dp_bounding))),0,NULL,0},
  {&TA_float,NULL,"min_delta_p"," delta_p is added to each parameter in turn to calc finite difference approximation to dE/dp. min_delta_p provides best accuracy and is used unless it results in zero gradient (this is roughly the precision of the final parameter fit) ","CONDEDIT_ON_opt_method_type:OPT_BFGS ","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::min_delta_p))),0,NULL,0},
  {&TA_float,NULL,"max_delta_p"," if zero gradient, increase delta_p for offending parameter up to max_delta_p ","CONDEDIT_ON_opt_method_type:OPT_BFGS ","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::max_delta_p))),0,NULL,0},
  {&TA_RtTrial_ptr,NULL,"trial_proc"," used for static constraints ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::trial_proc))),0,NULL,0},
  {&TA_float,NULL,"errorPenalty"," how much to penalize model for incorrect responses -- this value is added to objective function for each error ","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::errorPenalty))),0,NULL,0},
  {&TA_bool,NULL,"loopDumpParams"," Should the best parameter set be saved to a file at each step?","","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::loopDumpParams))),0,NULL,0},
  {&TA_taString,NULL,"paramDumpFile"," filename to save parameters at each step","CONDEDIT_ON_loopDumpParams:true ","",
    *((ta_memb_ptr*)&(TA_RtConstrain_MbrOff=(int RtConstrain::*)(&RtConstrain::paramDumpFile))),0,NULL,0},
  NULL};
static MethodDef_data TA_RtConstrain_MethodDef[]={
  {&TA_float,NULL,"fitEnergy"," Calculates objective function; changes network state ","","",
    0,0,-1,0,NULL,cssElCFun_RtConstrain_fitEnergy_stub,NULL},
  {&TA_void,NULL,"SaveParams"," save params to file","","",
    0,0,-1,0,NULL,cssElCFun_RtConstrain_SaveParams_stub,NULL},
  {&TA_void,NULL,"PrepDoFit","","","",
    0,0,-1,0,NULL,cssElCFun_RtConstrain_PrepDoFit_stub,NULL},
  {&TA_void,NULL,"ForceStop"," ","BUTTON GHOST_ON_running ","",
    0,0,-1,0,NULL,cssElCFun_RtConstrain_ForceStop_stub,NULL},
  {&TA_float,NULL,"CalcObjFunc"," ","BUTTON USE_RVAL GHOST_OFF_running ","",
    0,0,-1,0,NULL,cssElCFun_RtConstrain_CalcObjFunc_stub,NULL},
  NULL};
static int MPESubNameSpec::* TA_MPESubNameSpec_MbrOff;
static MemberDef_data TA_MPESubNameSpec_MemberDef[]={
  {&TA_bool,NULL,"isSubGroup"," Is the parameter part of an inlined class in the spec? ","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_MPESubNameSpec_MbrOff=(int MPESubNameSpec::*)(&MPESubNameSpec::isSubGroup))),0,NULL,0},
  {&TA_taString,NULL,"SubMemberName"," Name of inlined class member ","CONDEDIT_ON_isSubGroup:true ","",
    *((ta_memb_ptr*)&(TA_MPESubNameSpec_MbrOff=(int MPESubNameSpec::*)(&MPESubNameSpec::SubMemberName))),0,NULL,0},
  NULL};
static int MPELimitSpec::* TA_MPELimitSpec_MbrOff;
static MemberDef_data TA_MPELimitSpec_MemberDef[]={
  {&TA_float,NULL,"upper"," Upper Limit bound for parameter fitting ","","",
    *((ta_memb_ptr*)&(TA_MPELimitSpec_MbrOff=(int MPELimitSpec::*)(&MPELimitSpec::upper))),0,NULL,0},
  {&TA_float,NULL,"lower"," Lower Limit bound for parameter fitting ","","",
    *((ta_memb_ptr*)&(TA_MPELimitSpec_MbrOff=(int MPELimitSpec::*)(&MPELimitSpec::lower))),0,NULL,0},
  NULL};
static int ModelParamEntry::* TA_ModelParamEntry_MbrOff;
static MemberDef_data TA_ModelParamEntry_MemberDef[]={
  {&TA_bool,NULL,"isOrphan"," ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::isOrphan))),0,NULL,0},
  {&TA_taString,NULL,"SpecName"," From which spec? ","","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::SpecName))),0,NULL,0},
  {&TA_taString,NULL,"MemberName"," Member name? ","","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::MemberName))),0,NULL,0},
  {&TA_MPESubNameSpec,NULL,"subGroup"," Used if the parameter is part of an inlined subclass ","","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::subGroup))),0,NULL,0},
  {&TA_bool,NULL,"fit","","","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::fit))),0,NULL,0},
  {&TA_float_ptr,NULL,"pval"," pointer to actual parameter ","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::pval))),0,NULL,0},
  {&TA_float,NULL,"delta_p"," used to calculate gradient via finite difference ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::delta_p))),0,NULL,0},
  {&TA_float,NULL,"test_delta_p"," Mark delta_p's when BFGS says convergence, then run again and see if delta_p has decreased further. If not, then assume converged ","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::test_delta_p))),0,NULL,0},
  {&TA_float,NULL,"val"," ","CONDEDIT_ON_fit:true ","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::val))),0,NULL,0},
  {&TA_MPELimitSpec,NULL,"limits"," ","CONDEDIT_ON_fit:true ","",
    *((ta_memb_ptr*)&(TA_ModelParamEntry_MbrOff=(int ModelParamEntry::*)(&ModelParamEntry::limits))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ModelParamEntry_setVal_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodDef_data TA_ModelParamEntry_MethodDef[]={
  {&TA_void,NULL,"setVal","","","",
    0,1,-1,0,NULL,cssElCFun_ModelParamEntry_setVal_stub,TA_ModelParamEntry_setVal_MethArgs},
  {&TA_float,NULL,"getVal","","","",
    0,0,-1,0,NULL,cssElCFun_ModelParamEntry_getVal_stub,NULL},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__MoveBefore_MethArgs[]={
  {NULL,"::ModelParamEntry_ptr","trg",""},
  {NULL,"::ModelParamEntry_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__MoveAfter_MethArgs[]={
  {NULL,"::ModelParamEntry_ptr","trg",""},
  {NULL,"::ModelParamEntry_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__Edit_El_MethArgs[]={
  {NULL,"::ModelParamEntry_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__LeafGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","0"},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__AddUniqNameOld_MethArgs[]={
  {NULL,"::ModelParamEntry_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__LinkUniqNameOld_MethArgs[]={
  {NULL,"::ModelParamEntry_ptr","item",""},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taGroup_ModelParamEntry__FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodDef_data TA_taGroup_ModelParamEntry__MethodDef[]={
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__MoveBefore_stub,TA_taGroup_ModelParamEntry__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__MoveAfter_stub,TA_taGroup_ModelParamEntry__MoveAfter_MethArgs},
  {NULL,"::ModelParamEntry_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__SafeEl_stub,TA_taGroup_ModelParamEntry__SafeEl_MethArgs},
  {NULL,"::ModelParamEntry_ptr","FastEl"," fast element (no checking)","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FastEl_stub,TA_taGroup_ModelParamEntry__FastEl_MethArgs},
  {NULL,"::ModelParamEntry_ptr","DefaultEl"," returns the element specified as the default for this group","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__DefaultEl_stub,NULL},
  {NULL,"::ModelParamEntry_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__Edit_El_stub,TA_taGroup_ModelParamEntry__Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__SafeGp_stub,TA_taGroup_ModelParamEntry__SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FastGp_stub,TA_taGroup_ModelParamEntry__FastGp_MethArgs},
  {NULL,"::ModelParamEntry_ptr","Leaf"," get leaf element at index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__Leaf_stub,TA_taGroup_ModelParamEntry__Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"LeafGp"," the group containing given leaf","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__LeafGp_stub,TA_taGroup_ModelParamEntry__LeafGp_MethArgs},
  {NULL,"::ModelParamEntry_ptr","FirstEl"," returns first leaf element and inits indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FirstEl_stub,TA_taGroup_ModelParamEntry__FirstEl_MethArgs},
  {NULL,"::ModelParamEntry_ptr","NextEl"," returns next leaf element and incs indexes","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__NextEl_stub,TA_taGroup_ModelParamEntry__NextEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FirstGp_stub,TA_taGroup_ModelParamEntry__FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__NextGp_stub,TA_taGroup_ModelParamEntry__NextGp_MethArgs},
  {NULL,"::ModelParamEntry_ptr","NewEl"," Create and add (n_els) new element(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_ModelParamEntry__NewEl_stub,TA_taGroup_ModelParamEntry__NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_taGroup_ModelParamEntry__NewGp_stub,TA_taGroup_ModelParamEntry__NewGp_MethArgs},
  {NULL,"::ModelParamEntry_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FindName_stub,TA_taGroup_ModelParamEntry__FindName_MethArgs},
  {NULL,"::ModelParamEntry_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FindType_stub,TA_taGroup_ModelParamEntry__FindType_MethArgs},
  {NULL,"::ModelParamEntry_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__Pop_stub,NULL},
  {NULL,"::ModelParamEntry_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__Peek_stub,NULL},
  {NULL,"::ModelParamEntry_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__AddUniqNameOld_stub,TA_taGroup_ModelParamEntry__AddUniqNameOld_MethArgs},
  {NULL,"::ModelParamEntry_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taGroup_ModelParamEntry__LinkUniqNameOld_stub,TA_taGroup_ModelParamEntry__LinkUniqNameOld_MethArgs},
  {NULL,"::ModelParamEntry_ptr","FindLeafName"," Find element with given name (el_nm) ","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FindLeafName_stub,TA_taGroup_ModelParamEntry__FindLeafName_MethArgs},
  {NULL,"::ModelParamEntry_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taGroup_ModelParamEntry__FindLeafType_stub,TA_taGroup_ModelParamEntry__FindLeafType_MethArgs},
  NULL};

// Init Function


static bool ta_Init_rns_done = false;

void ta_Init_rns() {
  TypeDef* sbt;

  if(ta_Init_rns_done) return;
  ta_Init_rns_done = true;

  ta_Init_ta();
  ta_Init_pdp();
  ta_Init_ta_misc();
  ta_Init_iv_graphic();

  taMisc::in_init = true;

    tac_AddMethods(TA_taRegFun,TA_taRegFun_MethodDef);
  taMisc::types.Add(&TA_RtCon);
    TAI_RtCon = new RtCon;
    TA_RtCon.AddParFormal(&TA_class);
    TA_RtCon.AddParCache(&TA_taBase);
    TA_RtCon.AddClassPar(&TA_Connection,0);
    tac_AddMembers(TA_RtCon,TA_RtCon_MemberDef);
  taMisc::types.Add(&TA_RtCon_Group);
    TAI_RtCon_Group = new RtCon_Group;
    TA_RtCon_Group.AddParFormal(&TA_class);
    TA_RtCon_Group.AddParCache(&TA_taBase);
    TA_RtCon_Group.AddClassPar(&TA_Con_Group,0);
    tac_AddMethods(TA_RtCon_Group,TA_RtCon_Group_MethodDef);
  taMisc::types.Add(&TA_RtUnit);
    TAI_RtUnit = new RtUnit;
    TA_RtUnit.AddParFormal(&TA_class);
    TA_RtUnit.AddParCache(&TA_taBase);
    TA_RtUnit.AddClassPar(&TA_Unit,0);
    tac_AddMembers(TA_RtUnit,TA_RtUnit_MemberDef);
    tac_AddMethods(TA_RtUnit,TA_RtUnit_MethodDef);
  taMisc::types.Add(&TA_ModelParam);
    TAI_ModelParam = new ModelParam;
    TA_ModelParam.AddParFormal(&TA_class);
    TA_ModelParam.AddParCache(&TA_taBase);
    TA_ModelParam.AddClassPar(&TA_BaseSpec,0);
    tac_AddMembers(TA_ModelParam,TA_ModelParam_MemberDef);
    tac_AddMethods(TA_ModelParam,TA_ModelParam_MethodDef);
  taMisc::types.Add(&TA_RtUnitSpec);
    TAI_RtUnitSpec = new RtUnitSpec;
    TA_RtUnitSpec.AddParFormal(&TA_class);
    TA_RtUnitSpec.AddParCache(&TA_taBase);
    TA_RtUnitSpec.AddClassPar(&TA_UnitSpec,0);
    tac_AddMembers(TA_RtUnitSpec,TA_RtUnitSpec_MemberDef);
    tac_AddMethods(TA_RtUnitSpec,TA_RtUnitSpec_MethodDef);
  taMisc::types.Add(&TA_RtTrial);
    TAI_RtTrial = new RtTrial;
    TA_RtTrial.AddParFormal(&TA_class);
    TA_RtTrial.AddParCache(&TA_taBase);
    TA_RtTrial.AddClassPar(&TA_TrialProcess,0);
    tac_AddMembers(TA_RtTrial,TA_RtTrial_MemberDef);
    tac_AddMethods(TA_RtTrial,TA_RtTrial_MethodDef);
  taMisc::types.Add(&TA_float_DelayBuffer);
    TAI_float_DelayBuffer = new float_DelayBuffer;
    TA_float_DelayBuffer.AddParFormal(&TA_class);
    TA_float_DelayBuffer.AddParCache(&TA_taBase);
    TA_float_DelayBuffer.AddClassPar(&TA_float_Array,0);
    tac_AddMembers(TA_float_DelayBuffer,TA_float_DelayBuffer_MemberDef);
    tac_AddMethods(TA_float_DelayBuffer,TA_float_DelayBuffer_MethodDef);
  taMisc::types.Add(&TA_RtEvent);
    TAI_RtEvent = new RtEvent;
    TA_RtEvent.AddParFormal(&TA_class);
    TA_RtEvent.AddParCache(&TA_taBase);
    TA_RtEvent.AddClassPar(&TA_Event,0);
    tac_AddMembers(TA_RtEvent,TA_RtEvent_MemberDef);
    tac_AddMethods(TA_RtEvent,TA_RtEvent_MethodDef);
  taMisc::types.Add(&TA_const_float_DelayBuffer);
    TA_const_float_DelayBuffer.AddParents(&TA_const, &TA_float_DelayBuffer);
  taMisc::types.Add(&TA_const_float_DelayBuffer_ref);
    TA_const_float_DelayBuffer_ref.AddParents(&TA_const_float_DelayBuffer);
  taMisc::types.Add(&TA_NeuroModInfo);
    TAI_NeuroModInfo = new NeuroModInfo;
    TA_NeuroModInfo.AddParFormal(&TA_class);
    TA_NeuroModInfo.AddParCache(&TA_taBase);
    TA_NeuroModInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_NeuroModInfo,TA_NeuroModInfo_MemberDef);
  taMisc::types.Add(&TA_const_NeuroModInfo);
    TA_const_NeuroModInfo.AddParents(&TA_const, &TA_NeuroModInfo);
  taMisc::types.Add(&TA_NMDAInfo);
    TAI_NMDAInfo = new NMDAInfo;
    TA_NMDAInfo.AddParFormal(&TA_class);
    TA_NMDAInfo.AddParCache(&TA_taBase);
    TA_NMDAInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_NMDAInfo,TA_NMDAInfo_MemberDef);
  taMisc::types.Add(&TA_const_NeuroModInfo_ref);
    TA_const_NeuroModInfo_ref.AddParents(&TA_const_NeuroModInfo);
  taMisc::types.Add(&TA_const_NMDAInfo);
    TA_const_NMDAInfo.AddParents(&TA_const, &TA_NMDAInfo);
  taMisc::types.Add(&TA_const_NMDAInfo_ref);
    TA_const_NMDAInfo_ref.AddParents(&TA_const_NMDAInfo);
  taMisc::types.Add(&TA_HabitInfo);
    TAI_HabitInfo = new HabitInfo;
    TA_HabitInfo.AddParFormal(&TA_class);
    TA_HabitInfo.AddParCache(&TA_taBase);
    TA_HabitInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_HabitInfo,TA_HabitInfo_MemberDef);
  taMisc::types.Add(&TA_const_HabitInfo);
    TA_const_HabitInfo.AddParents(&TA_const, &TA_HabitInfo);
  taMisc::types.Add(&TA_const_HabitInfo_ref);
    TA_const_HabitInfo_ref.AddParents(&TA_const_HabitInfo);
  taMisc::types.Add(&TA_ActInfo);
    TAI_ActInfo = new ActInfo;
    TA_ActInfo.AddParFormal(&TA_class);
    TA_ActInfo.AddParCache(&TA_taBase);
    TA_ActInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActInfo,TA_ActInfo_MemberDef);
  taMisc::types.Add(&TA_const_ActInfo);
    TA_const_ActInfo.AddParents(&TA_const, &TA_ActInfo);
  taMisc::types.Add(&TA_const_ActInfo_ref);
    TA_const_ActInfo_ref.AddParents(&TA_const_ActInfo);
  taMisc::types.Add(&TA_ActTraceInfo);
    TAI_ActTraceInfo = new ActTraceInfo;
    TA_ActTraceInfo.AddParFormal(&TA_class);
    TA_ActTraceInfo.AddParCache(&TA_taBase);
    TA_ActTraceInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActTraceInfo,TA_ActTraceInfo_MemberDef);
  taMisc::types.Add(&TA_const_ActTraceInfo);
    TA_const_ActTraceInfo.AddParents(&TA_const, &TA_ActTraceInfo);
  taMisc::types.Add(&TA_const_ActTraceInfo_ref);
    TA_const_ActTraceInfo_ref.AddParents(&TA_const_ActTraceInfo);
  taMisc::types.Add(&TA_RecExcInfo);
    TAI_RecExcInfo = new RecExcInfo;
    TA_RecExcInfo.AddParFormal(&TA_class);
    TA_RecExcInfo.AddParCache(&TA_taBase);
    TA_RecExcInfo.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_RecExcInfo, "RecurExcitType", " form of recurrent excitation signal function ", "", "", "", TA_RecExcInfo_RecurExcitType);
    tac_AddMembers(TA_RecExcInfo,TA_RecExcInfo_MemberDef);
  taMisc::types.Add(&TA_const_RecExcInfo);
    TA_const_RecExcInfo.AddParents(&TA_const, &TA_RecExcInfo);
  taMisc::types.Add(&TA_const_RecExcInfo_ref);
    TA_const_RecExcInfo_ref.AddParents(&TA_const_RecExcInfo);
  taMisc::types.Add(&TA_SoftClampInfo);
    TAI_SoftClampInfo = new SoftClampInfo;
    TA_SoftClampInfo.AddParFormal(&TA_class);
    TA_SoftClampInfo.AddParCache(&TA_taBase);
    TA_SoftClampInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SoftClampInfo,TA_SoftClampInfo_MemberDef);
  taMisc::types.Add(&TA_const_SoftClampInfo);
    TA_const_SoftClampInfo.AddParents(&TA_const, &TA_SoftClampInfo);
  taMisc::types.Add(&TA_const_SoftClampInfo_ref);
    TA_const_SoftClampInfo_ref.AddParents(&TA_const_SoftClampInfo);
  taMisc::types.Add(&TA_NormInfo);
    TAI_NormInfo = new NormInfo;
    TA_NormInfo.AddParFormal(&TA_class);
    TA_NormInfo.AddParCache(&TA_taBase);
    TA_NormInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_NormInfo,TA_NormInfo_MemberDef);
  taMisc::types.Add(&TA_const_NormInfo);
    TA_const_NormInfo.AddParents(&TA_const, &TA_NormInfo);
  taMisc::types.Add(&TA_const_NormInfo_ref);
    TA_const_NormInfo_ref.AddParents(&TA_const_NormInfo);
  taMisc::types.Add(&TA_SpikeInfo);
    TAI_SpikeInfo = new SpikeInfo;
    TA_SpikeInfo.AddParFormal(&TA_class);
    TA_SpikeInfo.AddParCache(&TA_taBase);
    TA_SpikeInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SpikeInfo,TA_SpikeInfo_MemberDef);
  taMisc::types.Add(&TA_const_SpikeInfo);
    TA_const_SpikeInfo.AddParents(&TA_const, &TA_SpikeInfo);
  taMisc::types.Add(&TA_const_SpikeInfo_ref);
    TA_const_SpikeInfo_ref.AddParents(&TA_const_SpikeInfo);
  taMisc::types.Add(&TA_RandLearnInfoSpec);
    TAI_RandLearnInfoSpec = new RandLearnInfoSpec;
    TA_RandLearnInfoSpec.AddParFormal(&TA_class);
    TA_RandLearnInfoSpec.AddParCache(&TA_taBase);
    TA_RandLearnInfoSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_RandLearnInfoSpec,TA_RandLearnInfoSpec_MemberDef);
  taMisc::types.Add(&TA_const_RandLearnInfoSpec);
    TA_const_RandLearnInfoSpec.AddParents(&TA_const, &TA_RandLearnInfoSpec);
  taMisc::types.Add(&TA_const_RandLearnInfoSpec_ref);
    TA_const_RandLearnInfoSpec_ref.AddParents(&TA_const_RandLearnInfoSpec);
  taMisc::types.Add(&TA_VectAssocMapInfo);
    TAI_VectAssocMapInfo = new VectAssocMapInfo;
    TA_VectAssocMapInfo.AddParFormal(&TA_class);
    TA_VectAssocMapInfo.AddParCache(&TA_taBase);
    TA_VectAssocMapInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VectAssocMapInfo,TA_VectAssocMapInfo_MemberDef);
  taMisc::types.Add(&TA_RtUnitSpec_ptr);
    TA_RtUnitSpec_ptr.AddParents(&TA_RtUnitSpec);
  taMisc::types.Add(&TA_const_VectAssocMapInfo);
    TA_const_VectAssocMapInfo.AddParents(&TA_const, &TA_VectAssocMapInfo);
  taMisc::types.Add(&TA_RtUnit_ptr);
    TA_RtUnit_ptr.AddParents(&TA_RtUnit);
  taMisc::types.Add(&TA_const_VectAssocMapInfo_ref);
    TA_const_VectAssocMapInfo_ref.AddParents(&TA_const_VectAssocMapInfo);
  taMisc::types.Add(&TA_const_RtUnitSpec);
    TA_const_RtUnitSpec.AddParents(&TA_const, &TA_RtUnitSpec);
  taMisc::types.Add(&TA_const_RtUnitSpec_ref);
    TA_const_RtUnitSpec_ref.AddParents(&TA_const_RtUnitSpec);
  taMisc::types.Add(&TA_const_RtUnit);
    TA_const_RtUnit.AddParents(&TA_const, &TA_RtUnit);
  taMisc::types.Add(&TA_const_RtUnit_ref);
    TA_const_RtUnit_ref.AddParents(&TA_const_RtUnit);
  taMisc::types.Add(&TA_const_RtCon);
    TA_const_RtCon.AddParents(&TA_const, &TA_RtCon);
  taMisc::types.Add(&TA_const_RtCon_ref);
    TA_const_RtCon_ref.AddParents(&TA_const_RtCon);
  taMisc::types.Add(&TA_SigFuncInfo);
    TAI_SigFuncInfo = new SigFuncInfo;
    TA_SigFuncInfo.AddParFormal(&TA_class);
    TA_SigFuncInfo.AddParCache(&TA_taBase);
    TA_SigFuncInfo.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_SigFuncInfo, "SigFuncType", " What is the nature of the signal function? ", "", "", "", TA_SigFuncInfo_SigFuncType);
    tac_AddMembers(TA_SigFuncInfo,TA_SigFuncInfo_MemberDef);
  taMisc::types.Add(&TA_const_SigFuncInfo);
    TA_const_SigFuncInfo.AddParents(&TA_const, &TA_SigFuncInfo);
  taMisc::types.Add(&TA_EligTraceInfo);
    TAI_EligTraceInfo = new EligTraceInfo;
    TA_EligTraceInfo.AddParFormal(&TA_class);
    TA_EligTraceInfo.AddParCache(&TA_taBase);
    TA_EligTraceInfo.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_EligTraceInfo, "EligType", " What kind of law for eligibility traces? ", "", "", "", TA_EligTraceInfo_EligType);
    tac_AddMembers(TA_EligTraceInfo,TA_EligTraceInfo_MemberDef);
  taMisc::types.Add(&TA_const_SigFuncInfo_ref);
    TA_const_SigFuncInfo_ref.AddParents(&TA_const_SigFuncInfo);
  taMisc::types.Add(&TA_const_EligTraceInfo);
    TA_const_EligTraceInfo.AddParents(&TA_const, &TA_EligTraceInfo);
  taMisc::types.Add(&TA_const_EligTraceInfo_ref);
    TA_const_EligTraceInfo_ref.AddParents(&TA_const_EligTraceInfo);
  taMisc::types.Add(&TA_ModLearnInfo);
    TAI_ModLearnInfo = new ModLearnInfo;
    TA_ModLearnInfo.AddParFormal(&TA_class);
    TA_ModLearnInfo.AddParCache(&TA_taBase);
    TA_ModLearnInfo.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ModLearnInfo, "TermType", " factors for learning equations", "", "", "", TA_ModLearnInfo_TermType);
    tac_AddEnum(TA_ModLearnInfo, "NMODType", " neuromodulators can gate learning", "", "", "", TA_ModLearnInfo_NMODType);
    tac_AddEnum(TA_ModLearnInfo, "aboveBelow", " is quantity above or below spec'd value?", "", "", "", TA_ModLearnInfo_aboveBelow);
    tac_AddMembers(TA_ModLearnInfo,TA_ModLearnInfo_MemberDef);
  taMisc::types.Add(&TA_const_ModLearnInfo);
    TA_const_ModLearnInfo.AddParents(&TA_const, &TA_ModLearnInfo);
  taMisc::types.Add(&TA_const_ModLearnInfo_ref);
    TA_const_ModLearnInfo_ref.AddParents(&TA_const_ModLearnInfo);
  taMisc::types.Add(&TA_ModLearnDecayInfo);
    TAI_ModLearnDecayInfo = new ModLearnDecayInfo;
    TA_ModLearnDecayInfo.AddParFormal(&TA_class);
    TA_ModLearnDecayInfo.AddParCache(&TA_taBase);
    TA_ModLearnDecayInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ModLearnDecayInfo,TA_ModLearnDecayInfo_MemberDef);
  taMisc::types.Add(&TA_const_ModLearnDecayInfo);
    TA_const_ModLearnDecayInfo.AddParents(&TA_const, &TA_ModLearnDecayInfo);
  taMisc::types.Add(&TA_const_ModLearnDecayInfo_ref);
    TA_const_ModLearnDecayInfo_ref.AddParents(&TA_const_ModLearnDecayInfo);
  taMisc::types.Add(&TA_ExcludeNormInfo);
    TAI_ExcludeNormInfo = new ExcludeNormInfo;
    TA_ExcludeNormInfo.AddParFormal(&TA_class);
    TA_ExcludeNormInfo.AddParCache(&TA_taBase);
    TA_ExcludeNormInfo.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ExcludeNormInfo,TA_ExcludeNormInfo_MemberDef);
  taMisc::types.Add(&TA_RtCon_ptr);
    TA_RtCon_ptr.AddParents(&TA_RtCon);
  taMisc::types.Add(&TA_const_ExcludeNormInfo);
    TA_const_ExcludeNormInfo.AddParents(&TA_const, &TA_ExcludeNormInfo);
  taMisc::types.Add(&TA_const_ExcludeNormInfo_ref);
    TA_const_ExcludeNormInfo_ref.AddParents(&TA_const_ExcludeNormInfo);
  taMisc::types.Add(&TA_ModLearnInfo_ptr);
    TA_ModLearnInfo_ptr.AddParents(&TA_ModLearnInfo);
  taMisc::types.Add(&TA_RtConSpec);
    TAI_RtConSpec = new RtConSpec;
    TA_RtConSpec.AddParFormal(&TA_class);
    TA_RtConSpec.AddParCache(&TA_taBase);
    TA_RtConSpec.AddClassPar(&TA_ConSpec,0);
    tac_AddEnum(TA_RtConSpec, "ConType", " what kind of connection is it? ", "", "", "", TA_RtConSpec_ConType);
    tac_AddEnum(TA_RtConSpec, "LearningLaw", " What kind of learning law? ", "", "", "", TA_RtConSpec_LearningLaw);
    tac_AddMembers(TA_RtConSpec,TA_RtConSpec_MemberDef);
    tac_AddMethods(TA_RtConSpec,TA_RtConSpec_MethodDef);
  taMisc::types.Add(&TA_const_RtCon_Group);
    TA_const_RtCon_Group.AddParents(&TA_const, &TA_RtCon_Group);
  taMisc::types.Add(&TA_const_RtConSpec);
    TA_const_RtConSpec.AddParents(&TA_const, &TA_RtConSpec);
  taMisc::types.Add(&TA_const_RtCon_Group_ref);
    TA_const_RtCon_Group_ref.AddParents(&TA_const_RtCon_Group);
  taMisc::types.Add(&TA_const_RtConSpec_ref);
    TA_const_RtConSpec_ref.AddParents(&TA_const_RtConSpec);
  taMisc::types.Add(&TA_const_RtTrial);
    TA_const_RtTrial.AddParents(&TA_const, &TA_RtTrial);
  taMisc::types.Add(&TA_const_RtTrial_ref);
    TA_const_RtTrial_ref.AddParents(&TA_const_RtTrial);
  taMisc::types.Add(&TA_RtEvent_ptr);
    TA_RtEvent_ptr.AddParents(&TA_RtEvent);
  taMisc::types.Add(&TA_RtEpoch);
    TAI_RtEpoch = new RtEpoch;
    TA_RtEpoch.AddParFormal(&TA_class);
    TA_RtEpoch.AddParCache(&TA_taBase);
    TA_RtEpoch.AddClassPar(&TA_EpochProcess,0);
    tac_AddMembers(TA_RtEpoch,TA_RtEpoch_MemberDef);
    tac_AddMethods(TA_RtEpoch,TA_RtEpoch_MethodDef);
  taMisc::types.Add(&TA_Trigger);
    TAI_Trigger = new Trigger;
    TA_Trigger.AddParFormal(&TA_class);
    TA_Trigger.AddParCache(&TA_taBase);
    TA_Trigger.AddClassPar(&TA_taNBase,0);
    tac_AddEnum(TA_Trigger, "TrigLogic", "", "", "", "", TA_Trigger_TrigLogic);
    tac_AddEnum(TA_Trigger, "TrigAction", "", "", "", "", TA_Trigger_TrigAction);
    tac_AddMembers(TA_Trigger,TA_Trigger_MemberDef);
    tac_AddMethods(TA_Trigger,TA_Trigger_MethodDef);
  taMisc::types.Add(&TA_const_RtEpoch);
    TA_const_RtEpoch.AddParents(&TA_const, &TA_RtEpoch);
  taMisc::types.Add(&TA_const_RtEpoch_ref);
    TA_const_RtEpoch_ref.AddParents(&TA_const_RtEpoch);
  taMisc::types.Add(&TA_RtTrial_ptr);
    TA_RtTrial_ptr.AddParents(&TA_RtTrial);
  taMisc::types.Add(&TA_Trigger_ptr);
    TA_Trigger_ptr.AddParents(&TA_Trigger);
  taMisc::types.Add(&TA_ResponseStat);
    TAI_ResponseStat = new ResponseStat;
    TA_ResponseStat.AddParFormal(&TA_class);
    TA_ResponseStat.AddParCache(&TA_taBase);
    TA_ResponseStat.AddClassPar(&TA_Stat,0);
    tac_AddEnum(TA_ResponseStat, "ResponseType", "", "", "", "", TA_ResponseStat_ResponseType);
    tac_AddMembers(TA_ResponseStat,TA_ResponseStat_MemberDef);
    tac_AddMethods(TA_ResponseStat,TA_ResponseStat_MethodDef);
  taMisc::types.Add(&TA_const_ResponseStat);
    TA_const_ResponseStat.AddParents(&TA_const, &TA_ResponseStat);
  taMisc::types.Add(&TA_TriggerCondition);
    TAI_TriggerCondition = new TriggerCondition;
    TA_TriggerCondition.AddParFormal(&TA_class);
    TA_TriggerCondition.AddParCache(&TA_taBase);
    TA_TriggerCondition.AddClassPar(&TA_taOBase,0);
    tac_AddEnum(TA_TriggerCondition, "TrigCondType", "", "", "", "", TA_TriggerCondition_TrigCondType);
    tac_AddMembers(TA_TriggerCondition,TA_TriggerCondition_MemberDef);
  taMisc::types.Add(&TA_const_ResponseStat_ref);
    TA_const_ResponseStat_ref.AddParents(&TA_const_ResponseStat);
  taMisc::types.Add(&TA_const_Trigger);
    TA_const_Trigger.AddParents(&TA_const, &TA_Trigger);
  taMisc::types.Add(&TA_const_TriggerCondition);
    TA_const_TriggerCondition.AddParents(&TA_const, &TA_TriggerCondition);
  taMisc::types.Add(&TA_const_Trigger_ref);
    TA_const_Trigger_ref.AddParents(&TA_const_Trigger);
  taMisc::types.Add(&TA_const_TriggerCondition_ref);
    TA_const_TriggerCondition_ref.AddParents(&TA_const_TriggerCondition);
  taMisc::types.Add(&TA_TransitionProb);
    TAI_TransitionProb = new TransitionProb;
    TA_TransitionProb.AddParFormal(&TA_class);
    TA_TransitionProb.AddParCache(&TA_taBase);
    TA_TransitionProb.AddClassPar(&TA_taOBase,0);
    tac_AddMembers(TA_TransitionProb,TA_TransitionProb_MemberDef);
  taMisc::types.Add(&TA_taGroup_TransitionProb_);
    TAI_taGroup_TransitionProb_ = new taGroup<TransitionProb>;
    TA_taGroup_TransitionProb_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taGroup_TransitionProb_.AddParCache(&TA_taBase);
    TA_taGroup_TransitionProb_.AddClassPar(&TA_taGroup,0);
    sbt = new TypeDef("taBase_ptr", 1, 1, 0);
    sbt->AddParents(&TA_taBase);
    TA_taGroup_TransitionProb_.sub_types.Add(sbt);
    sbt = new TypeDef("TransitionProb_ptr", 1, 1, 0);
    sbt->AddParents(&TA_TransitionProb);
    TA_taGroup_TransitionProb_.sub_types.Add(sbt);
    tac_AddMethods(TA_taGroup_TransitionProb_,TA_taGroup_TransitionProb__MethodDef);
  taMisc::types.Add(&TA_const_TransitionProb);
    TA_const_TransitionProb.AddParents(&TA_const, &TA_TransitionProb);
  taMisc::types.Add(&TA_const_TransitionProb_ref);
    TA_const_TransitionProb_ref.AddParents(&TA_const_TransitionProb);
  taMisc::types.Add(&TA_TransitionProb_Group);
    TAI_TransitionProb_Group = new TransitionProb_Group;
    TA_TransitionProb_Group.AddParFormal(&TA_class);
    TA_TransitionProb_Group.AddParCache(&TA_taBase);
    TA_TransitionProb_Group.AddClassPar(&TA_taGroup_TransitionProb_,0);
  taMisc::types.Add(&TA_const_TransitionProb_Group);
    TA_const_TransitionProb_Group.AddParents(&TA_const, &TA_TransitionProb_Group);
  taMisc::types.Add(&TA_eventTransition);
    TAI_eventTransition = new eventTransition;
    TA_eventTransition.AddParFormal(&TA_class);
    TA_eventTransition.AddParCache(&TA_taBase);
    TA_eventTransition.AddClassPar(&TA_taNBase,0);
    tac_AddMembers(TA_eventTransition,TA_eventTransition_MemberDef);
  taMisc::types.Add(&TA_const_TransitionProb_Group_ref);
    TA_const_TransitionProb_Group_ref.AddParents(&TA_const_TransitionProb_Group);
  taMisc::types.Add(&TA_const_eventTransition);
    TA_const_eventTransition.AddParents(&TA_const, &TA_eventTransition);
  taMisc::types.Add(&TA_const_eventTransition_ref);
    TA_const_eventTransition_ref.AddParents(&TA_const_eventTransition);
  taMisc::types.Add(&TA_RtPatternSpec);
    TAI_RtPatternSpec = new RtPatternSpec;
    TA_RtPatternSpec.AddParFormal(&TA_class);
    TA_RtPatternSpec.AddParCache(&TA_taBase);
    TA_RtPatternSpec.AddClassPar(&TA_PatternSpec,0);
    tac_AddMembers(TA_RtPatternSpec,TA_RtPatternSpec_MemberDef);
    tac_AddMethods(TA_RtPatternSpec,TA_RtPatternSpec_MethodDef);
  taMisc::types.Add(&TA_const_RtPatternSpec);
    TA_const_RtPatternSpec.AddParents(&TA_const, &TA_RtPatternSpec);
  taMisc::types.Add(&TA_const_RtPatternSpec_ref);
    TA_const_RtPatternSpec_ref.AddParents(&TA_const_RtPatternSpec);
  taMisc::types.Add(&TA_NextEventInfo);
    TAI_NextEventInfo = new NextEventInfo;
    TA_NextEventInfo.AddParFormal(&TA_class);
    TA_NextEventInfo.AddParCache(&TA_taBase);
    TA_NextEventInfo.AddClassPar(&TA_taNBase,0);
    tac_AddEnum(TA_NextEventInfo, "NextEventMethod", "", "", "", "", TA_NextEventInfo_NextEventMethod);
    tac_AddMembers(TA_NextEventInfo,TA_NextEventInfo_MemberDef);
    tac_AddMethods(TA_NextEventInfo,TA_NextEventInfo_MethodDef);
  taMisc::types.Add(&TA_taGroup_Trigger_);
    TAI_taGroup_Trigger_ = new taGroup<Trigger>;
    TA_taGroup_Trigger_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taGroup_Trigger_.AddParCache(&TA_taBase);
    TA_taGroup_Trigger_.AddClassPar(&TA_taGroup,0);
    sbt = new TypeDef("taBase_ptr", 1, 1, 0);
    sbt->AddParents(&TA_taBase);
    TA_taGroup_Trigger_.sub_types.Add(sbt);
    sbt = new TypeDef("Trigger_ptr", 1, 1, 0);
    sbt->AddParents(&TA_Trigger);
    TA_taGroup_Trigger_.sub_types.Add(sbt);
    tac_AddMethods(TA_taGroup_Trigger_,TA_taGroup_Trigger__MethodDef);
  taMisc::types.Add(&TA_const_NextEventInfo);
    TA_const_NextEventInfo.AddParents(&TA_const, &TA_NextEventInfo);
  taMisc::types.Add(&TA_const_NextEventInfo_ref);
    TA_const_NextEventInfo_ref.AddParents(&TA_const_NextEventInfo);
  taMisc::types.Add(&TA_Trigger_Group);
    TAI_Trigger_Group = new Trigger_Group;
    TA_Trigger_Group.AddParFormal(&TA_class);
    TA_Trigger_Group.AddParCache(&TA_taBase);
    TA_Trigger_Group.AddClassPar(&TA_taGroup_Trigger_,0);
  taMisc::types.Add(&TA_taGroup_NextEventInfo_);
    TAI_taGroup_NextEventInfo_ = new taGroup<NextEventInfo>;
    TA_taGroup_NextEventInfo_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taGroup_NextEventInfo_.AddParCache(&TA_taBase);
    TA_taGroup_NextEventInfo_.AddClassPar(&TA_taGroup,0);
    sbt = new TypeDef("taBase_ptr", 1, 1, 0);
    sbt->AddParents(&TA_taBase);
    TA_taGroup_NextEventInfo_.sub_types.Add(sbt);
    sbt = new TypeDef("NextEventInfo_ptr", 1, 1, 0);
    sbt->AddParents(&TA_NextEventInfo);
    TA_taGroup_NextEventInfo_.sub_types.Add(sbt);
    tac_AddMethods(TA_taGroup_NextEventInfo_,TA_taGroup_NextEventInfo__MethodDef);
  taMisc::types.Add(&TA_const_Trigger_Group);
    TA_const_Trigger_Group.AddParents(&TA_const, &TA_Trigger_Group);
  taMisc::types.Add(&TA_const_Trigger_Group_ref);
    TA_const_Trigger_Group_ref.AddParents(&TA_const_Trigger_Group);
  taMisc::types.Add(&TA_NextEventInfo_Group);
    TAI_NextEventInfo_Group = new NextEventInfo_Group;
    TA_NextEventInfo_Group.AddParFormal(&TA_class);
    TA_NextEventInfo_Group.AddParCache(&TA_taBase);
    TA_NextEventInfo_Group.AddClassPar(&TA_taGroup_NextEventInfo_,0);
  taMisc::types.Add(&TA_const_NextEventInfo_Group);
    TA_const_NextEventInfo_Group.AddParents(&TA_const, &TA_NextEventInfo_Group);
  taMisc::types.Add(&TA_const_NextEventInfo_Group_ref);
    TA_const_NextEventInfo_Group_ref.AddParents(&TA_const_NextEventInfo_Group);
  taMisc::types.Add(&TA_RtEventSpec);
    TAI_RtEventSpec = new RtEventSpec;
    TA_RtEventSpec.AddParFormal(&TA_class);
    TA_RtEventSpec.AddParCache(&TA_taBase);
    TA_RtEventSpec.AddClassPar(&TA_EventSpec,0);
    tac_AddMembers(TA_RtEventSpec,TA_RtEventSpec_MemberDef);
    tac_AddMethods(TA_RtEventSpec,TA_RtEventSpec_MethodDef);
  taMisc::types.Add(&TA_NextEventInfo_ptr);
    TA_NextEventInfo_ptr.AddParents(&TA_NextEventInfo);
  taMisc::types.Add(&TA_const_RtEventSpec);
    TA_const_RtEventSpec.AddParents(&TA_const, &TA_RtEventSpec);
  taMisc::types.Add(&TA_NextEventInfo_Group_ptr);
    TA_NextEventInfo_Group_ptr.AddParents(&TA_NextEventInfo_Group);
  taMisc::types.Add(&TA_const_RtEventSpec_ref);
    TA_const_RtEventSpec_ref.AddParents(&TA_const_RtEventSpec);
  taMisc::types.Add(&TA_const_RtEvent);
    TA_const_RtEvent.AddParents(&TA_const, &TA_RtEvent);
  taMisc::types.Add(&TA_const_RtEvent_ref);
    TA_const_RtEvent_ref.AddParents(&TA_const_RtEvent);
  taMisc::types.Add(&TA_RtConstraintInfo);
    TAI_RtConstraintInfo = new RtConstraintInfo;
    TA_RtConstraintInfo.AddParFormal(&TA_class);
    TA_RtConstraintInfo.AddParCache(&TA_taBase);
    TA_RtConstraintInfo.AddClassPar(&TA_BaseSubSpec,0);
    tac_AddEnum(TA_RtConstraintInfo, "ConstraintType", "", "", "", "", TA_RtConstraintInfo_ConstraintType);
    tac_AddEnum(TA_RtConstraintInfo, "ConstraintObjType", "", "", "", "", TA_RtConstraintInfo_ConstraintObjType);
    tac_AddEnum(TA_RtConstraintInfo, "ConstraintSpecific", "", "", "", "", TA_RtConstraintInfo_ConstraintSpecific);
    tac_AddMembers(TA_RtConstraintInfo,TA_RtConstraintInfo_MemberDef);
    tac_AddMethods(TA_RtConstraintInfo,TA_RtConstraintInfo_MethodDef);
  taMisc::types.Add(&TA_RtConstraintInfo_Group);
    TAI_RtConstraintInfo_Group = new RtConstraintInfo_Group;
    TA_RtConstraintInfo_Group.AddParFormal(&TA_class);
    TA_RtConstraintInfo_Group.AddParCache(&TA_taBase);
    TA_RtConstraintInfo_Group.AddClassPar(&TA_taBase_Group,0);
  taMisc::types.Add(&TA_RtConstraintInfo_Group_ptr);
    TA_RtConstraintInfo_Group_ptr.AddParents(&TA_RtConstraintInfo_Group);
  taMisc::types.Add(&TA_RtConstraintInfo_ptr);
    TA_RtConstraintInfo_ptr.AddParents(&TA_RtConstraintInfo);
  taMisc::types.Add(&TA_const_RtConstraintInfo);
    TA_const_RtConstraintInfo.AddParents(&TA_const, &TA_RtConstraintInfo);
  taMisc::types.Add(&TA_const_RtConstraintInfo_ref);
    TA_const_RtConstraintInfo_ref.AddParents(&TA_const_RtConstraintInfo);
  taMisc::types.Add(&TA_RtConstraintSpec);
    TAI_RtConstraintSpec = new RtConstraintSpec;
    TA_RtConstraintSpec.AddParFormal(&TA_class);
    TA_RtConstraintSpec.AddParCache(&TA_taBase);
    TA_RtConstraintSpec.AddClassPar(&TA_BaseSpec,0);
    tac_AddMembers(TA_RtConstraintSpec,TA_RtConstraintSpec_MemberDef);
  taMisc::types.Add(&TA_FitDataInfo);
    TAI_FitDataInfo = new FitDataInfo;
    TA_FitDataInfo.AddParFormal(&TA_class);
    TA_FitDataInfo.AddParCache(&TA_taBase);
    TA_FitDataInfo.AddClassPar(&TA_BaseSubSpec,0);
    tac_AddEnum(TA_FitDataInfo, "ConstraintType", "", "", "", "", TA_FitDataInfo_ConstraintType);
    tac_AddMembers(TA_FitDataInfo,TA_FitDataInfo_MemberDef);
    tac_AddMethods(TA_FitDataInfo,TA_FitDataInfo_MethodDef);
  taMisc::types.Add(&TA_const_RtConstraintSpec);
    TA_const_RtConstraintSpec.AddParents(&TA_const, &TA_RtConstraintSpec);
  taMisc::types.Add(&TA_FitDataInfo_Group);
    TAI_FitDataInfo_Group = new FitDataInfo_Group;
    TA_FitDataInfo_Group.AddParFormal(&TA_class);
    TA_FitDataInfo_Group.AddParCache(&TA_taBase);
    TA_FitDataInfo_Group.AddClassPar(&TA_taBase_Group,0);
  taMisc::types.Add(&TA_const_RtConstraintSpec_ref);
    TA_const_RtConstraintSpec_ref.AddParents(&TA_const_RtConstraintSpec);
  taMisc::types.Add(&TA_const_FitDataInfo);
    TA_const_FitDataInfo.AddParents(&TA_const, &TA_FitDataInfo);
  taMisc::types.Add(&TA_const_FitDataInfo_ref);
    TA_const_FitDataInfo_ref.AddParents(&TA_const_FitDataInfo);
  taMisc::types.Add(&TA_FitDataSpec);
    TAI_FitDataSpec = new FitDataSpec;
    TA_FitDataSpec.AddParFormal(&TA_class);
    TA_FitDataSpec.AddParCache(&TA_taBase);
    TA_FitDataSpec.AddClassPar(&TA_BaseSpec,0);
    tac_AddMembers(TA_FitDataSpec,TA_FitDataSpec_MemberDef);
    tac_AddMethods(TA_FitDataSpec,TA_FitDataSpec_MethodDef);
  taMisc::types.Add(&TA_float_Array_ptr);
    TA_float_Array_ptr.AddParents(&TA_float_Array);
  taMisc::types.Add(&TA_const_FitDataSpec);
    TA_const_FitDataSpec.AddParents(&TA_const, &TA_FitDataSpec);
  taMisc::types.Add(&TA_const_FitDataSpec_ref);
    TA_const_FitDataSpec_ref.AddParents(&TA_const_FitDataSpec);
  taMisc::types.Add(&TA_optim);
    TAI_optim = new optim;
    TA_optim.AddParFormal(&TA_class);
    TA_optim.AddParCache(&TA_taBase);
    TA_optim.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_optim,TA_optim_MemberDef);
    tac_AddMethods(TA_optim,TA_optim_MethodDef);
  taMisc::types.Add(&TA_const_optim);
    TA_const_optim.AddParents(&TA_const, &TA_optim);
  taMisc::types.Add(&TA_simplex);
    TAI_simplex = new simplex;
    TA_simplex.AddParFormal(&TA_class);
    TA_simplex.AddParCache(&TA_taBase);
    TA_simplex.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_simplex,TA_simplex_MemberDef);
    tac_AddMethods(TA_simplex,TA_simplex_MethodDef);
  taMisc::types.Add(&TA_const_optim_ref);
    TA_const_optim_ref.AddParents(&TA_const_optim);
  taMisc::types.Add(&TA_const_simplex);
    TA_const_simplex.AddParents(&TA_const, &TA_simplex);
  taMisc::types.Add(&TA_const_simplex_ref);
    TA_const_simplex_ref.AddParents(&TA_const_simplex);
  taMisc::types.Add(&TA_subplex);
    TAI_subplex = new subplex;
    TA_subplex.AddParFormal(&TA_class);
    TA_subplex.AddParCache(&TA_taBase);
    TA_subplex.AddClassPar(&TA_simplex,0);
    tac_AddMembers(TA_subplex,TA_subplex_MemberDef);
    tac_AddMethods(TA_subplex,TA_subplex_MethodDef);
  taMisc::types.Add(&TA_FitDataInfo_Group_ptr);
    TA_FitDataInfo_Group_ptr.AddParents(&TA_FitDataInfo_Group);
  taMisc::types.Add(&TA_const_subplex);
    TA_const_subplex.AddParents(&TA_const, &TA_subplex);
  taMisc::types.Add(&TA_const_subplex_ref);
    TA_const_subplex_ref.AddParents(&TA_const_subplex);
  taMisc::types.Add(&TA_RtDistFitMgr);
    TAI_RtDistFitMgr = new RtDistFitMgr;
    TA_RtDistFitMgr.AddParFormal(&TA_class);
    TA_RtDistFitMgr.AddParCache(&TA_taBase);
    TA_RtDistFitMgr.AddClassPar(&TA_taNBase,0);
    tac_AddMembers(TA_RtDistFitMgr,TA_RtDistFitMgr_MemberDef);
    tac_AddMethods(TA_RtDistFitMgr,TA_RtDistFitMgr_MethodDef);
  taMisc::types.Add(&TA_ModelParam_ptr);
    TA_ModelParam_ptr.AddParents(&TA_ModelParam);
  taMisc::types.Add(&TA_const_RtDistFitMgr);
    TA_const_RtDistFitMgr.AddParents(&TA_const, &TA_RtDistFitMgr);
  taMisc::types.Add(&TA_FitDataSpec_ptr);
    TA_FitDataSpec_ptr.AddParents(&TA_FitDataSpec);
  taMisc::types.Add(&TA_const_RtDistFitMgr_ref);
    TA_const_RtDistFitMgr_ref.AddParents(&TA_const_RtDistFitMgr);
  taMisc::types.Add(&TA_RtConstrain);
    TAI_RtConstrain = new RtConstrain;
    TA_RtConstrain.AddParFormal(&TA_class);
    TA_RtConstrain.AddParCache(&TA_taBase);
    TA_RtConstrain.AddClassPar(&TA_RtEpoch,0);
    tac_AddEnum(TA_RtConstrain, "opt_method_type", "", "", "", "", TA_RtConstrain_opt_method_type);
    tac_AddEnum(TA_RtConstrain, "dp_bound_type", "", "", "", "", TA_RtConstrain_dp_bound_type);
    tac_AddMembers(TA_RtConstrain,TA_RtConstrain_MemberDef);
    tac_AddMethods(TA_RtConstrain,TA_RtConstrain_MethodDef);
  taMisc::types.Add(&TA_const_RtConstrain);
    TA_const_RtConstrain.AddParents(&TA_const, &TA_RtConstrain);
  taMisc::types.Add(&TA_MPESubNameSpec);
    TAI_MPESubNameSpec = new MPESubNameSpec;
    TA_MPESubNameSpec.AddParFormal(&TA_class);
    TA_MPESubNameSpec.AddParCache(&TA_taBase);
    TA_MPESubNameSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MPESubNameSpec,TA_MPESubNameSpec_MemberDef);
  taMisc::types.Add(&TA_const_RtConstrain_ref);
    TA_const_RtConstrain_ref.AddParents(&TA_const_RtConstrain);
  taMisc::types.Add(&TA_const_MPESubNameSpec);
    TA_const_MPESubNameSpec.AddParents(&TA_const, &TA_MPESubNameSpec);
  taMisc::types.Add(&TA_const_MPESubNameSpec_ref);
    TA_const_MPESubNameSpec_ref.AddParents(&TA_const_MPESubNameSpec);
  taMisc::types.Add(&TA_MPELimitSpec);
    TAI_MPELimitSpec = new MPELimitSpec;
    TA_MPELimitSpec.AddParFormal(&TA_class);
    TA_MPELimitSpec.AddParCache(&TA_taBase);
    TA_MPELimitSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MPELimitSpec,TA_MPELimitSpec_MemberDef);
  taMisc::types.Add(&TA_const_MPELimitSpec);
    TA_const_MPELimitSpec.AddParents(&TA_const, &TA_MPELimitSpec);
  taMisc::types.Add(&TA_const_MPELimitSpec_ref);
    TA_const_MPELimitSpec_ref.AddParents(&TA_const_MPELimitSpec);
  taMisc::types.Add(&TA_ModelParamEntry);
    TAI_ModelParamEntry = new ModelParamEntry;
    TA_ModelParamEntry.AddParFormal(&TA_class);
    TA_ModelParamEntry.AddParCache(&TA_taBase);
    TA_ModelParamEntry.AddClassPar(&TA_taOBase,0);
    tac_AddMembers(TA_ModelParamEntry,TA_ModelParamEntry_MemberDef);
    tac_AddMethods(TA_ModelParamEntry,TA_ModelParamEntry_MethodDef);
  taMisc::types.Add(&TA_taGroup_ModelParamEntry_);
    TAI_taGroup_ModelParamEntry_ = new taGroup<ModelParamEntry>;
    TA_taGroup_ModelParamEntry_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taGroup_ModelParamEntry_.AddParCache(&TA_taBase);
    TA_taGroup_ModelParamEntry_.AddClassPar(&TA_taGroup,0);
    sbt = new TypeDef("taBase_ptr", 1, 1, 0);
    sbt->AddParents(&TA_taBase);
    TA_taGroup_ModelParamEntry_.sub_types.Add(sbt);
    sbt = new TypeDef("ModelParamEntry_ptr", 1, 1, 0);
    sbt->AddParents(&TA_ModelParamEntry);
    TA_taGroup_ModelParamEntry_.sub_types.Add(sbt);
    tac_AddMethods(TA_taGroup_ModelParamEntry_,TA_taGroup_ModelParamEntry__MethodDef);
  taMisc::types.Add(&TA_const_ModelParamEntry);
    TA_const_ModelParamEntry.AddParents(&TA_const, &TA_ModelParamEntry);
  taMisc::types.Add(&TA_const_ModelParamEntry_ref);
    TA_const_ModelParamEntry_ref.AddParents(&TA_const_ModelParamEntry);
  taMisc::types.Add(&TA_ModelParamEntry_Group);
    TAI_ModelParamEntry_Group = new ModelParamEntry_Group;
    TA_ModelParamEntry_Group.AddParFormal(&TA_class);
    TA_ModelParamEntry_Group.AddParCache(&TA_taBase);
    TA_ModelParamEntry_Group.AddClassPar(&TA_taGroup_ModelParamEntry_,0);
  taMisc::types.Add(&TA_ModelParamEntry_ptr);
    TA_ModelParamEntry_ptr.AddParents(&TA_ModelParamEntry);
  taMisc::types.Add(&TA_const_ModelParamEntry_Group);
    TA_const_ModelParamEntry_Group.AddParents(&TA_const, &TA_ModelParamEntry_Group);
  taMisc::types.Add(&TA_const_ModelParam);
    TA_const_ModelParam.AddParents(&TA_const, &TA_ModelParam);
  taMisc::types.Add(&TA_const_ModelParamEntry_Group_ref);
    TA_const_ModelParamEntry_Group_ref.AddParents(&TA_const_ModelParamEntry_Group);
  taMisc::types.Add(&TA_const_ModelParam_ref);
    TA_const_ModelParam_ref.AddParents(&TA_const_ModelParam);


  taMisc::in_init = false;
} 
