// File Automatically Generated by MakeTA
// DO NOT EDIT


#include <ta/typea.h>
#include <ta/typea_constr.h>
#include <css/basic_types.h>
#include <css/c_ptr_types.h>
#include <css/ta_css.h>
#include <cs.h>
#include "cs_TA_type.h"
#include "cs_TA_inst.h"


// Types

TypeDef TA_CsCon("CsCon", " connection values for constraint satisfaction", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(CsCon), (void**)&TAI_CsCon, 0, 0, 0,1);
TypeDef TA_CsConSpec("CsConSpec", " constraint satisfaction connection specifications", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(CsConSpec), (void**)&TAI_CsConSpec, 1, 0, 0,1);
TypeDef TA_CsCon_Group("CsCon_Group", "", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(CsCon_Group), (void**)&TAI_CsCon_Group, 0, 0, 0,1);
TypeDef TA_CsUnitSpec("CsUnitSpec", " standard constraint satisfaction unit (uses inverse-logistic activation)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(CsUnitSpec), (void**)&TAI_CsUnitSpec, 1, 0, 0,1);
TypeDef TA_SigmoidUnitSpec("SigmoidUnitSpec", " Sigmoid (logistic) activation function (float-valued within range)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(SigmoidUnitSpec), (void**)&TAI_SigmoidUnitSpec, 1, 0, 0,1);
TypeDef TA_BoltzUnitSpec("BoltzUnitSpec", " Boltzmann-machine activation function (binary, probabalistic)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(BoltzUnitSpec), (void**)&TAI_BoltzUnitSpec, 1, 0, 0,1);
TypeDef TA_IACUnitSpec("IACUnitSpec", " Interactive-Activation & Competition activation function (IAC)", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(IACUnitSpec), (void**)&TAI_IACUnitSpec, 1, 0, 0,1);
TypeDef TA_CsUnit("CsUnit", " constraint satisfaction unit", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 ", "", sizeof(CsUnit), (void**)&TAI_CsUnit, 0, 0, 0,1);
TypeDef TA_CsSample("CsSample", " Samples over Cs Trials (", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(CsSample), (void**)&TAI_CsSample, 1, 0, 0,1);
TypeDef TA_CsTrial("CsTrial", " one minus phase and one plus phase of settling", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(CsTrial), (void**)&TAI_CsTrial, 1, 0, 0,1);
TypeDef TA_CsSettle("CsSettle", " one settle to equilibrium of constrant satsisfaction", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(CsSettle), (void**)&TAI_CsSettle, 1, 0, 0,1);
TypeDef TA_CsCycle("CsCycle", " one update cycle of all units (or n_updates in async) in network", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(CsCycle), (void**)&TAI_CsCycle, 1, 0, 0,1);
TypeDef TA_CsMaxDa("CsMaxDa", " stat that computes when equilibrium is", 
	"EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "", sizeof(CsMaxDa), (void**)&TAI_CsMaxDa, 1, 0, 0,1);
TypeDef TA_CsDistStat("CsDistStat", " gets actual distributions for TIG Stat aggregation makes avg of this in phases, TIG stat in trial ", 
	"EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "", sizeof(CsDistStat), (void**)&TAI_CsDistStat, 1, 0, 0,1);
TypeDef TA_CsTIGstat("CsTIGstat", " Total Information Gain statistic, needs a dist stat to compute raw stats for this one ", 
	"EXT_proc COMPUTE_IN_CsSample FINAL_STAT ", "EXT_proc COMPUTE_IN_CsSample FINAL_STAT ", "", sizeof(CsTIGstat), (void**)&TAI_CsTIGstat, 1, 0, 0,1);
TypeDef TA_CsTargStat("CsTargStat", " computes the pct in target distribution, is just like a TIG stat in that it gets raw values from dist stat ", 
	"EXT_proc COMPUTE_IN_CsSample FINAL_STAT ", "EXT_proc COMPUTE_IN_CsSample FINAL_STAT ", "", sizeof(CsTargStat), (void**)&TAI_CsTargStat, 1, 0, 0,1);
TypeDef TA_CsGoodStat("CsGoodStat", " constraint satisfaction goodness statistic", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(CsGoodStat), (void**)&TAI_CsGoodStat, 1, 0, 0,1);
TypeDef TA_const_CsCon("const_CsCon", 1, 0, 0, 0,1);
TypeDef TA_const_CsCon_ref("const_CsCon_ref", 1, 0, 1, 0,1);
TypeDef TA_CsConSpec_ptr("CsConSpec_ptr", 1, 1, 0, 0,1);
TypeDef TA_CsCon_ptr("CsCon_ptr", 1, 1, 0, 0,1);
TypeDef TA_CsUnit_ptr("CsUnit_ptr", 1, 1, 0, 0,1);
TypeDef TA_CsCon_Group_ptr("CsCon_Group_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_CsConSpec("const_CsConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_CsConSpec_ref("const_CsConSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsCon_Group("const_CsCon_Group", 1, 0, 0, 0,1);
TypeDef TA_const_CsCon_Group_ref("const_CsCon_Group_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsUnitSpec("const_CsUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_CsUnitSpec_ref("const_CsUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_SigmoidUnitSpec("const_SigmoidUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_SigmoidUnitSpec_ref("const_SigmoidUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_BoltzUnitSpec("const_BoltzUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_BoltzUnitSpec_ref("const_BoltzUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_IACUnitSpec("const_IACUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_IACUnitSpec_ref("const_IACUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_LinearCsUnitSpec("LinearCsUnitSpec", " linear version of Cs units with time-averaging on the net inputs", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(LinearCsUnitSpec), (void**)&TAI_LinearCsUnitSpec, 1, 0, 0,1);
TypeDef TA_const_LinearCsUnitSpec("const_LinearCsUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_ThreshLinCsUnitSpec("ThreshLinCsUnitSpec", " threshold-linear version of Cs units with time-averaging on the net inputs", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(ThreshLinCsUnitSpec), (void**)&TAI_ThreshLinCsUnitSpec, 1, 0, 0,1);
TypeDef TA_const_LinearCsUnitSpec_ref("const_LinearCsUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsUnit("const_CsUnit", 1, 0, 0, 0,1);
TypeDef TA_const_ThreshLinCsUnitSpec("const_ThreshLinCsUnitSpec", 1, 0, 0, 0,1);
TypeDef TA_const_CsUnit_ref("const_CsUnit_ref", 1, 0, 1, 0,1);
TypeDef TA_const_ThreshLinCsUnitSpec_ref("const_ThreshLinCsUnitSpec_ref", 1, 0, 1, 0,1);
TypeDef TA_CsSettle_ptr("CsSettle_ptr", 1, 1, 0, 0,1);
TypeDef TA_CsTrial_ptr("CsTrial_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_CsCycle("const_CsCycle", 1, 0, 0, 0,1);
TypeDef TA_const_CsCycle_ref("const_CsCycle_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsSettle("const_CsSettle", 1, 0, 0, 0,1);
TypeDef TA_const_CsSettle_ref("const_CsSettle_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsTrial("const_CsTrial", 1, 0, 0, 0,1);
TypeDef TA_const_CsTrial_ref("const_CsTrial_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsSample("const_CsSample", 1, 0, 0, 0,1);
TypeDef TA_const_CsSample_ref("const_CsSample_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsMaxDa("const_CsMaxDa", 1, 0, 0, 0,1);
TypeDef TA_const_CsMaxDa_ref("const_CsMaxDa_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsDistStat("const_CsDistStat", 1, 0, 0, 0,1);
TypeDef TA_const_CsDistStat_ref("const_CsDistStat_ref", 1, 0, 1, 0,1);
TypeDef TA_CsDistStat_ptr("CsDistStat_ptr", 1, 1, 0, 0,1);
TypeDef TA_const_CsTIGstat("const_CsTIGstat", 1, 0, 0, 0,1);
TypeDef TA_const_CsTIGstat_ref("const_CsTIGstat_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsTargStat("const_CsTargStat", 1, 0, 0, 0,1);
TypeDef TA_const_CsTargStat_ref("const_CsTargStat_ref", 1, 0, 1, 0,1);
TypeDef TA_const_CsGoodStat("const_CsGoodStat", 1, 0, 0, 0,1);
TypeDef TA_const_CsGoodStat_ref("const_CsGoodStat_ref", 1, 0, 1, 0,1);
TypeDef TA_HebbCsConSpec("HebbCsConSpec", " Simple Hebbian wt update (send act * recv act), operates only on final activity states", 
	"EXT_spec MEMB_IN_GPMENU ", "EXT_spec MEMB_IN_GPMENU ", "", sizeof(HebbCsConSpec), (void**)&TAI_HebbCsConSpec, 1, 0, 0,1);
TypeDef TA_const_HebbCsConSpec("const_HebbCsConSpec", 1, 0, 0, 0,1);
TypeDef TA_const_HebbCsConSpec_ref("const_HebbCsConSpec_ref", 1, 0, 1, 0,1);

// Instances

  static cssEl* cssElCFun_Cs_Simple_WtDecay_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    Cs_Simple_WtDecay((CsConSpec*)(void*)*arg[1], (CsCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_Cs_WtElim_WtDecay_stub(void*,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    Cs_WtElim_WtDecay((CsConSpec*)(void*)*arg[1], (CsCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
CsCon*		 TAI_CsCon=NULL;
CsConSpec*		 TAI_CsConSpec=NULL;
  static cssEl* cssElCFun_CsConSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->C_InitWtState((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->C_Compute_dWt((CsCon*)(void*)*arg[1], (CsUnit*)(void*)*arg[2], (CsUnit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->C_UpdateWeights((CsCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_C_Aggregate_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->C_Aggregate_dWt((CsCon*)(void*)*arg[1], (CsUnit*)(void*)*arg[2], (CsUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_Aggregate_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->Aggregate_dWt((CsCon_Group*)(void*)*arg[1], (CsUnit*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_B_Aggregate_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->B_Aggregate_dWt((CsCon*)(void*)*arg[1], (CsUnit*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_C_Compute_WtDecay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->C_Compute_WtDecay((CsCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->B_Compute_dWt((CsCon*)(void*)*arg[1], (CsUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_CsConSpec_B_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsConSpec*)ths)->B_UpdateWeights((CsCon*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
CsCon_Group*		 TAI_CsCon_Group=NULL;
  static cssEl* cssElCFun_CsCon_Group_Aggregate_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsCon_Group*)ths)->Aggregate_dWt((CsUnit*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
CsUnitSpec*		 TAI_CsUnitSpec=NULL;
  static cssEl* cssElCFun_CsUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_ModifyState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->ModifyState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->InitWtState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Compute_Net((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Compute_Act((Unit*)(void*)*arg[1], (int)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Compute_dWt((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Compute_ClampAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Compute_ClampAct((CsUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Compute_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Compute_ClampNet((CsUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Compute_Act_impl((CsUnit*)(void*)*arg[1], (int)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_Aggregate_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->Aggregate_dWt((Unit*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_PostSettle_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnitSpec*)ths)->PostSettle((CsUnit*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_CsUnitSpec_GraphActFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((CsUnitSpec*)ths)->GraphActFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((CsUnitSpec*)ths)->GraphActFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((CsUnitSpec*)ths)->GraphActFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((CsUnitSpec*)ths)->GraphActFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (int)*arg[4]);}
    return rval;}
SigmoidUnitSpec*		 TAI_SigmoidUnitSpec=NULL;
BoltzUnitSpec*		 TAI_BoltzUnitSpec=NULL;
IACUnitSpec*		 TAI_IACUnitSpec=NULL;
  static cssEl* cssElCFun_IACUnitSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((IACUnitSpec*)ths)->Send_Net((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2]);
    return rval;}
CsUnit*		 TAI_CsUnit=NULL;
  static cssEl* cssElCFun_CsUnit_Compute_Act_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnit*)ths)->Compute_Act();
    return rval;}
  static cssEl* cssElCFun_CsUnit_Compute_ClampAct_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnit*)ths)->Compute_ClampAct();
    return rval;}
  static cssEl* cssElCFun_CsUnit_Compute_ClampNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnit*)ths)->Compute_ClampNet();
    return rval;}
  static cssEl* cssElCFun_CsUnit_Targ_To_Ext_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnit*)ths)->Targ_To_Ext();
    return rval;}
  static cssEl* cssElCFun_CsUnit_PostSettle_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnit*)ths)->PostSettle((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsUnit_Aggregate_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsUnit*)ths)->Aggregate_dWt((int)*arg[1]);
    return rval;}
CsSample*		 TAI_CsSample=NULL;
  static cssEl* cssElCFun_CsSample_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSample*)ths)->Compute_dWt();
    return rval;}
CsTrial*		 TAI_CsTrial=NULL;
  static cssEl* cssElCFun_CsTrial_GenCntrLog_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsTrial*)ths)->GenCntrLog((LogData*)(void*)*arg[1], (bool)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_CsTrial_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsTrial*)ths)->Compute_dWt();
    return rval;}
CsSettle*		 TAI_CsSettle=NULL;
  static cssEl* cssElCFun_CsSettle_Compute_ClampAct_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSettle*)ths)->Compute_ClampAct();
    return rval;}
  static cssEl* cssElCFun_CsSettle_Compute_ClampNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSettle*)ths)->Compute_ClampNet();
    return rval;}
  static cssEl* cssElCFun_CsSettle_Compute_NUnits_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSettle*)ths)->Compute_NUnits();
    return rval;}
  static cssEl* cssElCFun_CsSettle_Targ_To_Ext_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSettle*)ths)->Targ_To_Ext();
    return rval;}
  static cssEl* cssElCFun_CsSettle_PostSettle_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSettle*)ths)->PostSettle();
    return rval;}
  static cssEl* cssElCFun_CsSettle_Aggregate_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsSettle*)ths)->Aggregate_dWt();
    return rval;}
CsCycle*		 TAI_CsCycle=NULL;
  static cssEl* cssElCFun_CsCycle_Compute_SyncAct_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsCycle*)ths)->Compute_SyncAct();
    return rval;}
  static cssEl* cssElCFun_CsCycle_Compute_AsyncAct_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsCycle*)ths)->Compute_AsyncAct();
    return rval;}
  static cssEl* cssElCFun_CsCycle_Aggregate_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((CsCycle*)ths)->Aggregate_dWt();
    return rval;}
CsMaxDa*		 TAI_CsMaxDa=NULL;
  static cssEl* cssElCFun_CsMaxDa_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsMaxDa*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsMaxDa_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsMaxDa*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsMaxDa_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsMaxDa*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
CsDistStat*		 TAI_CsDistStat=NULL;
CsTIGstat*		 TAI_CsTIGstat=NULL;
CsTargStat*		 TAI_CsTargStat=NULL;
CsGoodStat*		 TAI_CsGoodStat=NULL;
  static cssEl* cssElCFun_CsGoodStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsGoodStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsGoodStat_Unit_Init_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsGoodStat*)ths)->Unit_Init((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsGoodStat_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsGoodStat*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_CsGoodStat_Con_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((CsGoodStat*)ths)->Con_Stat((Unit*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
LinearCsUnitSpec*		 TAI_LinearCsUnitSpec=NULL;
ThreshLinCsUnitSpec*		 TAI_ThreshLinCsUnitSpec=NULL;
HebbCsConSpec*		 TAI_HebbCsConSpec=NULL;
  static cssEl* cssElCFun_HebbCsConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((HebbCsConSpec*)ths)->C_Compute_dWt((CsCon*)(void*)*arg[1], (CsUnit*)(void*)*arg[2], (CsUnit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_HebbCsConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((HebbCsConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}

// Type Data

static MethodArgs_data TA_taRegFun_Cs_Simple_WtDecay_MethArgs[]={
  {&TA_CsConSpec_ptr,NULL,"spec",""},
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_taRegFun_Cs_WtElim_WtDecay_MethArgs[]={
  {&TA_CsConSpec_ptr,NULL,"spec",""},
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_taRegFun_MethodDef[]={
  {&TA_void,NULL,"Cs_Simple_WtDecay"," Simple weight decay (subtract decay*wt)","","CsConSpec_WtDecay ",
    0,4,-1,1,(ta_void_fun)(Cs_Simple_WtDecay),cssElCFun_Cs_Simple_WtDecay_stub,TA_taRegFun_Cs_Simple_WtDecay_MethArgs},
  {&TA_void,NULL,"Cs_WtElim_WtDecay"," Weight Elimination (Rumelhart) weight decay","","CsConSpec_WtDecay ",
    0,4,-1,1,(ta_void_fun)(Cs_WtElim_WtDecay),cssElCFun_Cs_WtElim_WtDecay_stub,TA_taRegFun_Cs_WtElim_WtDecay_MethArgs},
  NULL};
static int CsCon::* TA_CsCon_MbrOff;
static MemberDef_data TA_CsCon_MemberDef[]={
  {&TA_float,NULL,"dwt"," the current change in weight","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsCon_MbrOff=(int CsCon::*)(&CsCon::dwt))),0,NULL,0},
  {&TA_float,NULL,"pdw"," the previous delta-weight (for momentum)","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsCon_MbrOff=(int CsCon::*)(&CsCon::pdw))),0,NULL,0},
  {&TA_float,NULL,"dwt_agg"," variable for aggregating the outer-prods","NO_VIEW NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsCon_MbrOff=(int CsCon::*)(&CsCon::dwt_agg))),0,NULL,0},
  NULL};
static int CsConSpec::* TA_CsConSpec_MbrOff;
static MemberDef_data TA_CsConSpec_MemberDef[]={
  {&TA_float,NULL,"lrate"," learning rate","","",
    *((ta_memb_ptr*)&(TA_CsConSpec_MbrOff=(int CsConSpec::*)(&CsConSpec::lrate))),0,NULL,0},
  {&TA_float,NULL,"momentum"," momentum for change in weights","","",
    *((ta_memb_ptr*)&(TA_CsConSpec_MbrOff=(int CsConSpec::*)(&CsConSpec::momentum))),0,NULL,0},
  {&TA_float,NULL,"momentum_c"," complement of momentum","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_CsConSpec_MbrOff=(int CsConSpec::*)(&CsConSpec::momentum_c))),0,NULL,0},
  {&TA_float,NULL,"decay"," decay rate (before lrate and momentum)","","",
    *((ta_memb_ptr*)&(TA_CsConSpec_MbrOff=(int CsConSpec::*)(&CsConSpec::decay))),0,NULL,0},
  {&TA_void,NULL,"decay_fun"," the weight decay function to use","CONDEDIT_OFF_decay:0 ","CsConSpec_WtDecay ",
    *((ta_memb_ptr*)&(TA_CsConSpec_MbrOff=(int CsConSpec::*)(&CsConSpec::decay_fun))),0,NULL,1},
  NULL};
static MethodArgs_data TA_CsConSpec_C_InitWtState_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_CsConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_CsConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_CsUnit_ptr,NULL,"ru",""},
  {&TA_CsUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_CsConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_CsConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_CsConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_CsConSpec_C_Aggregate_dWt_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_CsUnit_ptr,NULL,"ru",""},
  {&TA_CsUnit_ptr,NULL,"su",""},
  {&TA_float,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsConSpec_Aggregate_dWt_MethArgs[]={
  {&TA_CsCon_Group_ptr,NULL,"cg",""},
  {&TA_CsUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsConSpec_B_Aggregate_dWt_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_CsUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsConSpec_C_Compute_WtDecay_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_CsConSpec_B_Compute_dWt_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_CsUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_CsConSpec_B_UpdateWeights_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodDef_data TA_CsConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtState","","","",
    1,4,-1,0,NULL,cssElCFun_CsConSpec_C_InitWtState_stub,TA_CsConSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,NULL,cssElCFun_CsConSpec_C_InitWtDelta_stub,TA_CsConSpec_C_InitWtDelta_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt","","","",
    1,3,-1,0,NULL,cssElCFun_CsConSpec_C_Compute_dWt_stub,TA_CsConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change","","",
    1,2,-1,0,NULL,cssElCFun_CsConSpec_Compute_dWt_stub,TA_CsConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights","","","",
    1,3,-1,0,NULL,cssElCFun_CsConSpec_C_UpdateWeights_stub,TA_CsConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_CsConSpec_UpdateWeights_stub,TA_CsConSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"C_Aggregate_dWt","","","",
    0,4,-1,0,NULL,cssElCFun_CsConSpec_C_Aggregate_dWt_stub,TA_CsConSpec_C_Aggregate_dWt_MethArgs},
  {&TA_void,NULL,"Aggregate_dWt","","","",
    0,3,-1,0,NULL,cssElCFun_CsConSpec_Aggregate_dWt_stub,TA_CsConSpec_Aggregate_dWt_MethArgs},
  {&TA_void,NULL,"B_Aggregate_dWt"," aggregate coproducts","","",
    0,3,-1,0,NULL,cssElCFun_CsConSpec_B_Aggregate_dWt_stub,TA_CsConSpec_B_Aggregate_dWt_MethArgs},
  {&TA_void,NULL,"C_Compute_WtDecay"," call the decay function ","","",
    0,3,-1,0,NULL,cssElCFun_CsConSpec_C_Compute_WtDecay_stub,TA_CsConSpec_C_Compute_WtDecay_MethArgs},
  {&TA_void,NULL,"B_Compute_dWt","","","",
    0,2,-1,0,NULL,cssElCFun_CsConSpec_B_Compute_dWt_stub,TA_CsConSpec_B_Compute_dWt_MethArgs},
  {&TA_void,NULL,"B_UpdateWeights","","","",
    0,2,-1,0,NULL,cssElCFun_CsConSpec_B_UpdateWeights_stub,TA_CsConSpec_B_UpdateWeights_MethArgs},
  NULL};
static MethodArgs_data TA_CsCon_Group_Aggregate_dWt_MethArgs[]={
  {&TA_CsUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"phase",""},
  NULL};
static MethodDef_data TA_CsCon_Group_MethodDef[]={
  {&TA_void,NULL,"Aggregate_dWt"," compute weight change","","",
    0,2,-1,0,NULL,cssElCFun_CsCon_Group_Aggregate_dWt_stub,TA_CsCon_Group_Aggregate_dWt_MethArgs},
  NULL};
static EnumDef_data TA_CsUnitSpec_ClampType[]={
  {"HARD_CLAMP"," input sets value, noise is added","",0},
  {"HARD_FAST_CLAMP"," input fixed for entire settle (much faster)","",1},
  {"SOFT_CLAMP"," input added to net input","",2},
  {"SOFT_THEN_HARD_CLAMP"," soft clamping in minus phase, hard clamping in plus","",3},
  NULL};
static int CsUnitSpec::* TA_CsUnitSpec_MbrOff;
static MemberDef_data TA_CsUnitSpec_MemberDef[]={
  {&TA_MinMaxRange,NULL,"real_range"," the actual range to use for activations","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::real_range))),0,NULL,0},
  {&TA_Random,NULL,"noise"," what kind of noise?","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::noise))),0,NULL,0},
  {&TA_float,NULL,"step"," step size taken to update activations","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::step))),0,NULL,0},
  {&TA_float,NULL,"sqrt_step"," square-root of the step size","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::sqrt_step))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain of the activation fun (1/T for boltz)","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::gain))),0,NULL,0},
  {NULL,"::ClampType","clamp_type"," type of clamping to use","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::clamp_type))),0,NULL,0},
  {&TA_float,NULL,"clamp_gain"," gain of the soft clamping","CONDEDIT_OFF_clamp_type:HARD_CLAMP,HARD_FAST_CLAMP ","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::clamp_gain))),0,NULL,0},
  {&TA_Random,NULL,"initial_act"," what to initialize the act to","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::initial_act))),0,NULL,0},
  {&TA_float,NULL,"modify_decay"," amount to decay acts towards rest for MODIFY_STATE","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::modify_decay))),0,NULL,0},
  {&TA_bool,NULL,"use_annealing"," true if noise sched is used to anneal acts","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::use_annealing))),0,NULL,0},
  {&TA_Schedule,NULL,"noise_sched"," schedule of noise variance multipliers","CONDEDIT_ON_use_annealing:true ","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::noise_sched))),0,NULL,0},
  {&TA_bool,NULL,"use_sharp"," true if gain sched is used to sharpen acts","","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::use_sharp))),0,NULL,0},
  {&TA_Schedule,NULL,"gain_sched"," schedule of gain multipliers","CONDEDIT_ON_use_sharp:true ","",
    *((ta_memb_ptr*)&(TA_CsUnitSpec_MbrOff=(int CsUnitSpec::*)(&CsUnitSpec::gain_sched))),0,NULL,0},
  NULL};
static MethodArgs_data TA_CsUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_ModifyState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_InitWtState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Compute_Net_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Compute_Act_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  {&TA_int,NULL,"cycle",""},
  {&TA_int,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Compute_ClampAct_MethArgs[]={
  {&TA_CsUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Compute_ClampNet_MethArgs[]={
  {&TA_CsUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Compute_Act_impl_MethArgs[]={
  {&TA_CsUnit_ptr,NULL,"u",""},
  {&TA_int,NULL,"cycle",""},
  {&TA_int,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_Aggregate_dWt_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  {&TA_int,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_PostSettle_MethArgs[]={
  {&TA_CsUnit_ptr,NULL,"u",""},
  {&TA_int,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsUnitSpec_GraphActFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"min"," -5.0"},
  {&TA_float,NULL,"max"," 5.0"},
  {&TA_int,NULL,"ncycles","50"},
  NULL};
static MethodDef_data TA_CsUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    1,1,-1,0,NULL,cssElCFun_CsUnitSpec_InitState_stub,TA_CsUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"ModifyState"," modify unit state variables decay unit state towards midpoint (or rest)","","",
    1,1,-1,0,NULL,cssElCFun_CsUnitSpec_ModifyState_stub,TA_CsUnitSpec_ModifyState_MethArgs},
  {&TA_void,NULL,"InitWtState"," init weight state variables also init aggregation stuff","","",
    1,1,-1,0,NULL,cssElCFun_CsUnitSpec_InitWtState_stub,TA_CsUnitSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Compute_Net"," add bias","","",
    1,1,-1,0,NULL,cssElCFun_CsUnitSpec_Compute_Net_stub,TA_CsUnitSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act"," if no cycle is passed","","",
    2,3,-1,0,NULL,cssElCFun_CsUnitSpec_Compute_Act_stub,TA_CsUnitSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    1,1,-1,0,NULL,cssElCFun_CsUnitSpec_Compute_dWt_stub,TA_CsUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights from deltas add update bias weight","","",
    1,1,-1,0,NULL,cssElCFun_CsUnitSpec_UpdateWeights_stub,TA_CsUnitSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"Compute_ClampAct"," hard-fast-clamp inputs (at start of settling)","","",
    0,1,-1,0,NULL,cssElCFun_CsUnitSpec_Compute_ClampAct_stub,TA_CsUnitSpec_Compute_ClampAct_MethArgs},
  {&TA_void,NULL,"Compute_ClampNet"," compute net input from clamped inputs (at start of settling)","","",
    0,1,-1,0,NULL,cssElCFun_CsUnitSpec_Compute_ClampNet_stub,TA_CsUnitSpec_Compute_ClampNet_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl"," actually computes specific activation function ","","",
    0,3,-1,0,NULL,cssElCFun_CsUnitSpec_Compute_Act_impl_stub,TA_CsUnitSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"Aggregate_dWt","","","",
    0,2,-1,0,NULL,cssElCFun_CsUnitSpec_Aggregate_dWt_stub,TA_CsUnitSpec_Aggregate_dWt_MethArgs},
  {&TA_void,NULL,"PostSettle"," set stuff after settling is over","","",
    0,2,-1,0,NULL,cssElCFun_CsUnitSpec_PostSettle_stub,TA_CsUnitSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"GraphActFun"," graph the activation function, 'settling' for 50 cycles for each net input (NULL = new graph log)","BUTTON NULL_OK ","",
    0,4,1,0,NULL,cssElCFun_CsUnitSpec_GraphActFun_stub,TA_CsUnitSpec_GraphActFun_MethArgs},
  NULL};
static EnumDef_data TA_SigmoidUnitSpec_TimeAvgType[]={
  {"ACTIVATION"," time-average the activations","",0},
  {"NET_INPUT"," time-average the net inputs","",1},
  NULL};
static int SigmoidUnitSpec::* TA_SigmoidUnitSpec_MbrOff;
static MemberDef_data TA_SigmoidUnitSpec_MemberDef[]={
  {NULL,"::TimeAvgType","time_avg"," type of time-averaging to perform","","",
    *((ta_memb_ptr*)&(TA_SigmoidUnitSpec_MbrOff=(int SigmoidUnitSpec::*)(&SigmoidUnitSpec::time_avg))),0,NULL,0},
  NULL};
static int BoltzUnitSpec::* TA_BoltzUnitSpec_MbrOff;
static MemberDef_data TA_BoltzUnitSpec_MemberDef[]={
  {&TA_float,NULL,"temp"," temperature (1/gain)","","",
    *((ta_memb_ptr*)&(TA_BoltzUnitSpec_MbrOff=(int BoltzUnitSpec::*)(&BoltzUnitSpec::temp))),0,NULL,0},
  NULL};
static int IACUnitSpec::* TA_IACUnitSpec_MbrOff;
static MemberDef_data TA_IACUnitSpec_MemberDef[]={
  {&TA_float,NULL,"rest"," rest level of activation","","",
    *((ta_memb_ptr*)&(TA_IACUnitSpec_MbrOff=(int IACUnitSpec::*)(&IACUnitSpec::rest))),0,NULL,0},
  {&TA_float,NULL,"decay"," decay rate (1/gain)","","",
    *((ta_memb_ptr*)&(TA_IACUnitSpec_MbrOff=(int IACUnitSpec::*)(&IACUnitSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"use_send_thresh"," pay attn to send_thresh? if so, need SYNC_SENDER_BASED in cycle proc, sender based netin","","",
    *((ta_memb_ptr*)&(TA_IACUnitSpec_MbrOff=(int IACUnitSpec::*)(&IACUnitSpec::use_send_thresh))),0,NULL,0},
  {&TA_float,NULL,"send_thresh"," threshold below which unit does not send act","CONDEDIT_ON_use_send_thresh:true ","",
    *((ta_memb_ptr*)&(TA_IACUnitSpec_MbrOff=(int IACUnitSpec::*)(&IACUnitSpec::send_thresh))),0,NULL,0},
  NULL};
static MethodArgs_data TA_IACUnitSpec_Send_Net_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  {&TA_Layer_ptr,NULL,"tolay",""},
  NULL};
static MethodDef_data TA_IACUnitSpec_MethodDef[]={
  {&TA_void,NULL,"Send_Net"," send net input to all units I send to do sender-based stuff","","",
    1,2,-1,0,NULL,cssElCFun_IACUnitSpec_Send_Net_stub,TA_IACUnitSpec_Send_Net_MethArgs},
  NULL};
static int CsUnit::* TA_CsUnit_MbrOff;
static MemberDef_data TA_CsUnit_MemberDef[]={
  {&TA_float,NULL,"da"," delta-activation (or net input) value","","",
    *((ta_memb_ptr*)&(TA_CsUnit_MbrOff=(int CsUnit::*)(&CsUnit::da))),0,NULL,0},
  {&TA_float,NULL,"prv_net"," previous net input","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_CsUnit_MbrOff=(int CsUnit::*)(&CsUnit::prv_net))),0,NULL,0},
  {&TA_float,NULL,"clmp_net"," net input from hard_fast_clamp","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_CsUnit_MbrOff=(int CsUnit::*)(&CsUnit::clmp_net))),0,NULL,0},
  {&TA_float,NULL,"act_m"," minus phase activation","","",
    *((ta_memb_ptr*)&(TA_CsUnit_MbrOff=(int CsUnit::*)(&CsUnit::act_m))),0,NULL,0},
  {&TA_float,NULL,"act_p"," plus phase activation","","",
    *((ta_memb_ptr*)&(TA_CsUnit_MbrOff=(int CsUnit::*)(&CsUnit::act_p))),0,NULL,0},
  {&TA_int,NULL,"n_dwt_aggs"," number of delta-weight aggregations performed","","",
    *((ta_memb_ptr*)&(TA_CsUnit_MbrOff=(int CsUnit::*)(&CsUnit::n_dwt_aggs))),0,NULL,0},
  NULL};
static MethodArgs_data TA_CsUnit_PostSettle_MethArgs[]={
  {&TA_int,NULL,"phase",""},
  NULL};
static MethodArgs_data TA_CsUnit_Aggregate_dWt_MethArgs[]={
  {&TA_int,NULL,"phase",""},
  NULL};
static MethodDef_data TA_CsUnit_MethodDef[]={
  {&TA_void,NULL,"Compute_Act","","","",
    2,0,-1,0,NULL,cssElCFun_CsUnit_Compute_Act_stub,NULL},
  {&TA_void,NULL,"Compute_ClampAct","","","",
    0,0,-1,0,NULL,cssElCFun_CsUnit_Compute_ClampAct_stub,NULL},
  {&TA_void,NULL,"Compute_ClampNet","","","",
    0,0,-1,0,NULL,cssElCFun_CsUnit_Compute_ClampNet_stub,NULL},
  {&TA_void,NULL,"Targ_To_Ext","","","",
    0,0,-1,0,NULL,cssElCFun_CsUnit_Targ_To_Ext_stub,NULL},
  {&TA_void,NULL,"PostSettle","","","",
    0,1,-1,0,NULL,cssElCFun_CsUnit_PostSettle_stub,TA_CsUnit_PostSettle_MethArgs},
  {&TA_void,NULL,"Aggregate_dWt","","","",
    0,1,-1,0,NULL,cssElCFun_CsUnit_Aggregate_dWt_stub,TA_CsUnit_Aggregate_dWt_MethArgs},
  NULL};
static int CsSample::* TA_CsSample_MbrOff;
static MemberDef_data TA_CsSample_MemberDef[]={
  {&TA_Counter,NULL,"sample","","","",
    *((ta_memb_ptr*)&(TA_CsSample_MbrOff=(int CsSample::*)(&CsSample::sample))),0,NULL,0},
  NULL};
static MethodDef_data TA_CsSample_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," computes weight changes for all units in network","","",
    0,0,-1,0,NULL,cssElCFun_CsSample_Compute_dWt_stub,NULL},
  NULL};
static EnumDef_data TA_CsTrial_StateInit[]={
  {"DO_NOTHING"," do nothing","",0},
  {"INIT_STATE"," initialize the network state","",1},
  {"MODIFY_STATE"," modify state (algorithm specific)","",2},
  NULL};
static EnumDef_data TA_CsTrial_Phase[]={
  {"MINUS_PHASE","","",-1},
  {"PLUS_PHASE","","",1},
  NULL};
static int CsTrial::* TA_CsTrial_MbrOff;
static MemberDef_data TA_CsTrial_MemberDef[]={
  {&TA_Counter,NULL,"phase_no"," current phase number","","",
    *((ta_memb_ptr*)&(TA_CsTrial_MbrOff=(int CsTrial::*)(&CsTrial::phase_no))),0,NULL,0},
  {NULL,"::Phase","phase"," state variable for phase","","",
    *((ta_memb_ptr*)&(TA_CsTrial_MbrOff=(int CsTrial::*)(&CsTrial::phase))),0,NULL,0},
  {NULL,"::StateInit","trial_init"," how to initialize network at start of trial","","",
    *((ta_memb_ptr*)&(TA_CsTrial_MbrOff=(int CsTrial::*)(&CsTrial::trial_init))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_stats"," don't do stats/logging in plus phase","","",
    *((ta_memb_ptr*)&(TA_CsTrial_MbrOff=(int CsTrial::*)(&CsTrial::no_plus_stats))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_test"," don't do plus phase when testing","","",
    *((ta_memb_ptr*)&(TA_CsTrial_MbrOff=(int CsTrial::*)(&CsTrial::no_plus_test))),0,NULL,0},
  NULL};
static MethodArgs_data TA_CsTrial_GenCntrLog_MethArgs[]={
  {&TA_LogData_ptr,NULL,"ld",""},
  {&TA_bool,NULL,"gen",""},
  NULL};
static MethodDef_data TA_CsTrial_MethodDef[]={
  {&TA_void,NULL,"GenCntrLog"," generate log data for the counters","","",
    1,2,-1,0,NULL,cssElCFun_CsTrial_GenCntrLog_stub,TA_CsTrial_GenCntrLog_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," computes weight changes for all units in network","","",
    0,0,-1,0,NULL,cssElCFun_CsTrial_Compute_dWt_stub,NULL},
  NULL};
static EnumDef_data TA_CsSettle_StateInit[]={
  {"DO_NOTHING"," do nothing","",0},
  {"INIT_STATE"," initialize the network state","",1},
  {"MODIFY_STATE"," modify state (algorithm specific)","",2},
  NULL};
static int CsSettle::* TA_CsSettle_MbrOff;
static MemberDef_data TA_CsSettle_MemberDef[]={
  {&TA_CsTrial_ptr,NULL,"cs_trial"," ","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsSettle_MbrOff=(int CsSettle::*)(&CsSettle::cs_trial))),0,NULL,0},
  {NULL,"::StateInit","between_phases"," what to do between phases","","",
    *((ta_memb_ptr*)&(TA_CsSettle_MbrOff=(int CsSettle::*)(&CsSettle::between_phases))),0,NULL,0},
  {&TA_uint,NULL,"n_units"," for asynchronous update in cycle process","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_CsSettle_MbrOff=(int CsSettle::*)(&CsSettle::n_units))),0,NULL,0},
  {&TA_bool,NULL,"deterministic"," only compute stats after the last cycle (deterministic mode)","","",
    *((ta_memb_ptr*)&(TA_CsSettle_MbrOff=(int CsSettle::*)(&CsSettle::deterministic))),0,NULL,0},
  {&TA_int,NULL,"start_stats"," the cycle at which to start aggregating dWt","CONDEDIT_ON_deterministic:false ","",
    *((ta_memb_ptr*)&(TA_CsSettle_MbrOff=(int CsSettle::*)(&CsSettle::start_stats))),0,NULL,0},
  NULL};
static MethodDef_data TA_CsSettle_MethodDef[]={
  {&TA_void,NULL,"Compute_ClampAct","","","",
    0,0,-1,0,NULL,cssElCFun_CsSettle_Compute_ClampAct_stub,NULL},
  {&TA_void,NULL,"Compute_ClampNet","","","",
    0,0,-1,0,NULL,cssElCFun_CsSettle_Compute_ClampNet_stub,NULL},
  {&TA_void,NULL,"Compute_NUnits","","","",
    0,0,-1,0,NULL,cssElCFun_CsSettle_Compute_NUnits_stub,NULL},
  {&TA_void,NULL,"Targ_To_Ext","","","",
    0,0,-1,0,NULL,cssElCFun_CsSettle_Targ_To_Ext_stub,NULL},
  {&TA_void,NULL,"PostSettle","","","",
    0,0,-1,0,NULL,cssElCFun_CsSettle_PostSettle_stub,NULL},
  {&TA_void,NULL,"Aggregate_dWt","","","",
    0,0,-1,0,NULL,cssElCFun_CsSettle_Aggregate_dWt_stub,NULL},
  NULL};
static EnumDef_data TA_CsCycle_UpdateMode[]={
  {"SYNCHRONOUS","","",0},
  {"ASYNCHRONOUS","","",1},
  {"SYNC_SENDER_BASED"," needed for IAC send_thresh impl","",2},
  NULL};
static int CsCycle::* TA_CsCycle_MbrOff;
static MemberDef_data TA_CsCycle_MemberDef[]={
  {&TA_CsSettle_ptr,NULL,"cs_settle"," ","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsCycle_MbrOff=(int CsCycle::*)(&CsCycle::cs_settle))),0,NULL,0},
  {&TA_CsTrial_ptr,NULL,"cs_trial"," ","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsCycle_MbrOff=(int CsCycle::*)(&CsCycle::cs_trial))),0,NULL,0},
  {NULL,"::UpdateMode","update_mode"," how to update: async = n_updates, sync = all units. sender_based is for IAC","","",
    *((ta_memb_ptr*)&(TA_CsCycle_MbrOff=(int CsCycle::*)(&CsCycle::update_mode))),0,NULL,0},
  {&TA_int,NULL,"n_updates"," for ASYNC mode, number of updates (with replacement) to perform in one cycle","CONDEDIT_ON_update_mode:ASYNCHRONOUS ","",
    *((ta_memb_ptr*)&(TA_CsCycle_MbrOff=(int CsCycle::*)(&CsCycle::n_updates))),0,NULL,0},
  NULL};
static MethodDef_data TA_CsCycle_MethodDef[]={
  {&TA_void,NULL,"Compute_SyncAct","","","",
    0,0,-1,0,NULL,cssElCFun_CsCycle_Compute_SyncAct_stub,NULL},
  {&TA_void,NULL,"Compute_AsyncAct","","","",
    0,0,-1,0,NULL,cssElCFun_CsCycle_Compute_AsyncAct_stub,NULL},
  {&TA_void,NULL,"Aggregate_dWt","","","",
    0,0,-1,0,NULL,cssElCFun_CsCycle_Aggregate_dWt_stub,NULL},
  NULL};
static int CsMaxDa::* TA_CsMaxDa_MbrOff;
static MemberDef_data TA_CsMaxDa_MemberDef[]={
  {&TA_SettleProcess_ptr,NULL,"settle"," settle process to record","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsMaxDa_MbrOff=(int CsMaxDa::*)(&CsMaxDa::settle))),0,NULL,0},
  {&TA_StatVal,NULL,"da"," delta-activation","","",
    *((ta_memb_ptr*)&(TA_CsMaxDa_MbrOff=(int CsMaxDa::*)(&CsMaxDa::da))),0,NULL,0},
  NULL};
static MethodArgs_data TA_CsMaxDa_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_CsMaxDa_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_CsMaxDa_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"unit",""},
  NULL};
static MethodDef_data TA_CsMaxDa_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_CsMaxDa_RecvCon_Run_stub,TA_CsMaxDa_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_CsMaxDa_SendCon_Run_stub,TA_CsMaxDa_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_CsMaxDa_Unit_Stat_stub,TA_CsMaxDa_Unit_Stat_MethArgs},
  NULL};
static int CsDistStat::* TA_CsDistStat_MbrOff;
static MemberDef_data TA_CsDistStat_MemberDef[]={
  {&TA_CsSettle_ptr,NULL,"cs_settle"," ","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsDistStat_MbrOff=(int CsDistStat::*)(&CsDistStat::cs_settle))),0,NULL,0},
  {&TA_StatVal_List,NULL,"probs"," prob of each dist pattern","","",
    *((ta_memb_ptr*)&(TA_CsDistStat_MbrOff=(int CsDistStat::*)(&CsDistStat::probs))),0,NULL,0},
  {&TA_float_RArray,NULL,"act_vals"," the act values read from network","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_CsDistStat_MbrOff=(int CsDistStat::*)(&CsDistStat::act_vals))),0,NULL,0},
  {&TA_float,NULL,"tolerance"," the tolerance for judging if act=targ","","",
    *((ta_memb_ptr*)&(TA_CsDistStat_MbrOff=(int CsDistStat::*)(&CsDistStat::tolerance))),0,NULL,0},
  {&TA_int,NULL,"n_updates"," the number of stat cycles so far","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_CsDistStat_MbrOff=(int CsDistStat::*)(&CsDistStat::n_updates))),0,NULL,0},
  NULL};
static int CsTIGstat::* TA_CsTIGstat_MbrOff;
static MemberDef_data TA_CsTIGstat_MemberDef[]={
  {&TA_TrialProcess_ptr,NULL,"trial_proc"," need to get cur_event","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_CsTIGstat_MbrOff=(int CsTIGstat::*)(&CsTIGstat::trial_proc))),0,NULL,0},
  {&TA_StatVal,NULL,"tig"," the Information Gain for the trial","","",
    *((ta_memb_ptr*)&(TA_CsTIGstat_MbrOff=(int CsTIGstat::*)(&CsTIGstat::tig))),0,NULL,0},
  {&TA_CsDistStat_ptr,NULL,"dist_stat"," get the actual distributions from this stat","","",
    *((ta_memb_ptr*)&(TA_CsTIGstat_MbrOff=(int CsTIGstat::*)(&CsTIGstat::dist_stat))),0,NULL,0},
  NULL};
static int CsTargStat::* TA_CsTargStat_MbrOff;
static MemberDef_data TA_CsTargStat_MemberDef[]={
  {&TA_StatVal,NULL,"trg_pct"," the pct in target for the trial","","",
    *((ta_memb_ptr*)&(TA_CsTargStat_MbrOff=(int CsTargStat::*)(&CsTargStat::trg_pct))),0,NULL,0},
  {&TA_CsDistStat_ptr,NULL,"dist_stat"," get the actual distributions from this stat","","",
    *((ta_memb_ptr*)&(TA_CsTargStat_MbrOff=(int CsTargStat::*)(&CsTargStat::dist_stat))),0,NULL,0},
  NULL};
static int CsGoodStat::* TA_CsGoodStat_MbrOff;
static MemberDef_data TA_CsGoodStat_MemberDef[]={
  {&TA_bool,NULL,"use_netin"," use net-input for harmony instead of computing anew?","","",
    *((ta_memb_ptr*)&(TA_CsGoodStat_MbrOff=(int CsGoodStat::*)(&CsGoodStat::use_netin))),0,NULL,0},
  {&TA_StatVal,NULL,"hrmny","","","",
    *((ta_memb_ptr*)&(TA_CsGoodStat_MbrOff=(int CsGoodStat::*)(&CsGoodStat::hrmny))),0,NULL,0},
  {&TA_StatVal,NULL,"strss","","","",
    *((ta_memb_ptr*)&(TA_CsGoodStat_MbrOff=(int CsGoodStat::*)(&CsGoodStat::strss))),0,NULL,0},
  {&TA_StatVal,NULL,"gdnss","","","",
    *((ta_memb_ptr*)&(TA_CsGoodStat_MbrOff=(int CsGoodStat::*)(&CsGoodStat::gdnss))),0,NULL,0},
  {&TA_float,NULL,"netin_hrmny"," temp variable to hold netin-based harmony","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_CsGoodStat_MbrOff=(int CsGoodStat::*)(&CsGoodStat::netin_hrmny))),0,NULL,0},
  NULL};
static MethodArgs_data TA_CsGoodStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"unit",""},
  NULL};
static MethodArgs_data TA_CsGoodStat_Unit_Init_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  NULL};
static MethodArgs_data TA_CsGoodStat_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  NULL};
static MethodArgs_data TA_CsGoodStat_Con_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_CsGoodStat_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit check for use_netin case...","","",
    1,1,-1,0,NULL,cssElCFun_CsGoodStat_RecvCon_Run_stub,TA_CsGoodStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"Unit_Init"," Initialize before computing unit","","",
    1,1,-1,0,NULL,cssElCFun_CsGoodStat_Unit_Init_stub,TA_CsGoodStat_Unit_Init_MethArgs},
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_CsGoodStat_Unit_Stat_stub,TA_CsGoodStat_Unit_Stat_MethArgs},
  {&TA_void,NULL,"Con_Stat"," Compute statistic on a recv unit, connection, sending unit ","","",
    1,3,-1,0,NULL,cssElCFun_CsGoodStat_Con_Stat_stub,TA_CsGoodStat_Con_Stat_MethArgs},
  NULL};
static int ThreshLinCsUnitSpec::* TA_ThreshLinCsUnitSpec_MbrOff;
static MemberDef_data TA_ThreshLinCsUnitSpec_MemberDef[]={
  {&TA_float,NULL,"threshold","","","",
    *((ta_memb_ptr*)&(TA_ThreshLinCsUnitSpec_MbrOff=(int ThreshLinCsUnitSpec::*)(&ThreshLinCsUnitSpec::threshold))),0,NULL,0},
  NULL};
static MethodArgs_data TA_HebbCsConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_CsCon_ptr,NULL,"cn",""},
  {&TA_CsUnit_ptr,NULL,"ru",""},
  {&TA_CsUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_HebbCsConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodDef_data TA_HebbCsConSpec_MethodDef[]={
  {&TA_void,NULL,"C_Compute_dWt","","","",
    1,3,-1,0,NULL,cssElCFun_HebbCsConSpec_C_Compute_dWt_stub,TA_HebbCsConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change","","",
    1,2,-1,0,NULL,cssElCFun_HebbCsConSpec_Compute_dWt_stub,TA_HebbCsConSpec_Compute_dWt_MethArgs},
  NULL};

// Init Function


static bool ta_Init_cs_done = false;

void ta_Init_cs() {
  TypeDef* sbt;

  if(ta_Init_cs_done) return;
  ta_Init_cs_done = true;

  ta_Init_ta();
  ta_Init_pdp();
  ta_Init_ta_misc();
  ta_Init_iv_graphic();

  taMisc::in_init = true;

    tac_AddMethods(TA_taRegFun,TA_taRegFun_MethodDef);
  taMisc::types.Add(&TA_CsCon);
    TAI_CsCon = new CsCon;
    TA_CsCon.AddParFormal(&TA_class);
    TA_CsCon.AddParCache(&TA_taBase);
    TA_CsCon.AddClassPar(&TA_Connection,0);
    tac_AddMembers(TA_CsCon,TA_CsCon_MemberDef);
  taMisc::types.Add(&TA_CsConSpec);
    TAI_CsConSpec = new CsConSpec;
    TA_CsConSpec.AddParFormal(&TA_class);
    TA_CsConSpec.AddParCache(&TA_taBase);
    TA_CsConSpec.AddClassPar(&TA_ConSpec,0);
    tac_AddMembers(TA_CsConSpec,TA_CsConSpec_MemberDef);
    tac_AddMethods(TA_CsConSpec,TA_CsConSpec_MethodDef);
  taMisc::types.Add(&TA_CsCon_Group);
    TAI_CsCon_Group = new CsCon_Group;
    TA_CsCon_Group.AddParFormal(&TA_class);
    TA_CsCon_Group.AddParCache(&TA_taBase);
    TA_CsCon_Group.AddClassPar(&TA_Con_Group,0);
    tac_AddMethods(TA_CsCon_Group,TA_CsCon_Group_MethodDef);
  taMisc::types.Add(&TA_CsUnitSpec);
    TAI_CsUnitSpec = new CsUnitSpec;
    TA_CsUnitSpec.AddParFormal(&TA_class);
    TA_CsUnitSpec.AddParCache(&TA_taBase);
    TA_CsUnitSpec.AddClassPar(&TA_UnitSpec,0);
    tac_AddEnum(TA_CsUnitSpec, "ClampType", "", "", "", "", TA_CsUnitSpec_ClampType);
    tac_AddMembers(TA_CsUnitSpec,TA_CsUnitSpec_MemberDef);
    tac_AddMethods(TA_CsUnitSpec,TA_CsUnitSpec_MethodDef);
  taMisc::types.Add(&TA_SigmoidUnitSpec);
    TAI_SigmoidUnitSpec = new SigmoidUnitSpec;
    TA_SigmoidUnitSpec.AddParFormal(&TA_class);
    TA_SigmoidUnitSpec.AddParCache(&TA_taBase);
    TA_SigmoidUnitSpec.AddClassPar(&TA_CsUnitSpec,0);
    tac_AddEnum(TA_SigmoidUnitSpec, "TimeAvgType", " type of time-averaging to perform", "", "", "", TA_SigmoidUnitSpec_TimeAvgType);
    tac_AddMembers(TA_SigmoidUnitSpec,TA_SigmoidUnitSpec_MemberDef);
  taMisc::types.Add(&TA_BoltzUnitSpec);
    TAI_BoltzUnitSpec = new BoltzUnitSpec;
    TA_BoltzUnitSpec.AddParFormal(&TA_class);
    TA_BoltzUnitSpec.AddParCache(&TA_taBase);
    TA_BoltzUnitSpec.AddClassPar(&TA_CsUnitSpec,0);
    tac_AddMembers(TA_BoltzUnitSpec,TA_BoltzUnitSpec_MemberDef);
  taMisc::types.Add(&TA_IACUnitSpec);
    TAI_IACUnitSpec = new IACUnitSpec;
    TA_IACUnitSpec.AddParFormal(&TA_class);
    TA_IACUnitSpec.AddParCache(&TA_taBase);
    TA_IACUnitSpec.AddClassPar(&TA_CsUnitSpec,0);
    tac_AddMembers(TA_IACUnitSpec,TA_IACUnitSpec_MemberDef);
    tac_AddMethods(TA_IACUnitSpec,TA_IACUnitSpec_MethodDef);
  taMisc::types.Add(&TA_CsUnit);
    TAI_CsUnit = new CsUnit;
    TA_CsUnit.AddParFormal(&TA_class);
    TA_CsUnit.AddParCache(&TA_taBase);
    TA_CsUnit.AddClassPar(&TA_Unit,0);
    tac_AddMembers(TA_CsUnit,TA_CsUnit_MemberDef);
    tac_AddMethods(TA_CsUnit,TA_CsUnit_MethodDef);
  taMisc::types.Add(&TA_CsSample);
    TAI_CsSample = new CsSample;
    TA_CsSample.AddParFormal(&TA_class);
    TA_CsSample.AddParCache(&TA_taBase);
    TA_CsSample.AddClassPar(&TA_TrialProcess,0);
    tac_AddMembers(TA_CsSample,TA_CsSample_MemberDef);
    tac_AddMethods(TA_CsSample,TA_CsSample_MethodDef);
  taMisc::types.Add(&TA_CsTrial);
    TAI_CsTrial = new CsTrial;
    TA_CsTrial.AddParFormal(&TA_class);
    TA_CsTrial.AddParCache(&TA_taBase);
    TA_CsTrial.AddClassPar(&TA_TrialProcess,0);
    tac_AddEnum(TA_CsTrial, "StateInit", " ways of initializing the state of the network", "", "", "", TA_CsTrial_StateInit);
    tac_AddEnum(TA_CsTrial, "Phase", "", "", "", "", TA_CsTrial_Phase);
    tac_AddMembers(TA_CsTrial,TA_CsTrial_MemberDef);
    tac_AddMethods(TA_CsTrial,TA_CsTrial_MethodDef);
  taMisc::types.Add(&TA_CsSettle);
    TAI_CsSettle = new CsSettle;
    TA_CsSettle.AddParFormal(&TA_class);
    TA_CsSettle.AddParCache(&TA_taBase);
    TA_CsSettle.AddClassPar(&TA_SettleProcess,0);
    tac_AddEnum(TA_CsSettle, "StateInit", " ways of initializing the state of the network", "", "", "", TA_CsSettle_StateInit);
    tac_AddMembers(TA_CsSettle,TA_CsSettle_MemberDef);
    tac_AddMethods(TA_CsSettle,TA_CsSettle_MethodDef);
  taMisc::types.Add(&TA_CsCycle);
    TAI_CsCycle = new CsCycle;
    TA_CsCycle.AddParFormal(&TA_class);
    TA_CsCycle.AddParCache(&TA_taBase);
    TA_CsCycle.AddClassPar(&TA_CycleProcess,0);
    tac_AddEnum(TA_CsCycle, "UpdateMode", "", "", "", "", TA_CsCycle_UpdateMode);
    tac_AddMembers(TA_CsCycle,TA_CsCycle_MemberDef);
    tac_AddMethods(TA_CsCycle,TA_CsCycle_MethodDef);
  taMisc::types.Add(&TA_CsMaxDa);
    TAI_CsMaxDa = new CsMaxDa;
    TA_CsMaxDa.AddParFormal(&TA_class);
    TA_CsMaxDa.AddParCache(&TA_taBase);
    TA_CsMaxDa.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_CsMaxDa,TA_CsMaxDa_MemberDef);
    tac_AddMethods(TA_CsMaxDa,TA_CsMaxDa_MethodDef);
  taMisc::types.Add(&TA_CsDistStat);
    TAI_CsDistStat = new CsDistStat;
    TA_CsDistStat.AddParFormal(&TA_class);
    TA_CsDistStat.AddParCache(&TA_taBase);
    TA_CsDistStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_CsDistStat,TA_CsDistStat_MemberDef);
  taMisc::types.Add(&TA_CsTIGstat);
    TAI_CsTIGstat = new CsTIGstat;
    TA_CsTIGstat.AddParFormal(&TA_class);
    TA_CsTIGstat.AddParCache(&TA_taBase);
    TA_CsTIGstat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_CsTIGstat,TA_CsTIGstat_MemberDef);
  taMisc::types.Add(&TA_CsTargStat);
    TAI_CsTargStat = new CsTargStat;
    TA_CsTargStat.AddParFormal(&TA_class);
    TA_CsTargStat.AddParCache(&TA_taBase);
    TA_CsTargStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_CsTargStat,TA_CsTargStat_MemberDef);
  taMisc::types.Add(&TA_CsGoodStat);
    TAI_CsGoodStat = new CsGoodStat;
    TA_CsGoodStat.AddParFormal(&TA_class);
    TA_CsGoodStat.AddParCache(&TA_taBase);
    TA_CsGoodStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_CsGoodStat,TA_CsGoodStat_MemberDef);
    tac_AddMethods(TA_CsGoodStat,TA_CsGoodStat_MethodDef);
  taMisc::types.Add(&TA_const_CsCon);
    TA_const_CsCon.AddParents(&TA_const, &TA_CsCon);
  taMisc::types.Add(&TA_const_CsCon_ref);
    TA_const_CsCon_ref.AddParents(&TA_const_CsCon);
  taMisc::types.Add(&TA_CsConSpec_ptr);
    TA_CsConSpec_ptr.AddParents(&TA_CsConSpec);
  taMisc::types.Add(&TA_CsCon_ptr);
    TA_CsCon_ptr.AddParents(&TA_CsCon);
  taMisc::types.Add(&TA_CsUnit_ptr);
    TA_CsUnit_ptr.AddParents(&TA_CsUnit);
  taMisc::types.Add(&TA_CsCon_Group_ptr);
    TA_CsCon_Group_ptr.AddParents(&TA_CsCon_Group);
  taMisc::types.Add(&TA_const_CsConSpec);
    TA_const_CsConSpec.AddParents(&TA_const, &TA_CsConSpec);
  taMisc::types.Add(&TA_const_CsConSpec_ref);
    TA_const_CsConSpec_ref.AddParents(&TA_const_CsConSpec);
  taMisc::types.Add(&TA_const_CsCon_Group);
    TA_const_CsCon_Group.AddParents(&TA_const, &TA_CsCon_Group);
  taMisc::types.Add(&TA_const_CsCon_Group_ref);
    TA_const_CsCon_Group_ref.AddParents(&TA_const_CsCon_Group);
  taMisc::types.Add(&TA_const_CsUnitSpec);
    TA_const_CsUnitSpec.AddParents(&TA_const, &TA_CsUnitSpec);
  taMisc::types.Add(&TA_const_CsUnitSpec_ref);
    TA_const_CsUnitSpec_ref.AddParents(&TA_const_CsUnitSpec);
  taMisc::types.Add(&TA_const_SigmoidUnitSpec);
    TA_const_SigmoidUnitSpec.AddParents(&TA_const, &TA_SigmoidUnitSpec);
  taMisc::types.Add(&TA_const_SigmoidUnitSpec_ref);
    TA_const_SigmoidUnitSpec_ref.AddParents(&TA_const_SigmoidUnitSpec);
  taMisc::types.Add(&TA_const_BoltzUnitSpec);
    TA_const_BoltzUnitSpec.AddParents(&TA_const, &TA_BoltzUnitSpec);
  taMisc::types.Add(&TA_const_BoltzUnitSpec_ref);
    TA_const_BoltzUnitSpec_ref.AddParents(&TA_const_BoltzUnitSpec);
  taMisc::types.Add(&TA_const_IACUnitSpec);
    TA_const_IACUnitSpec.AddParents(&TA_const, &TA_IACUnitSpec);
  taMisc::types.Add(&TA_const_IACUnitSpec_ref);
    TA_const_IACUnitSpec_ref.AddParents(&TA_const_IACUnitSpec);
  taMisc::types.Add(&TA_LinearCsUnitSpec);
    TAI_LinearCsUnitSpec = new LinearCsUnitSpec;
    TA_LinearCsUnitSpec.AddParFormal(&TA_class);
    TA_LinearCsUnitSpec.AddParCache(&TA_taBase);
    TA_LinearCsUnitSpec.AddClassPar(&TA_CsUnitSpec,0);
  taMisc::types.Add(&TA_const_LinearCsUnitSpec);
    TA_const_LinearCsUnitSpec.AddParents(&TA_const, &TA_LinearCsUnitSpec);
  taMisc::types.Add(&TA_ThreshLinCsUnitSpec);
    TAI_ThreshLinCsUnitSpec = new ThreshLinCsUnitSpec;
    TA_ThreshLinCsUnitSpec.AddParFormal(&TA_class);
    TA_ThreshLinCsUnitSpec.AddParCache(&TA_taBase);
    TA_ThreshLinCsUnitSpec.AddClassPar(&TA_CsUnitSpec,0);
    tac_AddMembers(TA_ThreshLinCsUnitSpec,TA_ThreshLinCsUnitSpec_MemberDef);
  taMisc::types.Add(&TA_const_LinearCsUnitSpec_ref);
    TA_const_LinearCsUnitSpec_ref.AddParents(&TA_const_LinearCsUnitSpec);
  taMisc::types.Add(&TA_const_CsUnit);
    TA_const_CsUnit.AddParents(&TA_const, &TA_CsUnit);
  taMisc::types.Add(&TA_const_ThreshLinCsUnitSpec);
    TA_const_ThreshLinCsUnitSpec.AddParents(&TA_const, &TA_ThreshLinCsUnitSpec);
  taMisc::types.Add(&TA_const_CsUnit_ref);
    TA_const_CsUnit_ref.AddParents(&TA_const_CsUnit);
  taMisc::types.Add(&TA_const_ThreshLinCsUnitSpec_ref);
    TA_const_ThreshLinCsUnitSpec_ref.AddParents(&TA_const_ThreshLinCsUnitSpec);
  taMisc::types.Add(&TA_CsSettle_ptr);
    TA_CsSettle_ptr.AddParents(&TA_CsSettle);
  taMisc::types.Add(&TA_CsTrial_ptr);
    TA_CsTrial_ptr.AddParents(&TA_CsTrial);
  taMisc::types.Add(&TA_const_CsCycle);
    TA_const_CsCycle.AddParents(&TA_const, &TA_CsCycle);
  taMisc::types.Add(&TA_const_CsCycle_ref);
    TA_const_CsCycle_ref.AddParents(&TA_const_CsCycle);
  taMisc::types.Add(&TA_const_CsSettle);
    TA_const_CsSettle.AddParents(&TA_const, &TA_CsSettle);
  taMisc::types.Add(&TA_const_CsSettle_ref);
    TA_const_CsSettle_ref.AddParents(&TA_const_CsSettle);
  taMisc::types.Add(&TA_const_CsTrial);
    TA_const_CsTrial.AddParents(&TA_const, &TA_CsTrial);
  taMisc::types.Add(&TA_const_CsTrial_ref);
    TA_const_CsTrial_ref.AddParents(&TA_const_CsTrial);
  taMisc::types.Add(&TA_const_CsSample);
    TA_const_CsSample.AddParents(&TA_const, &TA_CsSample);
  taMisc::types.Add(&TA_const_CsSample_ref);
    TA_const_CsSample_ref.AddParents(&TA_const_CsSample);
  taMisc::types.Add(&TA_const_CsMaxDa);
    TA_const_CsMaxDa.AddParents(&TA_const, &TA_CsMaxDa);
  taMisc::types.Add(&TA_const_CsMaxDa_ref);
    TA_const_CsMaxDa_ref.AddParents(&TA_const_CsMaxDa);
  taMisc::types.Add(&TA_const_CsDistStat);
    TA_const_CsDistStat.AddParents(&TA_const, &TA_CsDistStat);
  taMisc::types.Add(&TA_const_CsDistStat_ref);
    TA_const_CsDistStat_ref.AddParents(&TA_const_CsDistStat);
  taMisc::types.Add(&TA_CsDistStat_ptr);
    TA_CsDistStat_ptr.AddParents(&TA_CsDistStat);
  taMisc::types.Add(&TA_const_CsTIGstat);
    TA_const_CsTIGstat.AddParents(&TA_const, &TA_CsTIGstat);
  taMisc::types.Add(&TA_const_CsTIGstat_ref);
    TA_const_CsTIGstat_ref.AddParents(&TA_const_CsTIGstat);
  taMisc::types.Add(&TA_const_CsTargStat);
    TA_const_CsTargStat.AddParents(&TA_const, &TA_CsTargStat);
  taMisc::types.Add(&TA_const_CsTargStat_ref);
    TA_const_CsTargStat_ref.AddParents(&TA_const_CsTargStat);
  taMisc::types.Add(&TA_const_CsGoodStat);
    TA_const_CsGoodStat.AddParents(&TA_const, &TA_CsGoodStat);
  taMisc::types.Add(&TA_const_CsGoodStat_ref);
    TA_const_CsGoodStat_ref.AddParents(&TA_const_CsGoodStat);
  taMisc::types.Add(&TA_HebbCsConSpec);
    TAI_HebbCsConSpec = new HebbCsConSpec;
    TA_HebbCsConSpec.AddParFormal(&TA_class);
    TA_HebbCsConSpec.AddParCache(&TA_taBase);
    TA_HebbCsConSpec.AddClassPar(&TA_CsConSpec,0);
    tac_AddMethods(TA_HebbCsConSpec,TA_HebbCsConSpec_MethodDef);
  taMisc::types.Add(&TA_const_HebbCsConSpec);
    TA_const_HebbCsConSpec.AddParents(&TA_const, &TA_HebbCsConSpec);
  taMisc::types.Add(&TA_const_HebbCsConSpec_ref);
    TA_const_HebbCsConSpec_ref.AddParents(&TA_const_HebbCsConSpec);


  taMisc::in_init = false;
} 
