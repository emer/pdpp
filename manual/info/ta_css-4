This is ta_css, produced by makeinfo version 4.1 from ta_css.texi.


File: ta_css,  Node: prog-typea-files,  Next: prog-typea-args,  Prev: prog-typea,  Up: prog-typea

Scanning Type Information using `maketa'
----------------------------------------

   Type information for TypeAccess is scanned from the header files
using a program called `maketa', which looks for `class' and
`typedef' definitions, and records what it finds.  It operates on all
the header files in a given directory at the same time, and it
produces three output files: `xxx_TA_type.h', `xxx_TA_inst.h', and
`xxx_TA.cc', where xxx is given by a "project name" argument.  The
first file contains a list of `extern' declarations of instances of
the TypeDef type, which is the basic object that records information
about types.  Each type that was defined with a `class' or `typedef',
or ones that are modifications of basic types, such as reference or
pointer types, are given their own TypeDef object, which is named
with the name of the type with a leading `TA_' prefix. Thus, a class
named MyClass would have corresponding TypeDef object named
TA_MyClass, which can be used directly in programs to obtain type
information about the MyClass object. a Pointers have a `_ptr'
suffix, and references have a `_ref' suffix.  Template instances are
represented by replacing the angle brackets with underbars.  The
`xxx_TA_type.h' file must be included in any header files which
reference their own type information.

   The `xxx_TA_inst.h' file contains declarations of "instance"
objects, which are pointers to a token of each of the classes for
which type information is available.  These instances are named `TAI_'
with the rest the same as the corresponding `TA_' name.  The
`-instances' argument to `maketa' determines if instances are made,
and this can be overridden with the `#NO_INSTANCE' and `#INSTANCE'
comment directives (*note prog-comdir::).  The TypeDef object can use
an instance object of one of the type-aware base classes to make a
new token of that object given only the name of the type to be
created.  This gives the system the power to create and delete
objects at will, which is necessary for the file saving and loading
system to work.

   Finally, the `xxx_TA.cc' file contains the actual definitions of
all the type information.  It must be compiled and linked in with the
project, and its `ta_Init_xxx' function must be called at the start
of the execution of the program before any type information is used.

   Note that while `maketa' does process complexities like `template'
and multiply inherited classes properly, it does not deal with
multiple versions of the same function which differ only in argument
type in the same way that C++ does.  Instead, the scanner just keeps
the last version of a given method defined on the class.  This makes
the type information compatible with the limitations of CSS in this
respect, since it does not know how to use argument types to select
the proper function to be called (*note css-c++-diff::).  This
limitation greatly simplifies the way that functions are called by
CSS.  It is recommended that you create methods which have some hint
as to what kinds of arguments they expect, in order to get around this
limitation.  The taList and taGroup classes, for example, contain
both overloaded and specific versions of the `Find' function, so the
C++ programmer can call `Find' with any of a number of different
argument types, while the CSS programmer can use the `FindName' or
`FindType' versions of the function.


File: ta_css,  Node: prog-typea-args,  Next: prog-typea-stru,  Prev: prog-typea-files,  Up: prog-typea

Startup Arguments for `maketa'
------------------------------

   The type-scanning program `maketa' takes the following arguments:

`[-v<level>]'
     Verbosity level, 1-5, 1=results,2=more
     detail,3=trace,4=source,5=parse.

`[-hx | -nohx]'
     Generate .hx, .ccx files instead of .h, .cc.  This is used in
     conjunction with a makefile that compares the .hx with the .h
     version of a file and only updates the .h if it actually differs
     from the .hx version.  This prevents lots of needless
     recompiling when the type-scanned information is not actually
     different when a header file was touched.

`[-css]'
     Generate CSS stub functions.  The stub functions take cssEl*
     arguments, and call member functions on classes.  These must be
     present to use CSS to call member functions on classes, or to
     call functions from the edit dialog menus and buttons.

`[-instances]'
     Generate instance tokens of types.  Instances are needed to make
     tokens of class objects.

`[-class_only | -struct_union]'
     Only scan for `class' types (else `struct' and `union' too). The
     default is to only scan for `class' types because they are
     always used in the definition of a class object.  `struct' and
     `union' can be used to modify the type name in old-style C code,
     which can throw off the scanner since these don't amount to class
     definitions.

`[-I<include>]...'
     Path to include files (one path per -I).

`[-D<define>]...'
     Define a pre-processor macro.

`[-cpp=<cpp command>]'
     Explicit path for c-pre-processor.  The default is to use
     `/usr/lib/cpp', which doesn't work very well on C++ code, but its
     there.  It is recommended that you use cccp, which is the gnu
     preprocessor that comes with gcc.

`[-hash<size>]'
     Size of hash tables (default 2000), use -v1 to see actual sizes
     after parsing all the types.

`project'
     This is the stub project name (generates
     project_TA[.cc|_type.h|_inst.h]).

`files...'
     These are the header files to be processed.


File: ta_css,  Node: prog-typea-stru,  Next: prog-typea-base,  Prev: prog-typea-args,  Up: prog-typea

Structure of TypeAccess Type Data
---------------------------------

   The classes used in storing type information in the TypeAccess
system are all defined in the `ta/typea.h' header file.  Basically,
there are a set of Space objects, which all derive from a basic form
of the `List' object (defined in `ta/ta_list.h', which represent type
spaces, member spaces, method spaces, etc.  These are just containers
of objects.  The spaces are: TypeSpace, MemberSpace, MethodSpace,
EnumSpace, TokenSpace.  Note that they contain functions for finding,
printing, and generally manipulating the objects they contain.

   There are corresponding TypeDef, MemberDef, MethodDef, and EnumDef
objects which hold specific information about the corresponding
aspect of type information.  The TypeDef contains the following
fields:

`String name'
     Holds the name of the type.

`String desc'
     A description which is obtained from the user's comment
     following the declaration of the type.

`uint size'
     The size of the object in bytes.

`int ptr'
     The number of pointers this type is from a basic non-pointer
     type.

`bool ref'
     True if this is a reference type.

`bool internal'
     True if this type information was automatically or internally
     generated.  This typically refers to pointer and reference types
     which were created when the scanner encountered their use in
     arguments or members of other classes that were being scanned.

`bool formal'
     True for basic level objects like `TA_class' and `TA_template'
     which are are formal parents (`par_formal') of types that users
     declare.  These provide a way of determining some basic features
     of the type.  Formal type objects are declared and installed
     automatically by the type scanning system.

`bool pre_parsed'
     True if this type was registered as previously parsed by the
     type scanning system (i.e., it encountered an `extern TypeDef
     TA_xxx' for this type, where xxx is the name of the type).
     These types don't get included in the list of types for this
     directory.  This makes it possible to do type scanning on a
     complex set of nested libraries.

`String_PArray inh_opts'
     These are the options (comment directives) that are inherited by
     this type (i.e., those declared with a `##' instead of a `#').

`String_PArray opts'
     These are all of the options (comment directives) for this type,
     including inherited and non-inherited ones.

`String_PArray lists'
     A list of the `#LIST_xxx' values declared for this type.

`TypeSpace parents'
     A list of parents of this type.  There are multiple parents for
     multiple-inheritance `class' types, and for `internal' types
     which are the combination of basic types, such as `unsigned
     long', etc.

`int_PArray par_off'
     A list of offsets from the start of memory occupied by this
     class where the parent object begins.  These are used for
     multiply inherited class types.  They are in a one-to-one
     correspondence with the `parents' entries.

`TypeSpace par_formal'
     A list of the formal parents of this type, including `TA_class',
     etc.

`TypeSpace par_cache'
     A special cache of frequently-queried type parents.  Currently
     if a type derives from taBase, then `TA_taBase' shows up here
     (because a lot of the TypeAccess code checks if something is
     derived from the basic type-aware type taBase).

`TypeSpace children'
     A list of all the types that are derived from this one.

`void** instance'
     A pointer to a pointer of an instance of this type, if it is
     kept.  The `GetInstance' function should be used to get the
     actual instance pointer.

`TokenSpace tokens'
     A list of the actual instances or tokens of this type that have
     been created by the user (the `TAI_xxx' instance object is not
     registered here).  These are not kept if the type does not
     record tokens (see the `#NO_TOKENS' comment directive, *Note
     comdir-objs::).

`taivType* iv'
     A pointer to an object which defines how a token of this type
     appears in a GUI edit dialog.  There is a "bidding" procedure
     which assigns these objects, allowing for the user to add new
     specialized representations which out-bid the standard ones.
     This bidding takes place when the gui stuff is initialized, and
     the results are stored here.

`taivEdit* ive'
     This is like the `iv' pointer, except it is the object which is
     used to generate the entire edit dialog for this object.  It also
     is the result of a bidding procedure.

`taBase_Group* defaults'
     These are pointers to different TypeDefault objects for this
     type.  Each TypeDefault object is for a different scope where
     these types can be created (i.e., a different Project in the
     PDP++ software).

`EnumSpace enum_vals'
     Contains the enum objects contained within a given `enum'
     declaration.

`TypeSpace sub_types'
     These are the sub-types declared with a `typedef', `enum', or as
     part of a template instantiation within a `class' object.

`MemberSpace members'
     These are the members of a `class' object.

`MethodSpace methods'
     These are the methods of a `class' object.

`TypeSpace templ_pars'
     These are the template parameters for template objects.  In the
     `template' itself, they are the formal parameters (i.e., `T'),
     but in the template instance they point to the actual types with
     which the template was instantiated.

   The most important functions on the TypeDef object are as follows:

`bool HasOption(const char* op)'
     Checks to see if the given option (comment directive) (don't
     include the `#') is present on this type.

`String OptionAfter(const char* op)'
     Returns the portion of the option (comment directive) after the
     given part.  This is used for things like `#MENU_ON_xxx' to
     obtain the xxx part.  If option is not present, an empty string
     is returned.

`InheritsFrom(TypeDef* tp)'
     Checks if this type inherits from the given one (versions that
     take a string and a reference to a TypeDef are also defined).
     Inheritance is defined only for classes, not for a pointer to a
     given class, for example.  Thus, both the argument and the type
     this is called on must be non-pointer, non-reference types.

`DerivesFrom(TypeDef* tp)'
     Simply checks if the given type appears anywhere in the list of
     parents for this type.  Thus, a pointer to a class derives from
     that class, but it does not inherit from it.

`String GetValStr(void* base, void* par=NULL, MemberDef* memb_def=NULL)'
     Uses the type-scanned information to obtain a string
     representation of the value of an instance of this type.  `base'
     is a pointer to the start of a token of this type, and `par' and
     `member_def' can be passed if it is known that this token is in
     a parent class at a particular member def.  This and the
     following function are used widely, including for saving and
     loading of objects, etc.

`SetValStr(const char* val, void* base, void* par=NULL, MemberDef* memb_def=NULL)'
     Takes a string representation of a type instance, and sets the
     value of the token accordingly (it is the inverse of
     `GetValStr').

`CopyFromSameType(void* trg_base, void* src_base, MemberDef* memb_def=NULL)'
     Uses the type-scanned information to copy from one type instance
     to the next.  Any class objects that are members are copied
     using that object's copy operator if one is defined (this is
     only known for derivatives of the taBase base class).

`Dump_Save(ostream& strm, void* base, void* par=NULL, int indent=0)'
     This will save the given type object to a file.  Files are saved
     in an ASCII format, and are capable of saving pointers to other
     objects when these objects derive from the taBase object.
     Special code is present for dealing with groups of objects
     stored in the taList or taGroup classes.  See *Note
     prog-typea-dump:: for more details.

`Dump_Load(istream& strm, void* base, void* par=NULL)'
     This will load a file saved by the `Dump_Save' command.

   The other Def objects are fairly straightforward.  Each includes a
`name' and `desc' field, and a list of `opts' (comment directives)
and `lists'.  Also, each contains an `iv' field which represents the
item in the GUI edit dialog, and is the result of a bidding process
(see the `iv' field in the TypeDef object above).  They all have the
`HasOption' and `OptionAfter' functions plus a number of other useful
functions (see the `ta/typea.h' for details).

   MemberDef objects contain the following additional fields. Note
that derived classes contain links (_not copies_) of the members and
methods they inherit from their parent, except when the class has
multiple parents, in which case copies are made for the derived class
because the offset information will no longer be the same for the
derived class.

`TypeDef* type'
     The type of the member.

`ta_memb_ptr off'
     The address or offset of this member relative to the start of
     the memory allocated for the class in which this member was
     declared.

`int base_off'
     The offset to add to the base address (address of the start of
     the class object) to obtain the start of the class this member
     was declared in.  This is for members of parents of
     multiply-inherited derived classes.

`bool is_static'
     True if the member was declared `static'.  Thus, it can be
     accessed without a `this' pointer.  The `addr' field contains
     its absolute address.

`void* addr'
     The absolute address (not relative to the class object) of a
     static member.

`bool fun_ptr'
     True if the member is actually a pointer to a function.

   The MethodDef object contains the following additional variables:

`TypeDef* type'
     The type of the method.

`bool is_static'
     True if the method was declared `static'.

`ta_void_fun addr'
     The address of a `static' method.  Non-static methods do not
     have their addresses recorded.  Methods are called via the
     `stubp' function, if the `-css' option was used during scanning.

`int fun_overld'
     The number of times this function was overloaded (i.e., a
     function of the same name was declared in the class or its
     parents).  TypeAccess does not perform name mangling on
     functions, so only one instance of a given method is recorded.
     It is the last one that the scanner encounters that is kept.

`int fun_argc'
     The number of arguments for this function.

`int fun_argd'
     The index where the arguments start having default values.
     Thus, the function can be called with a variable number of
     arguments from `fun_argd' to `fun_argc'.

`TypeSpace arg_types'
     These are the types of the arguments.

`String_PArray arg_names'
     These are the names of the arguements (in one-to-one
     correspondence with the types).

`css_fun_stub_ptr stubp'
     A pointer to a "stub" function which calls this method using
     cssEl objects as arguments.  This function is defined in the
     `xxx_TA.cc' file if the `-css' argument is given to `maketa'.
     The cssEl objects have conversion functions for most types of
     arguments, so that the function is called by casting the
     arguments into the types expected by the function.  Pointers to
     class objects are handled by `cssTA' objects which have a
     pointer and a corresponding `TypeDef' pointer, so they know what
     kind of object they point to, making conversion type-safe.
     These stubs return a cssEl object.  They also take a `void*' for
     the `this' object.  These stubs are used both by CSS and to call
     methods from the edit dialogs from menus and buttons.


File: ta_css,  Node: prog-typea-base,  Next: prog-typea-dump,  Prev: prog-typea-stru,  Up: prog-typea

The Type-Aware Base Class taBase
--------------------------------

   There is a basic class type called taBase that uses the TypeAccess
type information to perform a number of special functions
automatically.  This object is aware of its own type information, and
can thus save and load itself, etc.  Special code has been written in
both the TypeAccess system and in CSS that takes advantage of the
interface provided by the taBase type.  Thus, it is recommended that
user's derive all of their types from this base type, and use special
macros to provide derived types with the hooks necessary to get their
own type information and use it effectively.  The type TAPtr is a
`typedef' for a pointer to a taBase object.  The definition of a
taBase object and the macros that are used with it are all in
`ta/ta_base.h'.

   All taBase objects have only one member, which is a reference
counter.  This provides a mechanism for determining when it is safe to
delete an object when the object is being referenced or pointed to in
various different places.  taBase provides a set of referencing and
pointer-management functions that simplify the use of a
reference-count based memory management system.  `Ref' increments the
reference count, `unRef' decrements it, `Done' checks if the refcount
is zero, and deletes the object if it is, and `unRefDone' does both.
`Own' both Ref's an object and sets its owner.  For pointers,
`SetPointer' unrefs any existing object that the pointer points to,
and sets it to point to the new object.  `DelPointer' does an
`unRefDone' on the object pointed to, and sets the pointer to NULL.
`OwnPointer' is like SetPointer except it also sets the owner of the
pointed-to object to the one given by the argument.  See *Note
coding-funs:: and `ta/ta_base.h' for more details.

   The one essential function that taBase provides is `GetTypeDef()',
which is a virtual function that returns a pointer to the `TypeDef'
type descriptor for this object. This function is defined as part of
the basic macro `TA_BASEFUNS', which must be included in all classes
derived from taBase.  This function makes it possible for a generic
pointer to a taBase object to find out what type of object is really
being pointed to.

   There are a number of functions defined on the taBase type that
simply call the corresponding function on the TypeDef pointer.  These
can be found in the `ta/ta_base.h' header file.  They just make it
easier to call these commonly-used functions, instead of requiring the
user to put in a `GetTypeDef' function in between.

   taBase also provides a simplified way of managing the construction,
deletion, and copying of an object.  Basically, construction is broken
down into a set of functions that `Initialize' the member variables,
`Register' the new token with the type if it is keeping track of
tokens, and it sets the default name of the object based on its type
name using `SetDefaultName'.  The `TA_BASEFUNS' macro defines a
default constructor that calls these three functions in that order.
The user thus needs to provide a `Initialize' function for every
class defined, which does the appropriate member initialization.
Note that if this function is not defined, the one on the parent class
will be called twice, so its more efficient to include a blank
Initialize function when there are no members that need to be
initialized.

   The destructor function is similar to the constructor.  A default
destructor is defined in `TA_BASEFUNS', which simply calls
`unRegister', and `Destroy'.  Thus, the user needs to provide a
`Destroy' function which frees any additional resources allocated by
the object, etc.  Like `Initialize', a blank `Destroy' should be
defined when there is nothing that needs to be done to prevent the
parent function from being called twice.

   Copying, cloning, and making a new token of the given type are also
supported in the taBase class.  The `Copy' function performs the
basic copy operations for both the copy constructor and the `='
operator.  This should replace the values of this class and any of its
existing sub-objects with those of the object passed to it, as it is
intended for assignment between two existing objects.  In general, the
`=' operator should be used for copying all members, except for the
case of `LINK_GROUP' groups and lists, which should use the
`BorrowUnique' function (since they do not own the items in the list,
just link them).  `Copy' must call the parent's `Copy' function as
well.  As a minor simplification of calling the parent (and to
provide a copy function for just the items in a given class), it is
conventional to define a `Copy_' function, which does everything
except for calling the parent copy function.  The macro `COPY_FUNS'
can be used to define a `Copy' function which calls the parent
function and then `Copy_'.  The macro `SIMPLE_COPY' defines a `Copy_'
function which uses the type-scanned information to do the copying.
It is slower than hand-coding things, so it probably shouldn't be
used on types which will have a lot of tokens or be copied often.

   A `Clone' function which returns a `TAPtr' to a new duplicate of
this object is defined in `TA_BASEFUNS', as well as an "unsafe"
version of `Copy' (`UnSafeCopy'), which takes a generic `TAPtr'
argument and casts it into their type.  The argument's type should
thus be tested before calling this function.  A safe interface to
this function is provided by the `CopyFrom' function, which does the
type checking.  Finally, the `MakeToken' function will create a new
token of the type.

   The taBase class also contains functions for creating and
manipulating a structure hierarchy of objects.  This is where certain
objects contain groups of other objects, which contain other objects,
etc.  For example, the PDP++ software has a structure hierarchy built
around a root object, which contains projects, which contain lots of
other objects like networks, projects, environments, etc.  Special
container objects like taList and taGroup play an important role in
representing and manipulating this structure (note that it is
possible to write other types of container objects which could play
the same role simply by overloading the same functions that these
objects do).

   When an object is "linked" into the object hierarchy, a function
called `InitLinks' is called.  This function should perform any kind
of initialization that depends on the object being situated in the
hierarchy, like being able to know what object "owns" this one.
taBase has functions for getting and setting the owner of an object.
For example, when a group (taList or taGroup creates a new object and
links it into its list of objects, it calls the `SetOwner' function
with a pointer to itself on this new object, and then it calls
`InitLinks'.  Similarly, when the object is removed from the group,
the `CutLinks' function is called, which should cut any links that
the object has with other objects.

   An object's location in the object hierarchy can be represented by
a _path_ to that object from a global root object.  A given
application is assumed to have a root object, which contains all other
objects.  A pointer to that object is kept in tabMisc::root, which is
used to anchor the path to any given object.  An object can find its
path with the `GetPath' function, and an object can be found from a
path with the `FindFromPath' function.

   Finally, a function for allowing an object to set the values of
certain members based on changes that might have been made in other
members after a user edits the object, called `UpdateAfterEdit', is
provided.  This function is called on most objects after they are
loaded from a save file (except those with the `#NO_UPDATE_AFTER'
comment directive), and on all objects after the user hits Apply or Ok
in an edit dialog, and after any member is set through a CSS assign
statement.  While the object does not know which members were changed
when `UpdateAfterEdit' is called, the object can buffer previous
state on its own to figure this out if it is needed.

   For a step-by-step guide to making a new class that derives from
taBase, see *Note prog-coding::.


File: ta_css,  Node: prog-typea-dump,  Prev: prog-typea-base,  Up: prog-typea

The Dump-file Format for Saving/Loading
---------------------------------------

   The format used for dumping objects to files an loading them back
in involves two passes.  The first pass lists all of the objects to be
saved (i.e., the object that the `Save' function was called on, and
any sub-objects it owns.  This is done so that during loading, all
objects will have been created before pointers to these objects
attempt to be cashed out.  The second pass then saves all of the
values associated with the members in the object.  The format is a
name-value based one, so that files can be loaded back into objects
whose definition has changed.  It skips member names it can't find,
etc, so you can continue to modify your software and still load old
data.

   Paths (i.e., the `GetPath' function) figure heavily into the saving
of objects, especially pointers.  Pointers are saved by giving the
path to the object.  These saved paths are automatically corrected if
the objects are loaded into a different location than the one they
were saved in.  All pointers that are saved are assumed to be
reference-counter based.  Thus, the `SetPointer' function is used to
set the pointer.  Also note that it is impossible to save a pointer
to a non-taBase derived object, since there is no way to get the path
of such an object.


File: ta_css,  Node: prog-comdir,  Next: prog-coding,  Prev: prog-typea,  Up: prog

Standard TypeAccess Comment Directives
======================================

   The following sections document comment directives that are
recognized by the standard TypeAccess GUI and script-language
interfaces.  These must be placed in comments immediately following
the definition of that which the apply to.  Thus, an object directive
should appear as

       class whatever : public something {  // #IGNORE comment goes here

   for members and methods, it should be as follows:
       class whatever : public something {  // #IGNORE comment goes here
         int         member_1;       // #HIDDEN comment goes here
         float       member_2;
         // #READ_ONLY or here
         float       get_real();     /* #USE_RVAL note that multi-line
            old-fashioned c-style comments are legal too! */

* Menu:

* comdir-objs::                 Object Directives
* comdir-membs::                Member Directives
* comdir-meths::                Method Directives
* comdir-funs::                 Top-Level Function Directives
* comdir-pdp::                  PDP++ Specific Directives


File: ta_css,  Node: comdir-objs,  Next: comdir-membs,  Prev: prog-comdir,  Up: prog-comdir

Object Directives
-----------------

   If you add an extra "#" to the beginning of the comment directive,
it will automatically be inherited by any sub-classes of the given
object.  Otherwise, it only applies to the object on which it was
given.

`#IGNORE'
     Do not register this object in the list of types.

`#NO_TOKENS'
     Do not keep a record of the tokens of this object type.  Types
     can keep pointers to all instances or tokens of themselves.
     This can be expensive in terms of memory, but the interface uses
     "token menus" for arguements or methods which are pointers to
     objects of the given type.

`#NO_INSTANCE'
     Do not create a global instance (`TAI_xxx') of this object.  This
     will prevent tokens of this object from being made.

`#INSTANCE'
     If default is not to create instances, then create one anyway
     for this object.

`#NO_MEMBERS'
     Do not store the members (including member functions) of this
     class.  Only the type name will be registered.

`#NO_CSS'
     Do not create CSS stub functions for the member functions on
     this object.

`#INLINE'
     Causes this item to be edited in a single line in a dialog box
     (e.g. for geometry x,y,z) and affects saving/loading, etc.

`#EDIT_INLINE'
     Only causes this item to be edited in a single line in a dialog
     box, but in all other respects it is treated as a normal
     included class.  This is useful for certain complex objects such
     as arrays and lists that do not otherwise save/load well as
     INLINES.

`#BUTROWS_x'
     Set the number of button rows to be x, useful if default
     allocation of number of rows of buttons for edit dialog is not
     correct

`#EXT_xxx'
     Sets the default extension for saving/loading this type to xxx.

`#COMPRESS'
     store dump file's of this object compressed.  Since the save
     files are text, they can be large, so it is a good idea to
     auto-compress dump files for large objects.

`#MEMB_IN_GPMENU'
     This indicates that there is a group object as a member of this
     one who's objects should appear in menus where this object
     appears.

`#VIRT_BASE'
     This is a "virtual" base class: don't show in token menus for
     this object, etc.

`#NO_UPDATE_AFTER'
     Don't call UpdateAfterEdit when loading this object (and other
     places it might automatically get called).  Since a list of
     objects which should be updated after loading is made, small or
     numerous objects should not be added to this list if not
     necessary.

`#IMMEDIATE_UPDATE'
     Perform an immediate UpdateAfterEdit on this object after
     loading (i.e., it creates other objects..).  Normally, updating
     happens after all of the other objects have been loaded.

`#SCOPE_xxx'
     Type of object to use as a scope for this object.  The scope
     restricts token menus and other things to only those things that
     share a common parent token of the given scope type.

`#ARRAY_ALLOC'
     Specific to taList_impl derivatives: this list or group should
     have saved items created all together during loading (ie., like
     an array).  If actually using array-based memory allocation,
     this is essential, but otherwise it can only speed things up a
     little bit.

`#LINK_SAVE'
     Save the actual contents of this object even when it appears as
     a link in a list.  Usually just the link pointer is saved, and
     the object is saved later in the group that actually owns it.
     This overrides this and saves the information in both places -
     can be useful if info from the linked object is needed during
     loading.

`#NO_OK'
     Do not present an OK button on the edit dialog for this object.

`#NO_CANCEL'
     Do not present a CANCEL button on the edit dialog for this
     object.


File: ta_css,  Node: comdir-membs,  Next: comdir-meths,  Prev: comdir-objs,  Up: prog-comdir

Member Directives
-----------------

`#HIDDEN'
     Hides member from user's view in edit dialogs and CSS type
     information printouts.

`#HIDDEN_INLINE'
     Hides member when inlined in another object, but not when edited
     itself.  This only applies to members of #INLINE objects.

`#SHOW'
     Always show this member in the edit dialog (i.e., even if it was
     marked #READ_ONLY).

`#IGNORE'
     Does not register this member in the type information for this
     class.

`#DETAIL'
     Flags this member as a level of detail that the user usually
     does not need to deal with -- can be viewed by changing the Show
     setting in the edit dialog.

`#NO_SAVE'
     This member is not saved when dumping to a file.

`#NO_SAVE_PATH_R'
     Don't create these objects in the 1st pass of the dump file
     (e.g., they will be created automatically by something else,
     usually an #IMMEDIATE_UPDATE UpdateAfterEdit function on a
     parent object).  This can be used to speed up saving and loading
     of large numbers of repetitive objects which can be created
     instead.

`#READ_ONLY'
     Allows the user to see but not edit this item.  By default the
     gui edit dialog will not show these items.  This prevents the
     member from being changed in CSS as well.

`#IV_READ_ONLY'
     Like READ_ONLY, but user can modify the value via CSS (which is
     prevented by READ_ONLY).

`#LIST_xxx'
     Sets the Lookup List for this element.  This is used mainly for
     pointers to functions, where one wants the gui to show a list of
     top-level functions that have been scanned by maketa (*note
     comdir-funs::).

`#TYPE_xxx'
     Sets the default type for members which are pointers to TypeDef
     objects.  This also works for MemberDef pointers.  If xxx is
     'this', then the type of the current object is used.

`#TYPE_ON_xxx'
     For object, TypeDef, or MemberDef pointers: use member xxx of
     this object to anchor the listing of possible types, tokens, or
     members.

`#FROM_GROUP_xxx'
     For token pointers, use given member xxx as the group from which
     to select token options (xxx can be a pointer to a group).

`#GROUP_OPT_OK'
     For FROM_GROUP_xxx mbrs, allows group itself as an option (else
     not allowed).

`#SUBTYPE_xxx'
     Sets this token pointer member to be only subitems (objects
     owned by this one) of type xxx.  A recursive scan of members on
     this object is performed to search for objects of the given type
     as possible values for this field.

`#NO_SUBTYPE'
     Don't search this ptr for possible subitems (use if this ptr
     might point "up", causing a endless loop of searching for
     subitems).

`#NO_FIND'
     Don't search this member for the recursive FindMembeR function
     which searches recursively through objects (use if this ptr
     might point up in the hierarchy, which might cause an endless
     loop).

`#NO_SCOPE'
     Don't use scope for tokens for a token pointer member.  See
     SCOPE object directive

`#LABEL_xxx'
     Set the label for item (or menu or button) to be xxx.

`#OWN_POINTER'
     For a pointer to an object, when loading, set the owner of the
     obj to be this object.  Thus, this pointer is always created and
     owned by this object.

`#NULL_OK'
     A null value is ok as an option for the user (else not) for
     pointer to a type, and SUBTYPE tokens.

`#NO_NULL'
     A null value is not ok (for tokens) (else ok).

`#NO_EDIT'
     Don't include Edit as an option on a token pointer menu (else
     ok).

`#POS_ONLY'
     Only positive (non-negative) integers, this controls behavior of
     the stepper for integer types.

`#LINK_GROUP'
     This group member only has linked items (doesn't allow user to
     create new tokens in this group).

`#IN_GPMENU'
     This members' items should appear in the group menu. The member
     must be a taGroup_impl descendent type, and the class must have a
     MEMB_IN_GPMENU option set.

`#CONDEDIT_xxx'
     This makes editing a member conditional on the value of another
     member.  For example: #CONDEDIT_OFF_type:NONE,LT_MAX specifies
     that this member is to be not editable (OFF) when the type enum
     variable is either NONE or LT_MAX.  One alternatively specify ON
     for conditions when it should be editable.  The comparison is
     based on the string representation of the member value -
     sub-paths to members within contained objects can also be used.

`#DEF_xxx'
     Specifies a default value for the member.  If the field is set
     to a value other than this default value, it will be highlighted
     in yellow to indicate that the value is different from default.
     This should only be used where there are clear default values
     that are typically not changed.

`#AKA_xxx'
     This allows old project files etc to be loaded correctly after
     changing the name of a field or enum by matching xxx to the new
     field/enum.


File: ta_css,  Node: comdir-meths,  Next: comdir-funs,  Prev: comdir-membs,  Up: prog-comdir

Method Directives
-----------------

`#MENU'
     Creates a Menu for this function item in an Edit dialog.

`#MENU_SEP_BEFORE'
     Create a separator before this item in the menu.

`#MENU_SEP_AFTER'
     Create a separator after this item in the menu.

`#MENU_ON_xxx'
     Puts this function on given menu.  Creates menu if not already
     there.  This does not replace the #MENU directive.  Everything
     on the File and Edit menus will be on the edit button for this
     class in an edit dialog.

`#BUTTON'
     Creates a button for this function in the edit dialog.

`#LABEL_xxx'
     Sets the label for item (or menu or button) to be xxx.

`#USE_RVAL'
     Use (display) return value from this function.  Otherwise return
     values are ignored.

`#USE_RVAL_RMB'
     Use (display) return value from this function only if the right
     mouse button was pressed on the Ok button.  Otherwise return
     values are ignored.

`#NO_APPLY_BEFORE'
     Do not apply any changes to dialog before calling this function.
     The default is to apply the changes first.

`#NO_REVERT_AFTER'
     Do not update (revert) dialog after calling this function (and
     do not call the UpdateAfterEdit function either).  The default
     is to do both.

`#UPDATE_MENUS'
     Update the global menus after calling this function (e.g.,
     because altered the structure reflected by those menus).

`#ARGC_x'
     How many args to present to the user (if default args are
     available).

`#ARG_ON_OBJ'
     An argument to this function is an object within the base object
     (e.g., a member of the group).

`#TYPE_xxx'
     For TypeDef pointer args: use given type to anchor the listing
     of possible types.  if xxx == 'this', then the type of the
     current object is used.

`#TYPE_ON_xxx'
     For a function with (any) TypeDef or Token args, uses the member
     xxx of this to anchor type selection or type of tokens to
     present.

`#FROM_GROUP_xxx'
     Performs selection of tokens for args from given group member
     xxx, which is a member of this object (like ARG_ON_OBJ).  Can
     also specify which arg(s) this applies to by doing
     #FROM_GROUP_1_gp: 1 = this arg or below uses from_group, so put
     your from_group args first and specify the highest index as this.

`#NO_GROUP_OPT'
     For FROM_GROUP_xxx args, disallows group itself as an option.

`#NO_SCOPE'
     Don't scope the argument to this function.  See SCOPE object
     directive

`#NO_SCRIPT'
     Do not generate script code to call this function, if script code
     recording is currently active.  *Note comdir-objs::.

`#GHOST_ON_xxx'
     For BUTTON meths, ghosts the button based on the value of
     boolean member xxx of this class.  If member == true, button is
     ghosted.

`#GHOST_OFF_xxx'
     Like above, except if member == false, button is ghosted.

`#CONFIRM'
     For functions with no args, put up a dialog for confirmation
     (shows function description too).

`#NEW_FUN'
     Give user the option to call this (void) function during New (in
     the "new" dialog).

`#NULL_OK'
     A null value is ok as an option for the user (else not). for all
     pointers as args.

`#EDIT_OK'
     Include Edit as an option on the token pointer menu (else not)

`#FILE_ARG_EDIT'
     For functions with one ostream arg, use the normal arg edit
     dialog, instead of a shortcut directly to the file chooser (arg
     edit allows user to choose open mode for saving).

`#QUICK_SAVE'
     For functions with one ostream arg, use existing file name if
     possible (default is to prompt).

`#APPEND_FILE'
     For functions with one ostream arg, use append as the file
     opening mode.


File: ta_css,  Node: comdir-funs,  Next: comdir-pdp,  Prev: comdir-meths,  Up: prog-comdir

Top-Level Function Directives
-----------------------------

   In addition to class objects and typedef's, it is possible to scan
information about certain top-level functions.  These functions must
be preceded by a `#REG_FUN' comment, and the comments that apply to
the function must precede the trailing `;' that ends the function
declaration.

     // #REG_FUN
     void Cs_Simple_WtDecay(CsConSpec* spec, CsCon* cn, Unit* ru, Unit* su)
     // #LIST_CsConSpec_WtDecay Simple weight decay (subtract decay*wt)
          ;				// term here so scanner picks up comment

   These functions get registered as `static' functions of a mythical
object with a TypeDef of `TA_taRegFun'.  The purpose of registering
functions in this way is to make them available for members of
classes that are pointers to functions.  These registered functions
are shown in a menu in the edit dialog if the `#LIST_xxx' directive
matches on the registered function and the pointer to a function.


File: ta_css,  Node: comdir-pdp,  Prev: comdir-funs,  Up: prog-comdir

PDP++ Specific Directives
-------------------------

`#NO_VIEW'
     For real-valued unit members, do not display this item in the
     net view display.

`#AGGOP_xxx'
     (Process object only) sets the default aggregate operator for
     this process's statistics.

`#FINAL_STAT'
     (Stat object only) indicates if this should be created as a
     final stat.

`#LOOP_STAT'
     (Stat object only) indicates if this should be created as a loop
     stat.

`#COMPUTE_IN_xxx'
     (Stat object only) level at which this stat should be computed,
     xxx is a process type.

`#NO_INHERIT'
     In specs, makes member not-inherit from higher-ups.


File: ta_css,  Node: prog-coding,  Prev: prog-comdir,  Up: prog

Coding Conventions and Standards
================================

   This section describes the steps that need to be taken to define a
new class.  Every class based on the taBase type (i.e., all classes in
the PDP++ software) needs to have a set of standard methods (member
functions) that allow it to interface with the rest of the software.
Also, many commonly occurring data types and tasks that a class needs
to perform have been dealt with in a standardized way.  This chapter
familiarizes the programmer with these standards and interfaces.

   Defining a new class is typically the first step a user will take
in programming with the PDP++ software.  This is because the software
is designed to be extended, not revised, by the user.  Fortunately,
most everything that is done by the PDP++ library code can be
overwritten by defining a new class that does something differently,
or simply by adding on to what the existing code does.  Both of these
approaches require the definition of a new class.

   The first step in defining a new class is figuring out which
existing class to base the new one on.  This requires a knowledge of
the existing class structure, which is covered in this manual.  Once
this has been decided, the guidelines in this section should be
followed as closely as possible.  It is assumed that the reader knows
C++ and the basic ideas about constructors, destructors, virtual vs.
non-virtual functions, etc.

* Menu:

* coding-names::                Naming Conventions
* coding-funs::                 Basic Functions


File: ta_css,  Node: coding-names,  Next: coding-funs,  Prev: prog-coding,  Up: prog-coding

Naming Conventions
------------------

   The basic tension in naming something is the length vs.
descriptiveness tradeoff.  In general, we try to avoid abbreviations,
but really long words like "environment" inevitably get shortened to
"Env", etc.

   The bulk of the conventions we have established have to do with
distinguishing between different categories of names: class type
names, member function names, and member names being the major
categories.  In addition, the way in which names composed of multiple
words are formed is discussed.

Object Class Names
==================

   Class types are first-letter-capitalized with words separated by
capitalization: e.g. `MyClass'.  There are certain exceptions, where
an underbar '_' is used to attach a high-frequency suffix, usually
from a template, to the name:

   Common Suffixes:
`_List'
     taList derivative.

`_Group'
     taGroup derivative.

`_MGroup'
     MenuGroup derivative.

`_Array'
     taArray derivative.

`_SPtr'
     Smart Spec object pointer (PDP++).

   Also if the class name contains multiple words, words which are
actually acronyms ending with a capital letter are separated from the
following word by an '_', e.g., (CE_Stat).

   Classes in lower-level libraries also have the name-space
identifier prefixed to the name, which is lower case: e.g., `ta',
`taiv', `css'.

Enums
=====

   `enum' type names follow the same naming convention as class types.
`enum' members are all upper-case, words are separated by '_', e.g.,
`INIT_STATE'.

Member Names
============

   Members are lower-case, words are separated by a '_', e.g.,
member_name.  One exception is for names ending in spec or specs in
which case there is no separation (e.g., viewspecs).

Method Names
============

   Methods are first-letter-capitalized, words are separated by
capitalization (e.g., `RunThis()').  However, there some special
prefixes and suffixes that are exceptions to this rule, because they
are "high frequency" and denote a whole class of methods:

   Prefixes:
`Dump_'
     Saving and loading functions.

`Compute_'
     Network computation functions (PDP++).

`Send_'
     Network communication functions (PDP++).

`C_'
     C code versions of process functions (PDP++).

`Init_'
     Special initialize function for processes (PDP++).

   Suffixes:
`_impl'
     Implementation (guts) of some other function which is the one
     that should be called by the user.

`_xxxx'
     Other _impl type functions that do specific aspects of the
     implementation (xxx is lower case).  Examples in PDP++ include
     _flag, _force.

`_'
     (just a trailing underbar) This is a short version of _impl,
     which is used extensively in InterViews, and sparingly in
     TA/PDP++.

`_post'
     A function which is to be called after another one of the same
     name (for two-step processes).

`_Copy'
     A function called after the Copy function (e.g., to clean up
     pointers).

`_gui'
     A special GUI version of function call.

`_mc'
     A special menu callback version of function call.

