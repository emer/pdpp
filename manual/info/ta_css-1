This is ta_css, produced by makeinfo version 4.1 from ta_css.texi.


File: ta_css,  Node: Top,  Next: copyright,  Prev: (dir),  Up: (dir)

Welcome to the TypeAccess/CSS Manual
====================================

   This describes version 3.0 of the software.

   Manual revision date: 2 May 2003.

* Menu:

* copyright::           Copyright Information
* intro::               Introduction to TypeAccess/CSS
* inst::                Installation Guide
* css::                 Guide to the Script Language (CSS)
* prog::                Programming with TypeAccess
* gui::                 Guide to the Graphical User Interface (GUI)
* obj::                 Object Basics and Basic Objects
* conceptindex::        Index of Key Concepts
* typeindex::           Index of Class Types
* varindex::            Index of Variables
* funcindex::           Index of Functions


File: ta_css,  Node: copyright,  Next: intro,  Prev: Top,  Up: Top

Copyright Information
*********************

   Manual Copyright (C) 1995 Chadley K. Dawson, Randall C. O'Reilly,
James L. McClelland, and Carnegie Mellon University

   Software Copyright (C) 1995 Randall C. O'Reilly, Chadley K. Dawson,
James L. McClelland, and Carnegie Mellon University

   Permission to use, copy, modify, and distribute this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice and this permission notice
appear in all copies of the software and related documentation.

   Note that the PDP++ software package, which contains this package,
has a more restrictive copyright, which applies only to the
PDP++-specific portions of the software, which are labeled as such.

   Note that the taString class, which is derived from the GNU String
class, is Copyright (C) 1988 Free Software Foundation, written by
Doug Lea, and is covered by the GNU General Public License, see
ta_string.h.  The iv_graphic library and some iv_misc classes were
derived from the InterViews morpher example and other InterViews code,
which is Copyright (C) 1987, 1988, 1989, 1990, 1991 Stanford
University Copyright (C) 1991 Silicon Graphics, Inc.

   THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

   IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR ANY
SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON
ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.


File: ta_css,  Node: intro,  Next: inst,  Prev: copyright,  Up: Top

Introduction to TypeAccess/CSS
******************************

   TypeAccess (TA) and CSS were developed in order to automate the
interface to a neural-network simulation package called PDP++.  This
manual is simply a subset of the PDP++ software manual, and it has a
number of references to PDP++ specific objects and issues.  Just
ignore these.

   The TA/CSS system was designed to provide an automatic interface
to C++ objects.  The members and functions on the objects define what
the user can do, and the GUI (graphical user interface) and
script-level interface simply provides a way of accessing the members
and methods of these objects.  Also, a generic, automatic way of
saving and loading objects and structures of objects to disk is
provided.

   The TypeAccess system makes this possible by automatically parsing
the header files in an application directory and creating a record of
the critical type information needed to make the GUI and script
interfaces to these objects.  This type information is also available
for the programmer, as with all RTTI (run-time type information)
systems.

   Unlike most RTTI systems, TA also records the comments from the
source code, which provides the prompts and "comment directives" for
the automatic interface.  The comment directives control how the
member or function is presented to the user, making the interface
quite versatile.

   CSS is an interpreted script language that uses the C/C++ syntax.
It implements most of C and much of the basics of C++.  See *Note
css-c++-diff:: and *Note css-c-diff:: for details on the
discrepancies.  It has a built-in command system for controlling the
execution and debugging of programs.

   CSS is implemented in C++ as a set of objects that basically know
how to "run" themselves, convert themselves into other types, etc.
TypeAccess can generate a set of "stub" functions for class member
functions which take CSS object arguments, and return a CSS object.
These stub functions provide the basis for the CSS interface to
hard-coded classes, and for GUI buttons and pull-down menus which
call member functions.

   The same kind of automatic GUI is also available for classes
defined in CSS.  Thus, it is possible to create entire applications
with automatic GUI interfaces without compiling a line of code.  This
same code can then be compiled with C++ when the application is
stable enough to warrant compiling.

   CSS can also be used as a stand-alone program like Perl or TCL.
This provides the ability to write shell-like scripts in C/C++
instead of learning a complicated new language (use the complicated
language you already know..).  The basic version of CSS has the GNU
libg++ String object as a basic type, as well as standard
stream-based I/O, and all of the usual functions from `unistd.h' and
`math.h', plus some additional special math functions.  It would be
fairly simple to parse a good C++ matrix library under TA/CSS (this
is on the 'todo' list), or some classes that provide faster I/O
primitives for doing specific file-processing tasks, network
protocols, etc.

   The distribution includes a number of low-level objects which
provide transparent access to the TA type information, and basic
container functions like List, Group, and Array, as well as a host of
other object types that were used to implement the PDP++ software.


File: ta_css,  Node: inst,  Next: css,  Prev: intro,  Up: Top

Installation Guide
******************

   This chapter provides a guide to installing the PDP++ software.
There are two basic forms in which the software is distributed -- the
executable files only for use by an "end user", and the complete
source code, for use by a "programmer" who will be compiling new
additions to PDP++.  We will refer to the executable files only
distribution as the "end user's version", and the source code
distribution as the "programmer's version", where the version refers
to the manner in which the software is distributed, not to the
software itself (it's all the same code).

   For most systems, the end user's distribution is obtained in two
parts, a tar file containing pre-compiled binaries for a particular
system, and another which contains the manual, demos, default files,
and other miscellaneous things.  This is for the end user who will
not need to compile new versions of the software to add new
functionality to it.  The relevant tar files are:
       pdp++_version_bin_CPU.tar.gz
       pdp++_version_ext.tar.gz
   where VERSION is the version number of the software release, and
CPU is the cpu-type of the system you will be running on (see below).

   For LINUX systems under RedHat or compatible distributions, an rpm
version (with the `.rpm' extension) is available.

   For MS Windows, a standard `setup' install file (with the `.exe'
extension) is available.

   For Mac OS-X, a standard "package" file (with the `.pkg.sit'
extension) is available.

   The currently supported CPU types (listed in rough order of level
of support) are:
`LINUX'
     An Intel 386-Pentium machine running a modern glibc version of
     Linux (e.g., RedHat 7+).

`CYGWIN'
     An Intel 386-Pentium machine running the Windows operating
     system (using the Cygnus CygWin system as a compilation
     environment).

`DARWIN'
     A Mac running OS-X (aka Darwin), which is based on FreeBSD.
     Binaries are for the power PC (PPC) architecture.

`SUN4'
     A SUN sparc-station system running a modern 5.x Solaris version
     of the operating system.

`SGI'
     A Silicon Graphics workstation running a recent Irix 6.x release.

`HP800'
     A Hewlett Packard workstation running HP-UX version 10.x.

`IBMaix'
     An IBM RS/6000 machine running AIX v4.1.4 (4.1.x shouldwork)

   If you don't have one of these machines, then you will have to
compile the software from the source code using the programmers
distribution.

   The programmer's distribution is contained in one tar file that
contains the source code along with the manual and other supporting
files:
       pdp++_version_src.tar.gz

   These and any other files mentioned below can be obtained from our
anonymous FTP servers:
     CMU FTP Site: 	        ftp://cnbc.cmu.edu/pub/pdp++/
     Colorado FTP Site: 	ftp://grey.colorado.edu/pub/oreilly/pdp++/
     European (UK) Mirror:   ftp://unix.hensa.ac.uk/mirrors/pdp++/
   The Colorado site is updated most frequently.

* Menu:

* inst-users::                  Installing the End User's Version
* inst-prog::                   Installing the Programmers Version


File: ta_css,  Node: inst-users,  Next: inst-prog,  Prev: inst,  Up: inst

Installing the End User's Version
=================================

   After downloading the two tar files, `pdp++_version_bin_CPU.tar.gz'
and `pdp++_version_ext.tar.gz', you need to decide where to locate
the files.  It is recommended that you put them in
`/usr/local/pdp++', but they can be put anywhere.  However, the
`PDPDIR' environmental variable must then be set for all users to the
location it is actually installed in.  In addition if your CPU
supports shared libraries (all unix versions, including LINUX, IBMaix,
SUN4, HP800, SGI, but not DARWIN), you will need to insure that the
`LD_LIBRARY_PATH' environment variable includes the path
`PDPDIR/lib/CPU' where PDPDIR is the location of the pdp++
distribution, and CPU is your system type as described above (more
details on this below).  The following will assume that you are
installing in `/usr/local/pdp++'.

   Note: all of the PDP++ software is distributed in the gnu `gzip'
format, and it also uses gzip to automatically compress and decompress
the network, project, and environment files so that they take up less
space on your disk.  Thus, your system must have `gzip' installed
before proceeding.  It can be obtained from the GNU ftp server
(`gnudist.gnu.org') or one of its mirrors, and is typically installed
on most modern systems anyway.

   Go to the `/usr/local' directory, and issue the following command:
       gzip -dc <tarfile> | tar -xf -
   or, on Linux or other systems having a gnutar program
       tar -xzf <tarfile>
   where <TARFILE> is the name of the tar archive file.  Note that
the tar files will create the pdp++ directory, or load into it if it
already exists.  Thus, if you have an old version of the software, be
sure to rename its directory something else before loading the new
files.

   LINUX users: There is a special `.rpm' file that will install the
LINUX binaries and ext tar contents, including making links to the
binaries in /usr/local/bin, and installing the libIV.so library (and
links) in /usr/local/lib, and all of the ext-tra stuff in
/usr/local/pdp++.  To install this file, you need to be super-user,
and then execute the following command:
       rpm -Uvh pdp++-binext-VERSION.i386.rpm
   Note that the PDP++ specific libraires are still installed in
PDPDIR/lib/LINUX, so you still need to set the LD_LIBRARY_PATH to
include this path.

   Windows users (CYGWIN): There is a special `.exe' file that is an
auto-installing executable distribution of both the bin and ext tar
files described above.  This should be used to install under windows.
If you should install it in a location other than the default
`C:\PDP++' directory, you should add a `set PDPDIR=path' in the
`C:\autoexec.bat' file.

   OS-X users: There is a special `.pkg.sit' file that is an
auto-installing package file distribution of both the bin and ext tar
files described above.

   All further references to file names, unless otherwise stated,
assume that you are in the PDPDIR directory (e.g.,
`/usr/local/pdp++').

   The files will get loaded into the following directories:

`bin'
     binaries (executable files) go here

`config'
     configuration (for Makefile) and some standard init files are
     found here

`css'
     contains include files for commonly-used css scripts and some
     additional documentation, plus some demo script files

`defaults'
     contains default configuration files for the various executables
     (see the manual for more information).

`demo'
     contains demonstrations of various aspects of the PDP++ software.

`manual'
     contains the manual, which is in texinfo format	and has been made
     into a .ps, emacs .info, and html files.

`src'
     contains the source code for the software.

`lib'
     libraries (for dynamically linked executables) go here

`interviews/lib'
     InterViews toolkit libraries (for dynamically linked
     executables) go here.

   The binaries will get unloaded into `bin/CPU', where `CPU' is the
system name as described above.  The binaries are:

`bp++'
     The backpropagation executable (*note bp::).

`cs++'
     The constraint satisfaction executable (*note cs::).

`so++'
     The self-organizing learning executable (*note so::).

`bpso++'
     A combination of backpropagation and self-organization
     algorithms, so hybrid networks can be built.

`leabra++'
     The Leabra algorithm developed by O'Reilly, which incorporates
     Hebbian and error-driven learning, together with a
     k-Winners-Take-All competitive activation function, into a
     single coherent framework, which is biologically based.  See
     "Computational Explorations in Cognitive Neuroscience:
     Understanding the Mind by Simulating the Brain", by O'Reilly and
     Munakata, MIT Press, 2000 (September) and associated simulations
     *Note intro:: for details.

`lstm++'
     The long-short-term-memory algorithm by Hochreiter, Schmidhuber
     et al.

`rns++'
     The real-time neural simultation program developed by Josh Brown.

`maketa'
     The type-scanner used for programming the software.  You can
     read about it in *Note prog::.

`css'
     A stand-alone version of the CSS script language system.  It can
     be used as an interpreted C++ language system for any number of
     tasks.

   You should either add the path to these binaries to your standard
path, or make symbolic links to these files in `/usr/local/bin' or
some similar place which most user's will have on their path already.
For example, in a csh-like shell (e.g., in the `~/.cshrc' file that
initializes this shell), add (for the LINUX CPU):
     set path = (/usr/local/pdp++/bin/LINUX $path)
   or to make the symbolic links, do:
     cd /usr/local/bin
     ln -s /usr/local/pdp++/bin/LINUX/* .

Configuring the Libraries
=========================

   IMPORTANT: Most of the binaries are dynamically linked, which means
that the `pdp++_version_bin_CPU.tar.gz' file installed some dynamic
libraries in the `PDPDIR/lib/CPU' directory and in the
`PDPDIR/interviews/lib/CPU' directory.  When one of the PDP++
programs is run, it will need to know where to find these dynamic
libraries.  Thus you must set the `LD_LIBRARY_PATH' environmental
variable (using `setenv' under csh/tcsh) to point to both of these
locations.  For example, under LINUX with the standard PDPDIR:
     setenv LD_LIBRARY_PATH /usr/local/pdp++/lib/LINUX:/usr/local/pdp++/interviews/lib/LINUX
   It is a good idea to put this setting in your initialization file
for your shell (i.e. `~/.cshrc').

   It might be easier, especially if you want to use idraw or other
programs available under interviews, to copy the
`PDPDIR/interviews/lib/CPU/libIVhines.so*' (or .sl for HP800) file
into your `/usr/local/lib' or somewhere else that is already on your
dynamic linker's path.

   ADDITIONAL STEPS FOR libIV: First, note that we are now using (as
of version 3.0) the version of InterViews maintained by Michael Hines
as part of the NEURON detailed neural simulation package.  This
library is now called `libIVhines'.  The latest version should always
be available at `ftp://www.neuron.yale.edu/neuron/unix/', with the
current version being `iv-15.tar.gz' (also available on the PDP++ ftp
sites).

   The interviews library in `PDPDIR/interviews/lib/CPU' is called
libIVhines.so.3.0.3 (or possibly other numbers instead of 3.0.3), but
on several unix systems (including LINUX, SGI, SUN4) the linker also
wants to see a libIVhines.so.3 and a libIVhines.so as different names
for this same file.  Therefore, you need to do the following in
whatever directory you end up installing libIVhines.so.3.0.3 (even if
you keep it in the original location, you need to do this extra step):
     ln -s libIVhines.so.3.0.3 libIVhines.so.3
     ln -s libIVhines.so.3.0.3 libIVhines.so
   (replace 3.0.3 and .3 with the appropriate numbers for the
libIVhines file you actually have).  Note that the .rpm install under
LINUX does this automatically.

Manual
======

   The manual is distributed in several versions, including a
postscript file that can be printed out for hard-copy, a set of
"info" files that can be installed in your standard info file
location and added to your `dir' file for reading info files in gnu
emacs and other programs, and a directory called `html' which
contains a large number of `.html' files that can be read with
`Netscape', `Mosaic' or some other WWW program.  Point your program
at `pdp-user_1.html' for the chapter-level summary, or
`pdp-user_toc.html' for the detailed table of contents.

Help Viewer Configuration
-------------------------

   There is now a `Help' menu item on all of the objects (under the
`Object' menu), which automatically pulls up the appropriate section
of the `html' version of the manual, using `netscape' by default.

   Under Windows (CYGWIN), the default help command is setup to use
`C:/Program Files/Internet Explorer/iexplorer.exe' -- if you prefer
netscape or any other HTML browser, this should be changed to the
full path to that executable.

   Under Mac (DARWIN), the default help command is `open -a
\"Internet Explorer\" %s &' - this should work for most systems,
although you might want to use the new browser whatever it is called.

   These defaults can be changed in the `Settings' menu of the
`PDP++Root' object, see *Note proj-defaults:: and *Note gui-settings::
for details.

   The latest version of the manual is also available on-line from:
       http://psych.colorado.edu/~oreilly/PDP++/PDP++.html

MS Windows Configuration
========================

Memory Configuration
--------------------

   The PDP++ executables are compiled using an environment called
cygwin developed by Cygnus Solutions (now owned by Red Hat Software).
The default cygwin configuration has an upper limit of 128MB, which
should work for most simulations.  However, you might want to
increase this limit if you are exploring larger simulations.

   Open regedit (or regedt32) and find the key
HKEY_CURRENT_USER\Software\Cygnus Solutions\Cygwin\

   If this does not exist, you must create a new Key called Cygnus
Solutions, and then another within it called Cygwin.

   Then, create a new DWORD value under this key called
"heap_chunk_in_mb" that contains the maximum amount of memory (in Mb)
your application needs (watch the hex/decimal toggle - you'll
probably want to set it to decimal).  For example if you wanted to set
the memory limit to 256Mb, just enter 256.  Exit and restart all
cygwin applications (e.g., pdp++).

Taskbar Configuration
---------------------

   Because the simulator uses many windows, the windows taskbar often
does not adequetly display the names of the windows.  This can be
remediated by dragging the top of the bar up, allowing more room for
each icon.  Another approach is to grab the taskbar, drag it to the
right edge of the screen, drag the left edge to widen it, and then
set it to auto hide (right click on the taskbar, and select
Properties to expose this option, or go to the Start
menu/Settings/Taskbar).  When all this has been done, the window list
can be exposed bringing the pointer to the right edge of the screen.

Mac OS-X Configuration
======================

   PDP++ depends on having an XWindows (X11) server running on your
mac.  Apple now has their own version of the XFree86 X11 server,
which runs very smoothly under the standard OSX window manager.  This
is the recommended solution.  Read more about it and download from:

   `http://www.apple.com/macosx/x11/'

   Basically, everything works just as under unix because this is a
fairly standard unix setup after all is said and done.  The manual
should therefore provide all the info you need.

Other Configuration
===================

   See *Note proj-defaults:: for instructions on how to setup
customized startup files if you want to change some of the default
properties of the system.

   Happy simulating!


File: ta_css,  Node: inst-prog,  Prev: inst-users,  Up: inst

Installing the Programmers Version
==================================

   Read over the instructions for installing the end-user's version
first.  This assumes that you have unloaded the
`pdp++_version_src.tar.gz' file in something like `/usr/local/pdp++'.

   IMPORTANT: Whenever you are compiling, you need to have the
environmental variable `CPU' set to reflect your machine type (see
above).  Other machine types can be found in the interviews
`config/InterViews/arch.def' directory.  These are (in addition to
the above): `VAX, MIPSEL, SUN3, SUNi386, SUN, HP300, HP200, HP500,
HP, ATT, APOLLO, SONY68, SONYmips, SONY, PEGASUS, M4330, MACII, CRAY,
STELLAR, IBMi386, IBMrt, IBMr2, LUNA68, LUNA88, MIPSEB, MOTOROLA,
X386, DGUX, CONVEX, stratus, ALPHA'.

   The C++ compiler types that are supported are modern gnu g++/egcs
compilers (anything released after 1999 seems to work), and
proprietary system compilers, which we refer to as  `CC' compilers.

   There are a couple of other libraries that the PDP++ software
depends on.  These need to be made before PDP++ itself can be
compiled.  Please ensure that all of the following are installed
properly:

   1) The `readline' library, which will have already been installed
if `gdb' or perhaps other gnu programs have been installed on your
system (or if you are using Linux).  Look for
`/usr/lib/libreadline.so' or `/usr/local/lib/libreadline.so'.  If it
isn't there, then download a version of it from one of the gnu ftp
server sites (e.g., `gnudist.gnu.org'), and compile and install the
library.

   2) If using g++, and not on a Linux-based system, you need to make
the the `libstdc++' library in the libg++ distribution.  NOTE: PDP++
now requires the `sstream' header file, which defines the
`stringstream' class, which is a much improved replacement for the
`strstream' class.  For g++ version 2.9x, this header file might be
missing or broken (e.g., under RedHat 7.3, it is present but
broken!).  A good version of this file is present in
`PDPDIR/include/new_sstream_for_gcc_2.9x.h', and should be installed
in the appropriate location (e.g., for RH 7.3, do the following as
root: `cp include/new_sstream_for_gcc_2.9x.h
/usr/include/g++-3/sstream'.

   I haven't done this install in a while so the following is likely
out of date:. It seems that in the latest distribution of libg++ both
of these are installed in `/usr/local/lib' automatically, but if they
are not there, `libiostream.so' is made in the `libio' directory in
the libg++ distribution (do a `make install' to get the properly
installed or copy it yourself), and `libstdc++.so' is made in the
`libstdc++.so' directory.  CC/cfront users should have their iostream
code linked in automatically via the standard C++ library that comes
with the compiler.

   3) Install the InterViews library, which provides the graphics
toolkit used by PDP++.  We have collaborated with Michael Hines,
developer of the Neuron simulation system, in developing an improved
version of the InterViews library - You must install the Hines
version of InterViews!.  The source code for this version is:

     iv-15.tar.tz

   available on our ftp servers, and the latest version should be
available from Michael Hines' ftp site at:
`ftp://www.neuron.yale.edu/neuron/unix/'.  Some miscellaneous
information about interviews can be found in the
`PDPDIR/lib/interviews' directory.

   An alternative to compiling interviews yourself is to download
pre-compiled interviews libraries from us.  These are available for
the dominant form of compiler (CC or g++) for the platforms on which
the binary distribution is available (see list above in *Note inst::)
and are provided as `pdp++_version_ivlib_CPU_CC.tar.gz' for the CC
compiler and `..._g++.tar.gz' for g++.  The include files, which are
necessary to use the libraries to compile PDP++, are in
`pdp++_version_ivinc.tar.gz'.  These create a directory called
`interviews' when extracted, which means this should be done in the
`/usr/local' directory so that the interviews directory is
`/usr/local/interviews'.  Alternatively, these can be installed
elsewhere and the `IDIRS_EXTRA' and `LDIRS_EXTRA' makefile variables
set to point to this directory (see below).  We install ours in
`/usr/local/lib' - follow the directions in the End Users's install
version described above to do this.

   4) Once you have the above libraries installed, the next step is to
configure the makefiles for the type of compiler and system you have.
These makefiles are located in `PDPDIR/config'.  The actual makefiles
in a given directory (e.g., `src/bp/Makefile' and
`src/bp/CPU/Makefile') are made by combining several makefile
components.  `config/Makefile.std' has the standard rules for making
various things, `config/Makefile.defs' has the standard definitions
for everything, and then `config/Makefile.CPU' overrides any of these
definitions that need to be set differently for a different CPU type
(i.e., "local" definitions).  There are several sub-steps to this
process as labeled with letters below:

   a) If you have installed the software in a location other than
`/usr/local/pdp++': You need to change the definition of `PDPDIR' in
both the top-level Makefile (`PDPDIR/Makefile') and in the
definitions makefile `PDPDIR/config/Makefile.defs'.

   There are makefiles in `PDPDIR/config' for the supported CPU types
listed above, and the two different supported compilers (g++, CC). The
makefiles are named `Makefile.CPU.cmplr', where cmplr is either `g++'
or `CC'. The actual makefile used during compiling for a given
machine is the one called `Makefile.CPU', where CPU is the type of
system you are compiling on (e.g., LINUX, SUN4, HP800, SGI, etc.).
If you are compiling on a machine for which a standard makefile does
not exist, copy one from a supported machine for the same type of
compiler.  Also, see the notes below about porting to a new type of
machine.

   b) Copy the appropriate `Makefile.CPU.cmplr' makefile (where cmplr
is either g++ or CC depending on which compiler you are using), to
`Makefile.CPU' (again, CPU is your machine type, not 'CPU'). For some
architectures there is just one `Makefile.CPU' since only one type of
compilier is currently supported. In this case you can just leave it
as is.

   c) You should put any specific "local" definitions or
modifications to the makefiles in the `config/Makefile.CPU'.  This
will be included last in the actual makefiles, and any definitions
appearing here will override the standard definitions.  To see the
various definitions that might affect compiling, look at
`Makefile.defs', which contains all the "standard" definitions, along
with descriptive comments.  The following are items that you will
typically have to pay attention to:

   i) `IOS_INCLUDES' and `IOS_LIB': In order to be able to access via
the CSS script language the functions associated with the standard
C++ iostream classes, the type-scanning program `maketa' needs to
process the iostream header files: `streambuf.h', `iostream.h',
`fstream.h', and `strstream.h'.  These files are scanned in the
`src/ta' directory, as part of the building of the type access
library `libtypea.a'.  These header files are different depending on
the compiler being used.  For CC compilers, the `IOS_INCLUDES'
variable should be set to `CC-3.1'.

   These header files are typically located in `/usr/include/CC',
which is where the `CC-3.1' versions of these files in `src/ta' point
to via symbolic links.  Thus, if your headers are located elsewhere,
you will need to change these symbolic links, or just copy the header
files directly into the `ios-CC-3.1' subdirectory in `src/ta'.  For
g++ users, `IOS_INCLUDES' variable should be set to `g++-2.8.1' (for
g++ 2.9x) or `g++-3.1' (for g++ 3.x).  As of version 3.0, these g++
iostream headers are never actually included in the compile process
itself, and are only scanned via the maketa program.  Therefore, they
have been dramatically edited to expose only the relevant interface
components.  As such g++-3.1 should work for all subsequent releases
of g++ (hopefully!).

   Note that you can use the `make force_ta' action to force a re-scan
of the header files.  A `make opt_lib' is then neccessary to compile
this type information into the library.  Finally, the `IOS_LIB'
variable should be blank by default for both g++ and C++ users (for
newer g++), but for older g++ configurations it was necessary to set
it to `-liostream'.

   ii) `IDIRS_EXTRA' and `LDIRS_EXTRA' can be used to specify
locations for other include and library files, respectively (for
example, the cfront compiler may need to be told to look in
-I/usr/include/CC for include files).  Use these if you have installed
any libraries (e.g., InterViews) in a non-standard location.

   iii) `MAKETA_FLAGS' should be set to `-hx -css -instances' by
default, but it is also often necessary to include the include path
for the iostream and other C++ library files.  For example, the LINUX
makefile has the following: `LIBG++_INCLUDE_DIR =
-I/usr/include/linux -I/usr/include/g++-3', and then `MAKETA_FLAGS =
-hx -css -instances $(LIBG++_INCLUDE_DIR)'.

   iv) `cppC': this is the c-pre-processor, needed for the `maketa'
program to process header files.  Although the system default
preprocessor, usually installed in `/usr/lib/cpp', should work,
`maketa' was developed around the gnu cpp program, and so if you run
into difficulties using the system cpp, install the gnu one (included
as part of the gcc compiler).  Note that `make install' of gcc/g++
does not apparently install this program by default, so you have to
manually copy it from either your gcc compile directory or
`/usr/lib/gcc-lib/<machine>/cpp'.  You often need to include a define
for the system architecture (e.g., `-D__i386__' for Linux on intel
chips, or `-Dsparc' for suns) in the cppC command.

   v) `VT_xxx' and `TI_xxx': these specify the virtual-table
instantiation and template-instantiation (respectively) files, which
are needed by different compilers.  CC typically requires the VT_xxx
files along with the +e[01] flags to only make one copy of virtual
tables, while g++ requires the TI_xxx files to only make one copy of
the templates.  The TI_xxx files are included by default, so you will
need to define them to be empty to override this default:
`TI_INST_SRC = ', `TI_INST_OBJ = ', `TI_INST_DEP = '.

   vi) Porting to a non-supported machine: There are a small set of
system-dependent definitions contained in `src/ta/ta_stdef.h', which
are triggered by defines set up in the makefiles.  `NO_BUILTIN_BOOL'
should be defined if the c++ compiler does not have a bulitin `bool'
type, which is the case with most cfront-based CC compilers, but not
g++.  `CONST_48_ARGS' determines if the `seed48' and `lcong48'
functions take const arguments or not.  In addition, different
platforms may require different defines than those that are flagged
in `ta_stdef.h'.  In this case, you will have to edit `ta_stdef.h'
directly.  Please send any such additions, and the corresponding
`config/Makefile.CPU' along with any notes to us
(`pdpadmin@crab.psy.cmu.edu') so we can put them on our web page for
others to use, and incorporate them into subsequent releases.

   vii) For some more information about the makefiles, see *Note
prog-make::.

   5) The standard makefiles use gnu's `bison' instead of `yacc' for
making parsers.  If you don't touch any of the .y files in the
distribution, you won't need either.  If you plan on messing around
with the guts of the maketa type scanner or CSS, then you will
probably want to install the latest version of `bison'.

   6) The dependency information, which is essential if you are going
to be editing the main body of PDP++ code, but not necessary for a
one-pass make of the system, is not made by the default `make world'
action.  If you want to make this dependency information, do it with
a `make depend' after a successful `make world'.  Also, note that the
automatic dependencies are made by calling `gcc' in the standard
configuration.  If your local C compiler supports the `-M' flag for
generating dependency information, then this can be used instead.
Just change the definition for `CC' in your `Makefile.CPU'.  If you
don't have gcc and your local C compiler doesn't support this, you can
edit the end of the `Makefile.std' and change it to use the
`makedepend' program, which we have not found to work as well, but it
is an option.

   7) On some systems, the standard `make' program is broken and will
not work with our complex makfile system.  This is true of the SUN4
system and IBMaix, and may be true of others.  In this case, you will
have to install the GNU make program, and use it to compile the
software.  If you get inexplicable errors about not being able to make
certain things (seems to be the .d dependency files in particular that
cause a problem), then try using GNU make (again, available at
`gnudist.gnu.org' or mirrors).

   8) If your CPU supports shared libraries (most do now), you will
need to insure that the `LD_LIBRARY_PATH' environment variable
includes the path `PDPDIR/lib/CPU' nad `PDPDIR/interviews/LIB/CPU'
where PDPDIR is the location of the pdp++ distribution, and CPU is
your system type as described above.  This is important even during
the compile process, because the maketa program will need to access
shared libs.

   After setting appropriate definitions, go back up to the PDPDIR
and just do a:
     make world

   this should compile everything.  This will make makefiles in each
directory based on your CPU type, and then compile the various
libraries and then the executables.

   Most likely, the make will at least proceed past all the basic
directory initialization stuff that is part of `make world'.  Thus,
if the compile stops after making the makefiles and after making the
`maketa' program, you can fix the problem and re-start it by doing
`make all' instead of `make world'.

   If you run into difficulties during the compile process, the
programming guide might contain some useful information for debugging
what is going wrong: *Note prog::.


File: ta_css,  Node: css,  Next: prog,  Prev: inst,  Up: Top

Guide to the Script Language (CSS)
**********************************

   CSS is the script language for the PDP++ software.  It is a
general-purpose language that allows one to do virtually anything that
could be done by writing programs in C or C++ and compiling them.  It
provides full access to all the types and objects defined in PDP++,
and allows you to call the "member functions" of these objects and
set the values of their members variables.

   There are two principal uses for the script language in running
simulations.  One is to automate the procedure of setting up and
running a simulation.  In this role, the script replaces commands
that would otherwise be given through the graphical user interface
(gui).  The other is to extend the software without having to
re-compile and re-link.  Thus, one can write new kinds of procedures,
statistics, etc.  that are particular to a given simulation in the
script language, and run them as if they were hard coded.  This gives
the PDP++ software more flexibility.

* Menu:

* css-intro::                   Introduction to CSS
* css-tut::                     Tutorial Example of Using CSS
* css-from-c::                  CSS For C/C++ Programmers
* css-ref::                     CSS Reference Information
* css-errors::                  Common User Errors in CSS
* css-hard::                    Compiling CSS files as C++ Hard Code


File: ta_css,  Node: css-intro,  Next: css-tut,  Prev: css,  Up: css

Introduction to CSS
===================

   CSS is a "C" language interpreter and script language (C
Super-Script).  The name derives from the fact that the language is
C, written in C, so it is C to the C, or C^c, while at the same time
being an excellent, even superlative scripting language.  The actual
syntax for CSS is somewhere in between C and C++, and the language is
written entirely in C++.  The major differences between CSS and C++
are listed in *Note css-c++-diff::, and the few discrepancies between
CSS and C are noted in *Note css-c-diff::.  Some of the convenient
features of C++ that are incorporated into CSS are enumerated in
*Note css-c++-intro::, for those unfamiliar with C++.

   Being an interpreter, CSS presents the user with a prompt: `css>'.
At this prompt, the user can enter any C expression, which will be
evaluated immediately upon pressing Return, or enter a command.  The
commands operate much like a debugger (e.g., gdb, dbx), and allow
control over the running, listing, and debugging of programs.  In
addition to the default "immediate mode" behavior of the system, it
can behave like a compiler.  For example, the command `define' will
cause the system to enter a compiling mode (the prompt changes to
`css\# '), where the C code that is subsequently entered is compiled
into an intermediate machine code, but not run directly.  Instead, it
becomes a stored program that can be run many times.

   Typically, one works with a program file (use the extension .css to
indicate a css file) that is loaded and then run, instead of manually
typing programs into the system using define mode.  The command `load
"filename.css"' will load a file and compile it, at which point it
can be run.  The command `run' will run the program from the
beginning.  `reload' will remove the existing compiled program and
load (and re-compile) the previously loaded one from the disk file,
which is handy when you are editing the program file and testing it
out.

   One can view the source code within CSS by using the `list'
command, which takes (optional) line number and length arguments.
Unlike C functions, which need to be called with the usual syntax of
parentheses around the arguments, which are themselves comma
separated, and the whole thing is terminated by a semi-colon, the
arguments to commands don't require the parentheses or the
semi-colon, but do require thte commas.

   One of the principle uses of CSS is as an interface for hard-coded
C/C++ programs.  There is a "TypeAccess" program that reads the
header files for a given application and generates type information
that can be used by CSS to automatically interface with the objects
and types in the hard-coded world.  CSS comes initially with some
relevant hard-coded types from the standard C/C++ library, including
a String class and the stream I/O classes, and various math and posix
library functions.


File: ta_css,  Node: css-tut,  Next: css-from-c,  Prev: css-intro,  Up: css

Tutorial Example of Using CSS
=============================

   This section provides a tutorial-style introduction to some of the
features of the CSS language environment.

* Menu:

* css-tut-run::                 Running an Example Program in CSS
* css-tut-debug::               Debugging an Example Program in CSS
* css-tut-access::              Accessing Hard-Coded Functions and Variables in CSS


File: ta_css,  Node: css-tut-run,  Next: css-tut-debug,  Prev: css-tut,  Up: css-tut

Running an Example Program in CSS
---------------------------------

   The following example will be used to illustrate the use of the CSS
system:


     // a function that decodes the number
     String Decode_Number(float number) {
       String rval = "The number, " + number + " is: ";
       if(number < 0)
         rval += "negative";
       else if(number < .5)
         rval += "less than .5";
       else if(number < 1)
         rval += "less than 1";
       else
         rval += "greater than 1";
       return rval;
     }
     
     // decodes n_numbers randomly generated numbers
     void Decode_Random(int n_numbers) {
       int i;
       for(i=0; i<n_numbers; i++) {
         float number = 4.0 * (drand48()-.5);
         String decode = Decode_Number(number);  // call our decoding function
         cout << i << "\t" << decode << "\n";    // c++ style output
       }
     }

   You can enter this code using a text editor (e.g., emacs or vi),
or use the example code in `css_example.css' included with the PDP++
software in the `css/include' directory.  Then, run the PDP++
software.  At the prompt (which will vary depending on which
executable you run -- the example will use `css>'), type:

     css> load "css_example.css"

   and the prompt should return.  If you made any typos, they might
show up as a Syntax Error, and should be corrected in the text file,
which can be re-loaded with:

     css> reload

   Loading the text file translates it into an internal "machine
code" that actually implements CSS.  This is like compiling the code
in traditional C, but it does not write out an executable file.
Instead, it keeps the machine code in memory, so that it can be run
interactively by the user.

   To ensure that CSS has loaded the text, you can list the program:

     css> list
     
     Listing of Program: css_example.css
     1
     2       // a function that decodes the number
     3       String Decode_Number(float number) {
     4         String rval = "The number, " + number + " is: ";
     5         if(number < 0)
     6           rval += "negative";
     7         else if(number < .5)
     8           rval += "less than .5";
     9         else if(number < 1)
     10          rval += "less than 1";
     11        else
     12          rval += "greater than 1";
     13        return rval;
     14      }
     15
     16      // decodes n_numbers randomly generated numbers
     17      void Decode_Random(int n_numbers) {
     18        int i;
     19        for(i=0; i<n_numbers; i++) {
     20          float number = 4.0 * (drand48()-.5);
     21          String decode = Decode_Number(number);  // call decoder
     css> list
     
     Listing of Program: css_example.css
     21          String decode = Decode_Number(number);  // call decoder
     22          cout << i << "\t" << decode << "\n";    // c++ style output
     23        }
     24      }
     26      list

   Note that you have to type `list' in twice in order to see the
whole program (by default, `list' only shows 20 lines of code).
Also, notice that the list command itself shows up at the end of the
program--this is because commands that are entered on the command line
are actually compiled, run, and then deleted from the end of the
program.  Because `list', when run, shows the current state of the
code (i.e., before it has itself been deleted), it shows up at the
bottom of the listing.

   Now, let's try running the example:

     css> run
     css>

   Nothing happens!  This is because the code as written only defines
functions, it does not actually call them.  The program would have to
have had some statements (i.e., function calls, etc) at the _top
level_ (i.e., not within the definition of a function) in order to do
something when the `run' command is issued.

   However, we can call the functions directly:

     css> Decode_Random(5);
     0       The number, -0.414141 is: negative
     1       The number, 1.36194 is: greater than 1
     2       The number, -0.586656 is: negative
     3       The number, -0.213666 is: negative
     4       The number, -0.725229 is: negative
     css>

   (of course, your output will vary depending on the random number
generator).  This illustrates the interactive nature of CSS -- you can
call any function with any argument, and it will execute it for you
right then and there.  This is especially useful for debugging
functions individually.  Thus, we can call the `Decode_Number'
function directly with different numbers to make sure it handles the
cases appropriately:

     css> Decode_Number(.25);
     css>

   Notice, however, that there was no output.  This is because the
function simply returns a string, but does not print it out.  There
are several ways to print out results, but the easiest is probably to
use the `print' command:

     css> print Decode_Number(.25);
     (String)  = The number, 0.25 is: less than .5

   `print' gives you the type name, the variable name (which is blank
in this case), and the value.  To illustrate this, you can just
declare a variable directly:

     css> String foo = "a string";
     css> print foo
     (String) foo = a string

   Compare this with the print _function_ (not command) `printf':

     css> printf(Decode_Number(.25));
     The number, 0.25 is: less than .5css>

   which just gives you the value of the string (and does not
automatically append a '\n' return at the end of the line).  Finally,
we can use C++ stream-based printing, which directs the return value
from the function to print itself to the default current output
`cout':

     css> cout << Decode_Number(.75) << "\n";
     The number, 0.75 is: less than 1
     css>

   Note also that you can put any expression in the arguments to the
function:

     css> print Decode_Number(exp(cos(tan(.2) + .5) * PI)/ 20);
     (String)  = The number, 0.549689 is: less than 1

   In order to actually be able to run a script, we can add the
following lines to the code by switching to `define' mode instead of
the default interactive mode:

     css> define
     css# cout << Decode_Number(.75) << "\n";
     css# Decode_Random(5);
     css# exit

   Note that we use `exit' to exit the `define' mode.  You could also
use the `EOF' character (`ctrl-D' on most systems) to exit this mode.
To see that we have added to the program, list it from line 20
onwards:

     css> list 20
     
     Listing of Program: css_example.css
     20          float number = 4.0 * (drand48()-.5);
     21          String decode = Decode_Number(number);  // call decoder
     22          cout << i << "\t" << decode << "\n";    // c++ style output
     23        }
     24      }
     26      cout << Decode_Number(.75) << "\n";
     27      Decode_Random(5);
     28      exit
     29      list 20

   Now, when we `run' the program, we get:

     css> run
     The number, 0.75 is: less than 1
     0       The number, 1.54571 is: greater than 1
     1       The number, -1.93767 is: negative
     2       The number, 0.336361 is: less than .5
     3       The number, -1.36253 is: negative
     4       The number, -0.465137 is: negative
     css>

   All of the C language rules about declaring or defining functions
before they are called apply in CSS as well (in general, CSS obeys
most of the same rules as C), so we could not have put those two
extra lines of code in the example program before the functions
themselves were defined.  In general, this leads to a program layout
consisting of various different functions, followed at the very end
by one or two lines of code at the top-level which call the relevant
function to start things off.  If you are feeling traditional, you
can call this function `main', and it will look like a regular C/C++
program, except for the last line which calls the main function.

