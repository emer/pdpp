This is ta_css, produced by makeinfo version 4.1 from ta_css.texi.


File: ta_css,  Node: coding-funs,  Prev: coding-names,  Up: prog-coding

Basic Functions
---------------

   These are the functions that must be either specified or
considered in any new instance of a taBase class:

`void Initialize()'
        * It is called in every constructor.

        * Do not call `Parent::Initialize()', as this is a constructor
          function and the parent's will be called for you by C++ as
          the object is constructed.

        * Set the initial/default values of each member in the class.

        * Set the default type for groups that you own
          (`SetBaseType()').

        * Call `taBase::InitPointer(ptr)' on every taBase object
          pointer in class, or just set all pointers to NULL.

        * EVEN IF NOTHING NEEDS INITIALIZING: use `void Initialize()
          { };' to avoid multiple calls to the parent's Initialize.

`void Destroy()'
        * It is called in every destructor.

        * Do not call the parent, as C++ will automatically call the
          parent's destructor for you.

        * Free any resources you might have allocated.

        * Call `CutLinks()', if defined, to sever links with other
          objects.

        * EVEN IF NOTHING TO DESTROY: use `void Destroy() { };' to
          avoid multiple calls to parents Destroy.

`void InitLinks()'
        * Called when an object is linked into some kind of ownership
          structure.

        * Call the `Parent::InitLinks()', since this is not a
          constructor function and the parent's links will not
          otherwise be set.

        * Own any classes contained as members: `taBase::Own(recv,
          this);'

        * Set any pointers to objects with default values (e.g.,
          `spec->SetDefaultSpec(this));', etc.

        * Be sure to use `taBase::SetPointer(ptr, new_val);' for
          setting pointers.

        * Or use `taBase::OwnPointer(ptr, new_val);' for those you
          own.

        * If you do not need to do any of these InitLinks actions,
          then you do not need to define an InitLinks function.

`void CutLinks()'
        * Called when an object is removed from its owner, or as part
          of the `Destroy' function when an object is actually
          deleted, or explicitly by the user when the object is a
          member of another object.

        * At end of `CutLinks()', call `Parent::CutLinks()', since
          this is not always used as a destructor function, and
          parent's might not be called.  Note, however, that when it
          is called in the destructor, it will be repeatedly called,
          so it should be robust to this (i.e., SET ANY POINTERS YOU
          DELETE TO NULL SO YOU DON'T DELETE THEM AGAIN!).

        * Should sever all links to other objects, allowing them to
          be freed too.

        * Call `CutLinks()' on any owned members, especially groups!

        * Use `taBase::DelPointer()' on any pointers.

        * If you have a spec, call `CutLinks()' on it.

        * If you have group members, call `CutLinks()' on those
          groups.

`void Copy_(const T& cp), Copy(const T& cp)'
        * Used to duplicate the class, Copy is the = oper and copy
          constructor

        * Call `Parent::Copy' since this will not be called otherwise.

        * `Copy_(const T& cp)' is an "implementation" that does the
          copying for just this class, and does not call the parent
          `Copy'.

        * Use `COPY_FUNS(T, P);' (type and parent-type) to define the
          default macros for doing this:
                 void Copy(const T& cp)      { P::Copy(cp); Copy_(cp); }

        * Use `SIMPLE_COPY(T);' to define a `Copy_' function that
          automatically copies the members unique to this class in a
          member-by-member (using TypeDef) way.  This is less
          optimal, but easy when members are just simple floats and
          ints, etc.

        * Be sure to use `taBase::SetPointer(&ptr, cp.ptr)' for
          copying pointers.

`TA_BASEFUNS(T);'
     This defines the actual "basic" functions like constructors,
     destructors, `GetTypeDef()' etc. for taBase classes.  These
     default constructors and destructors call the other functions
     like `Initialize()' and `Destroy()'.

`TA_CONST_BASEFUNS(T);'
     This defines the actual "basic" functions like constructors,
     etc. for taBase classes which have `const' members defined in
     the class.  These need to be initialized as part of the
     constructor, so this macro leaves out the default constructors
     and destructor, which should contain the following code:
            MyClass() { Register(); Initialize(); SetDefaultName(); }
            MyClass(const MyClass& cp)
             { Register(); Initialize(); Copy(cp); }
            ~MyClass() { unRegister(); Destroy(); }

`TA_TMPLT_BASEFUNS(y,T);'
     Defines the actual "basic" functions like constructors, etc. for
     taBase classes which are also templates.  `y' is the template
     class, `T' is the template class parameter.

`void UpdateAfterEdit()'
        * Called after class members change via edit dialogs, loading
          from a file, or and assign operator in CSS.

        * Maintain consistency of member values.

        * Update links, etc.

When you add/remove/change any class members:
=============================================

   Check and add/remove/change initialization, copying, of this
member in:
`Initialize()'

`Copy_()'

`Copy()'
For classes with Specs:
=======================

   A pointer to a spec is encapsulated in a SpecPtr template class,
which is declared once immediately after a new class of spec types is
defined as follows (this will not typically done by the user):
       SpecPtr_of(UnitSpec);  // this defines the template class
     				    (only for base spec type)

   This pointer is then included in the class with the following:
       UnitSpec_SPtr  spec;  // this puts a spec pointer in the class

   Also, InitLinks() should have:
       spec.SetDefaultSpec(this);
   So that the spec pointer will set its pointer to a default
instance of the correct spec type (the `this' pointer is because this
also "owns" the spec pointer object.

For classes with taBase members:
================================

   All taBase members which appear as members of another class should
be owned by the parent class.  This increments their ref counter, so
that if they are ever pointed to by something else (e.g., during
loading this happens), and then unref'd, they won't then be deleted.

   `InitLinks()' should own the object member as follows:
       ta_Base::Own(obj_memb, this);

   For members that derive from taList or taGroup, `Initialize()'
should set the default type of object that goes in the group:
       gp_obj.SetDefaultType(&TA_typename);

Referring to other objects via pointers:
========================================

   If a class contains a pointer to another object, it should
typically refer to that object whenever the pointer is set.  The
interface assumes that this is the case, and any pointer member that
it sets will use the `SetPointer' function described below, which
does the referencing of the new value and the dereferencing of the
current one.

   HOWEVER, when the pointer is to a physical PARENT of the object
(or just higher in the deletion hierarchy) then it should not be
referenced, as this will prevent the parent from being deleted, which
will then prevent the child from being deleted.

   In this case, and in general when the pointer is just for
"internal use" of the class, and is not to be set by the user, the
following comment directives should always be used: `#READ_ONLY
#NO_SAVE' as this will prevent the user from overwriting the pointer,
and the loading code automatically does a reference when setting a
pointer, so these should not be saved.  DO NOT COPY SUCH POINTERS,
since they typically are set by the `InitLinks' based on the owner,
which is usually different for different tokens.

   When managing a pointer that the user can set, there are a set of
convenient functions in taBase that manage this process (note that the
argument is a _pointer_ to the pointer):

`taBase::InitPointer(TAPtr* ptr)'
     initializes the pointer (or just set the ptr to NULL yourself)
     in `Initialize()'

`taBase::SetPointer(TAPtr* ptr, TAPtr new_val)'
     unRef's *ptr obj if non-null, refs the new one.

`taBase::OwnPointer(TAPtr* ptr, TAPtr new_val, TAPtr ownr)'
     like set, but owns the pointer too with the given owner.

`taBase::DelPointer(ptr)'
     unRefDone the object pointed to, sets pointer to NULL.

   Using these functions will ensure correct refcounts on objects
pointed to, etc.

   If you `Own' the object at the pointer, then you should either mark
the member as `#NO_SAVE' if it is automatically created, or
`#OWN_POINTER' if it is not.  This is because saving and loading,
being generic, use `SetPointer' unless this comment is present, in
which case they use `OwnPointer'.

Using Group Iterators:
======================

   There are special iterator functions which iterate through the
members of a group.  One method is to iterate through those sub-groups
(including the 'this' group) which contain actual terminal elements
("leaves").  This is leaf-group iteration.  Then, the elements of each
group can be traversed simply using the `El' or `FastEl' functions.

   * for leaf-group iteration, using macros (preferred method):
            Con_Group* recv_gp;		// the current group
            int g;
            FOR_ITR_GP(Con_Group, recv_gp, u->recv., g)
              recv_gp->UpdateWeights();

   * for leaf-group iteration without macros:
            Con_Group* recv_gp;		// the current group
            int g;
            for(recv_gp = (Con_Group*)u->recv.FirstGp(g); recv_gp;
                recv_gp = (Con_Group*)u->recv.NextGp(g))
              recv_gp->UpdateWeights();

   When all you care about are the leaf elements themselves, you can
iterate over them directly using leaf-iteration:

   * for leaf-iteration, using macros (preferred method):
            Connection* con;		// the current leaf
            taLeafItr i;			// the iterator data
            FOR_ITR_EL(Connection, con, u->recv., i)
              con->UpdateWeights();

   * for leaf-iteration without macros:
            Connection* con;		// the current leaf
            taLeafItr i;			// the iterator data
            for(con = (Connection*)u->recv.FirstEl(i); con;
                con = (Connection*)u->recv.NextEl(i))
              con->UpdateWeights();


File: ta_css,  Node: gui,  Next: obj,  Prev: prog,  Up: Top

Guide to the Graphical User Interface (GUI)
*******************************************

   This chapter provides a general guide and reference for using the
graphical user interface to the PDP++ software.  This covers all of
the generic aspects of the interface--details about specific parts of
the interface like the network viewer are found in the the section of
the manual that covers the object in question (e.g., *Note
net-view::).

* Menu:

* gui-windows::                 Window Concepts and Operation
* gui-object::                  The "Object" Menu
* gui-actions::                 The "Actions" Menu
* gui-subgroup::                The SubGroup Menu(s)
* gui-edit::                    The Edit Dialog
* gui-settings::                Settings Affecting GUI Behavior
* gui-colors::                  Color Scale Specifications
* gui-file-requester::          File Requester
* gui-obj-chooser::             Object Chooser/Browser


File: ta_css,  Node: gui-windows,  Next: gui-object,  Prev: gui,  Up: gui

Window Concepts and Operation
=============================

   In PDP++ the hierarchy of objects provides the basis for most of
the gui (Graphical User Interface) interaction. To access a
sub-object of a class, the best place to start is with the gui window
for the parent class instance and work your way down to the
sub-object. The higher levels of the hierarchy have windows which are
mapped to the screen when the object is created. These windowing
objects inherit from the base class WinBase. When PDP++ starts up,
only one of these classes has been created and thus there is only one
window on the screen. The initial object is an instance of the class
PDPRoot, and is the top of the PDP hierarchy.

* Menu:

* gui-win-operation::           How to operate Windows
* gui-menu-operation::          How to operate the Menus
* gui-win-view::                Window Views


File: ta_css,  Node: gui-win-operation,  Next: gui-menu-operation,  Prev: gui-windows,  Up: gui-windows

How to operate Windows
----------------------

   PDP++ relies on your window manager for positioning, and
iconifying the graphical windows of the program. Please refer to your
window manager's manual for more information on the mouse movements
and button presses needed to accomplish these tasks. For all the
window objects in PDP++ there are CSS commands which ask the window
manager to position or iconify the windows associated with the
object. It is up to the window manager to provide the correct
behavior for these "hints". PDP++ WinBase Window's position and
iconification status can be manipulated with the following commands:

`GetWinPos()'
     Stores the window's current position and size on the object.
     When the object is saved the position and size of its window
     will be saved as well so that the window has the correct
     geometry when the object is loaded at a later time.

`ScriptWinPos()'
     Generates css script code for positioning the window at its
     current location and prints the code  to the output window or to
     a recording script.

`SetWinPos(float left, float bottom, float width, float height)'
     Asks the window manager to resize and move the window to the
     specified parameters. If no parameters are given, this functions
     uses the parameters stored on the object.

`Resize (float width, float height)'
     Asks the window manager to resize the window to the specified
     parameters. If no parameters are given, this functions uses the
     parameters stored on the object.

`Move (float left, float bottom)'
     Asks the window manager to move the window to the specified
     parameters. If no parameters are given, this functions uses the
     parameters stored on the object.

`Iconify()'
     Asks the window manager to iconify the window.

`DeIconify()'
     Asks the window manager to deiconify the window.


File: ta_css,  Node: gui-menu-operation,  Next: gui-win-view,  Prev: gui-win-operation,  Up: gui-windows

How to operate Menus
--------------------

   In all WinBase windows, there is a horizontal menubar along the
top. In this menubar is a "Object" menu (*note gui-object::), and also
"Subgroup" menus (*note gui-subgroup::) for access to the sub-objects
in this class.

   To access the menus press and hold button-1 (left button) on the
mouse while the mouse pointer is over the menu name. A smaller
vertical menu window will pop up under the mouse pointer. Moving the
mouse vertically while the button is still pressed will highlight the
different choices in a the menu. Some of the items in the menu may
have three dots `...' after them. When highlighting these menu items
a cascaded menu will popup to the right of the selected menu item.
The cascaded submenu may be traversed by moving the mouse pointer
horizontally into the submenu, and then moving the mouse vertically
as before. Again, button-1 must be pressed and held down during this
operation. To select an item, release the mouse button while the
mouse pointer is over the highlighted selection. To cancel the menu
(to select nothing) move the mouse out of the menu and release the
mouse button. Menu items which spawn submenus may not be selected. A
menu may be pinned (it will stay on the screen after the mouse is
released) by releasing the mouse while the pointer is on the menu
name or on a submenu's name. A selection can be made from a pinned
window by clicking (pressing and then releasing a button) on the
desired selection. This will also cause the pinned menu to become
unpinned and it will disappear.

   Note: This applies specifically to the motif mode in InterViews.
Open-look or other modes may be slightly different.


File: ta_css,  Node: gui-win-view,  Prev: gui-menu-operation,  Up: gui-windows

Window Views
------------

   Some objects may have multiple windows. These multiple windows are
called views, and provide alternative methods of interacting with the
same object and its data. In a view window then menubar at the top of
the window is split into a left menubar and a right menubar. The left
menubar contains menus whose actions pertain the the base object of
the view. The right menubar contains menus whose actions pertain to
this particular view only. For instance, a network object may have
multiple netviews. In each netview there will be the left and right
menubars along the top of the window. In the left menubar one would
find menus with function that are particular to the network, such as
menus for adding new layers, or removing all connections. In the
right menubar on would find menus with functions that are particular
to the view, such as setting the colors or shape of the units in the
view.

   Each view has an associated list of Schedule processes (*note
proc-sched::) which update the view in the course of their
processing. By adding or removing these "updaters", one can control
the grain at which changing data is displayed. For instance, in the
netview the colors of the units change to reflect their current
values whenever the view is updated. If the updater was a trial level
process then the view would display new values for all the units
after every trial.

WinView Functions
=================

`AddUpdater(SchedProcess*  updater)'
     Add the schedproc to the list of updaters for this view. (and
     vice-versa).

`RemoveUpdater(SchedProcess*  updater)'
     Removes the schedproc to the list of updaters for this view. (and
     vice-versa).

`InitDisplay()'
     Initializes and graphically rebuilds the view's display.

`UpdateDisplay()'
     Refreshes the winview's display to reflect changes in the base
     object's values. This is the function that is called by the
     updater processes.


File: ta_css,  Node: gui-object,  Next: gui-actions,  Prev: gui-windows,  Up: gui

The "Object" Menu
=================

   The "Object" menu always appears as the left most menu in a
WinBase's menubar.  The "Object" menu for each object is used to
perform file based actions on the object itself. Many of these
actions involve the use of a file requester dialog. *Note
gui-file-requester::.  These actions on the object can also be called
through css (e.g., the Print action can be called from css as
`object.Print()').  The "Object" menu has the following menu actions:

`Load'
     Load a text object dump of an object of the same class as this
     object on top of this object, replacing the values of fields of
     this object with the values of the saved object's fields. The
     saved object file is selected with the file requester.

`Save'
     Save a text object dump of this object in a file created with
     the file requester, or with the object's most recently used
     filename for saving.

`SaveAs'
     Save a text object dump of this object in a -new- file created
     with the file requester.

`Edit'
     The Edit menu action brings up an Edit Dialog on the object.
     *Note gui-edit::.

`Close'
     The Close menu action will attempt to close/delete the object.
     If the object is referenced or pointed to by other objects, then
     it will not actually be deleted, only the windows which display
     it will be removed. The user must confirm the deletion if it is
     possible to safely delete the object. NOTE THAT CLOSE IS NOT
     ICONIFY!, it really does delete the object, not just close the
     menu.

`Copy From'
     Copies from another object of the same or related type --
     replace all of the current data in the object with those in
     another.  In the menu, only the same or subtypes of this object
     will be shown, but in the script, any type of related object can
     be passed to this function.

`Copy To'
     Copies the data in this object to another object.  This can be
     useful if you want to copy from a more basic type of object
     (e.g., Environment) to a derived type (e.g., FreqEnv) - CopyFrom
     won't show the more basic type of object to copy from, but
     CopyTo will show the derived type.

`DuplicateMe'
     Makes another copy of this object - creates a new object and then
     copies from this current object to that new object.  Note this is
     DuplicateMe in the script code.

`ChangeMyType'
     Changes the type of this object to be another related type
     (e.g., change to a FreqEnv from an Environment).  Will usually
     do a good job of updating the various links to this object if
     changed.  Not good for objects within a network, or generally
     for Stat objects that are aggregated.  This is ChangeMyType in
     the script code.

`SelectForEdit'
     Allows you to select a field (member) of this object to be
     edited in a SelectEdit object, which consolidates parameters and
     functions across multiple objects into a single edit dialog
     (*note proj-seledit::).

`SelectFunForEdit'
     Allows you to select a function (method) of this object to be
     accessible from a SelectEdit object, which consolidates
     parameters and functions across multiple objects into a single
     edit dialog (*note proj-seledit::).

`Help'
     Will automatically pull up a help browser for information
     relevant to this object.  Depends on the browser actually
     running on your system, as specified in the Settings on the root
     object.

`Print'
     The Print menu action will save a snapshot of the entire
     object's window to a file in Postscript format using a file
     requester.  Note that this printout file uses structured
     graphics so it will scale well if resized, etc.

`Print Data'
     The Print data menu action will save a snapshot of the window's
     data, not including the menubars and window decoration, to a
     file in Postscript format using a file requester.

`Update Menus'
     If objects are created or deleted, sometimes the menus of their
     parent objects can become out of date. If this appears to be the
     case then use the "update menus" menu action on the parent
     object to fix the menus.  The "update menus" menu action
     recursively traverses the menus of the object and its
     subobjects, adding and deleting menu items appropriately.

`Iconify'
     This will iconify the window (shrink down to an iconic
     representation, to get it out of your way).


File: ta_css,  Node: gui-actions,  Next: gui-subgroup,  Prev: gui-object,  Up: gui

The "Actions" Menu
==================

   Some objects will have an "Actions" menu following their "Object"
menu.  In the Action menu are functions which are apply specifically
to the object and are not the common file based functions found on
the Object menu. If you wish to perform a function directly on the
object you are viewing in the window, the "Actions" menu is a good
place to look.  For more specific information concerning an object's
"Action" menu please refer to the section of this manual which
pertains to the object itself.


File: ta_css,  Node: gui-subgroup,  Next: gui-edit,  Prev: gui-actions,  Up: gui

The SubGroup Menu(s)
====================

   A subgroup menu appears in the menubar of a WinBase object for
each of the group members of the object. The name of the menu
corresponds to the name of the group member (e.g., The Layer object
has a group of units and a group of projections. It would have two
subgroup menus, one labeled `.units' and a second labeled
`.projections'. The "."  before the name of the subgroup is used to
indicate that the subgroups are sub-objects of the WinBase object. In
the CSS script language one would access objects in these subgroups
using the "." operator. (e.g., To access the first network in the
project one would type `.projects.networks[0]'). In addition the
subgroup menus appear in a non-italicized font to distinguish them
from the "Object" and "Action" menus of the WinBase. The subgroup
menu's have the following menu choices.  Occasionally subgroup menus
may add additional menu choices as well (e.g., The Processes submenu
of the Project has the menu choice Control Panel which opens a
control panel dialog for one of the processes in the subgroup). Some
of the group operations require the use of a file requester. *Note
gui-file-requester::.

`Edit'
     The Edit action brings up a Group Edit Dialog for the group or
     an Edit Dialog for an individual object (*Note gui-edit::).

`New'
     The New action allows the use to create new objects in the group
     or in a subgroup of the group. The user can chose to create
     objects of the base object type, objects of a subclass of the
     base object type, or a subgroup object. A popup dialog appears
     which enables the user to select the number of objects to
     create, the type of objects, and where to place them. Sometimes
     the popup dialog may have additional fields and toggles which
     are particular to the item being created. If the auto_edit flag
     in the global settings (*note gui-settings::) is turned on, an
     edit dialog will be created for the newly created objects when
     button-1 (left button) is pressed on the OK button of the popup
     dialog. If button-2 (middle button) is pressed the edit dialog
     will be created only if the auto_edit variable is off. When
     button-3 (right button) is pressed an edit dialog will always be
     created.

`Open In'
     The "Open in" action allows the user to open a previously-saved
     object file and add the data into the group. *Note
     obj-basics-files::.

`Load Over'
     The "Load Over" action allows the user to open a
     previously-saved object file and overwrite the objects in the
     group with the data in the file. *Note obj-basics-files::.

`Save'
     The Save action allows the user to save the group or a group
     element as a PDP++ object file using the file requester or the
     object's most recently used name for saving. *Note
     obj-basics-files::.

`Save As'
     The Save As action allows the user to save the group or a group
     element in a new PDP++ object file using the file requester.
     *Note obj-basics-files::.

`Remove'
     The Remove action allows the user to remove the group or a group
     element. The user is prompted with a confirmation dialog to
     confirm the choice. However, If the chosen object is referenced
     by other objects then it will not be deleted.

`Duplicate'
     The Duplicate action allows the user to add a duplicate of one
     of the objects in the group to the group or its subgroups.

`Move Within'
     This allows the user to move objects to new positions within the
     group (e.g., for rearranging the order of layers in the network,
     which is important for the feedforward Bp algorithm).

`View Window'
     View Window brings the window associated with selected object to
     the front, deiconifies it, or creates it if a window does not
     exist.


File: ta_css,  Node: gui-edit,  Next: gui-settings,  Prev: gui-subgroup,  Up: gui

The Edit Dialog
===============

   The Edit Dialog allows the user to both visually inspect and
modify the values of an object's fields. As an inspection tool, the
user can use and edit dialog to check the values of an object's
fields, and as an editing tool the user can use the edit dialog to
change the values of some or all of those fields. For some objects,
the edit dialog is the only representation available for inspecting,
or accessing it members.  Other objects may have extended edit
dialogs or even multiple views which may also allow modification of
the object's fields. An edit dialog also presents the user with easy
access to the substructures of an object including editing of its
subgroups and arrays. In addition the edit dialog may allow access to
certain member functions on an object.  Edit Dialogs are created by
choosing "Edit" from an object's menu or by the `EditObj' command in
css (*note css-commands::).

   The basic layout of the edit dialog includes a list of object
member names which are listed in a vertical column along the left
hand side of the display.  Clicking on a member name will popup a
short description of the member.  Certain members may not appear in
the edit dialog. This is determined by the `show_iv' field of the
global settings (*note gui-settings::).  Typically the unshown
members will not be of interest to the average user, or will contain
values which are potentially dangerous to change.

   The Show menu on the right-hand side of the menu bar at the top of
the edit dialog will allow you to control how much stuff to view on a
case-by-case basis.  Typically, you'll only want to switch to viewing
Detail, which is not viewed by default, but all levels can be
controlled in this menu.  If you suspect that something is not there
which should be, try selecting Show/Detail.

   Fields that are highlighted in bright yellow indicate that the
field value is at variance with the default value for that field.

   The values associated with the member names appear to the right.
There are a number of different graphical representations of the
content of these fields, which are described in the following section.

   In addition, there can be special buttons and menu actions
available on the dialog.  These are described in subsequent sections.

* Menu:

* gui-edit-fields::             Member Fields
* gui-edit-buttons::            Dialog Buttons
* gui-edit-menus::              Dialog Menus


File: ta_css,  Node: gui-edit-fields,  Next: gui-edit-buttons,  Prev: gui-edit,  Up: gui-edit

Member Fields
-------------

   The member fields in an edit dialog can be found to the right of
the member name. These member fields can appear in many different
forms.  Sometimes there may even be more than one on a line.

Field Editor
============

   The Field Editor is used for editing strings (e.g., an object's
name), and number values. It appears as a box with text in it. If you
click on the box an Ibeam cursor appears at the click location. When
the mouse is in the box, the characters you type will be entered at
the Ibeam location point as you would expect.

   You must place mouse pointer in field to start editing!  However,
once you have started typing, the mouse pointer need only remain in
the overall window.

   Some Emacs style editing keys are also recognized, in addition to
the standard keypad arrow and related keys:

     Ctrl-f moves Ibeam forward (also right arrow key)

     Ctrl-b moves Ibeam backward (also left arrow key)

     Ctrl-a moves Ibeam to beginning of line (also Home)

     Ctrl-e moves Ibeam to end of line (also End)

     Ctrl-d deletes character to right of Ibeam (also Del)

     Ctrl-u selects the entire line - subsequent typing replaces
     contents

     Ctrl-n, TAB, or RETURN moves the Ibeam to the next field editor

     Ctrl-p or Shift-TAB moves the Ibeam to the previous field editor

     Alt-n moves to next object in list editor (also PageDn)

     Alt-p moves to previous object in list editor (also PageUp)

   You can also hit shift-mousebutton2 (middle button) to scroll the
text with the hand cursor.

   If the item to be edited is an integer then increment/decrement
arrow buttons will appear to the right of the field editor. Pressing
on these buttons will increase or decrease the value in the field
editor.  Pressing button-1 (left button) changes the value by 1,
button-2 (middle button) changes the value by 10, and button-3 (right
button) changes the value by 100. If the mouse button is pressed and
held, the action will auto repeat.

Read Only Member Field
======================

   The read only member field is like the FieldEditor except the user
cannot edit the field. It is used for display purposes only.

Boolean CheckBox
================

   The checkbox is used for boolean values that are either on or off.
Clicking on the checkbox changes its values. A checkmark or solid
block indicates an ON, TRUE or 1 value, while no checkmark or an
empty box indicates an OFF, FALSE or 0 value.

Enum Menus
==========

   The Enum menu is used for enumerated types. These types may have
one of a number of symbolic values. The menu is shown with the
member's current value. by clicking on the menu the other value
choices appear in a popup menu. Selecting an alternate value from the
menu sets the menu's value to the new value.

SubObject Menus
===============

   A SubObject menu is used when an instance of a class is part of the
edited object and that instance is not edited inline (*note
gui-edit-fields::). The menu has the name "Type: Actions" where Type
is the class name of the subobject. The menu contains the following
functions as well as object specific functions that are unique to the
subobject class.

     Load:             Load an instance of the subobject class

     Save:             Save the subobject using a file requester

     SaveAs:           Save the subobject with its last saved name

     Edit:             Edit the subobject

Object Pointer Menus
====================

   Object pointer menus are used when the member is a pointer to
another object. The current value of the pointer is shown in the
menubar as the pathname of the object that is pointed to. If the
pointer is not set, the name on the menubar will be set to NULL.
Clicking on the menubar brings up a popup menu of other objects of
similar type. Selecting an alternate object sets the menubar to the
name of that object. The popup menu also allows the user to set the
pointer to NULL and to Edit the object currently pointed to.

Object Type Menus
=================

   The object type menus are used when a member specifies a type
class of object. This menu allows the user to select from classes
which inherit from it base class. The current selection is displayed
in the menubar.

SubGroup Menus
==============

   The subgroup menu allows the user to interact with a group member
of the object. The name on the menubar is one of the two forms
depending upon whether or not the group has subgroups. (*note
obj-group::).

   Clicking on the menubar gives the user the following choices:

New
     Create new object in the group

Load
     Load a group from a file using a file requester. *Note
     obj-basics-files::.

Save
     Save the group using a file requester. *Note obj-basics-files::.

SaveAs
     Save the group with its last saved name. *Note
     obj-basics-files::.

Edit
     Bring up a Group Edit Dialog of the subgroup

RemoveAll
     Remove all the elements of the group

Remove
     Remove an individual element of the group

Link
     Link an object from another group into this group

Move
     Rearrange the order of the elements in this group

Transfer
     Transfer objects from another group into this one

EditEl
     Edit and individual element of the group

Find
     Find and edit an object with a given name

   Each of these selections will bring up a dialog for the user to
specify the parameters to the operation.

SubArray Menus
==============

   The subarray menu allows the user to interact with a array member
of the object. It appears as an  "Edit" menubar. Clicking on the
menubar gives the user the following choices:

Load
     Load an array from a file using a file requester. *Note
     obj-basics-files::.

Save
     Save the array using a file requester. *Note obj-basics-files::.

SaveAs
     Save the array with its last saved name. *Note
     obj-basics-files::.

Edit
     Bring up an Array Edit Dialog for the array

Remove
     Remove a number of elements from the array at a given index

Permute
     Permute the order of the elements in the array

Sort
     Sort the order of the elements in the array

El
     Show the value of a member of the array at given index

Add
     Add elements onto the end  the array

Insert
     Add a number of given values at a certain Array index

Find
     Find and Show the index of a member of the given value

ColorEdit
     Bring up a Color Array Editor for number arrays

Inline Fields
=============

   Inline Fields are used for small substructures within an object
(e.g., an object's position, which is only three values: x,y,z).
Instead of the expected SubObject menubar, the object is laid out
horizontally across on line in the Edit Dialog. The names of each of
the fields are often truncated so that the line will not take up too
much space. This allows quicker access and visualization without
having to traverse through multiple dialogs. The fields within an
inline field behave as do the rest of the fields in the dialog.


File: ta_css,  Node: gui-edit-buttons,  Next: gui-edit-menus,  Prev: gui-edit-fields,  Up: gui-edit

Edit Dialog Buttons
-------------------

   At the bottom of the Edit Dialog is a row of buttons which have
actions pertaining to the Edit Dialog's fields. Some of the buttons
may be appropriately inactive due the state of the edit dialog. They
will become active when their action is applicable. The following
buttons will be available:

`Ok'
     The Ok button stores the information in the dialog's fields in
     the object's fields and closes the dialog window.

`Apply'
     The Apply button stores the information in the dialogs fields
     but does not close the window. If the apply button is
     highlighted the edit dialog may contain changes which have not
     been applied yet. The apply action can also be generated by
     pressing the Return key in the body of the editor, unless the
     editor has multiple field editors within it (*note
     gui-edit-fields::).

`Revert'
     The Revert button reloads the information from the object into
     the dialog's fields, clearing any changes the user might have
     made. If the revert button is highlighted the object's fields
     might have been changed "behind the scenes" by another part of
     the program in which case the information displayed in the edit
     dialog may be outdated. The revert action can also be generated
     by pressing the Escape key in the body of the editor.

`Cancel'
     The Cancel button dismisses the dialog without applying the
     user's changes.

`Other Member Buttons'
     Some objects will add an additional row of member buttons to the
     Edit Dialog.(e.g., The Process object adds a row of
     Run,Step,Init buttons).  These buttons perform additional
     actions on the object.


File: ta_css,  Node: gui-edit-menus,  Prev: gui-edit-buttons,  Up: gui-edit

Edit Dialog Menus
-----------------

   At the top of the edit dialog is a menubar with at least two
menus.  The first menu entitled Object is similar to the Object menu
on a WinBase window. If the edited object is not a WinBase, the
"Object" menu my only provide the "Load", "Save, "Save As", and
"Close" menu choices. (*note gui-object::). The second menu called
"Actions" may contain member functions particular to the edited
object's type which will be called on the edited object.


File: ta_css,  Node: gui-settings,  Next: gui-colors,  Prev: gui-edit,  Up: gui

Settings Affecting GUI Behavior
===============================

   There are two primary ways of setting parameters which affect the
look of the GUI.  There is an object called taMisc which contains
miscellaneous parameters and settings that affect various aspects of
the PDP++ system, but mostly the graphical interface.  This object
can be edited by using the Settings menu option on the PDPRoot object.

   In addition to the taMisc settings, there are a number of XWindow
resources or Xdefaults that can be set. Also, since PDP++ uses the
InterViews graphics toolkit a number of command line arguments and
InterViews Xresources can also be customized (*note proj-startup::).

* Menu:

* gui-settings-tamisc::         Settings in taMisc
* gui-settings-xdef::           XWindow Resources (Xdefaults)


File: ta_css,  Node: gui-settings-tamisc,  Next: gui-settings-xdef,  Prev: gui-settings,  Up: gui-settings

Settings in taMisc
------------------

   The following parameters can be set:

`int display_width'
     Width of the shell display in characters.

`int sep_tabs'
     Number of tabs to separate items by in listings.

`int max_menu'
     The maximum number of elements in a menu -- if there are more
     than this number of instances (tokens) of a given type of
     object, then the menu for that type of object will say "<Over
     max, Select>", meaning that each item could not be listed
     separately in the menu, so you select this option to pull up a
     object chooser (see *Note gui-obj-chooser::), which allows you
     to choose the object from a longer list.

`int search_depth'
     The recursive depth at which css stops searching for an object's
     path.

`int color_scale_size'
     This determines how many colors are in a color scale for a color
     monitor (*note gui-colors::).

`int mono_scale_size'
     This determines how many colors are in a color scale for a
     monochrome monitor (*note gui-colors::).

`ShowMembs show'
     Type of members to show in css.

`ShowMembs show_iv'
     Type of members to show in edit dialogs The previous two
     variables can have one of four "ShowMembs" values:
    `ALL_MEMBS'
          Shows all members.

    `NO_READ_ONLY'
          Shows all but read_only members - stuff that can't be
          changed.

    `NO_HIDDEN'
          Shows all but hidden members - stuff that is hidden because
          it is not typically relevant.

    `NO_HID_RO'
          Shows all but hidden and r/o members.

    `NO_DETAIL'
          Shows all but "detail" members - stuff that might be
          relevant, but is not often accessed.

    `NO_HID_DET, etc.'
          Further combinations of RO, HID, and DET options.  The
     default is `NO_HID_RO_DET'.

`TypeInfo type_info'
     The amount of information about a class type that is reported
     when the "type" command is used in CSS.  Type_info has one of
     the following values:
    `MEMB_OFFSETS'
          Shows the byte offset of members.

    `All_INFO'
          Shows all type info except memb_offsets

    `NO_OPTIONS'
          Shows all info except type options

    `NO_LISTS'
          Shows all info but lists

    `NO_OPTIONS_LISTS'
          Shows all info but options and lists The default is
     `NO_OPTIONS_LISTS'

`KeepTokens keep_tok'
     This sets the Default for keeping tokens (lists of members) for
     object types.  This can have one of three "KeepTokens" values:
    `Tokens'
          Keep tokens as specified in the type.

    `NoTokens'
          Do not keep any tokens lists.

    `ForceTokens'
          Force the keeping of all tokens lists.  The default is
     `Tokens'.

`verbose_load'
     Indicates the amount of information reported in the shell window
     when objects are loaded

`iv_verbose_load'
     Indicate the amount of information reported in the Loading window
     when objects are loaded The previous two members may have one of
     the following values:
    `QUIET'
          No information is given

    `MESSAGES'
          General messages are reported for each object

    `TRACE'
          Each line of the file is printed as it is loaded

    `SOURCE'
          Intricate debugging details are reported

`bool auto_edit'
     If this value is on, an edit dialog will appear each time an
     object is created with the New dialog. (*note The Subgroup
     Menu(New): gui-subgroup.).

`AutoRevert auto_revert'
     In some cases a dialog may be reverted to its old values by a
     PDP++ process.  This variable controls the behavior of the edit
     dialog when this situation occurs. The behavior is determined by
     one of three values:
    `Auto_Apply'
          Automatically apply changes before auto-reverting

    `Auto_Revert'
          Automatically revert the edit dialog loosing changes

    `Confirm_Revert'
          Popup a confirmation dialog to okay reverting

`String include_paths'
     Directory Paths used for finding files.  This is an array of
     string values that represent paths to find CSS, defaults files,
     and Help files in (*note css-settings::, *note proj-settings::,
     *note proj-objdef::).

`String tmp_dir'
     The directory to use for temporary files

`String compress_cmd'
     Command to use for compressing files

`String uncompress_cmd'
     Command to use for uncompressing files

`String compress_sfx'
     Suffix to append to filenames when compressed

`String help_file_tmplt'
     Template for converting the type name of an object into a help
     file - %t is replaced with the type name.  Include any leading
     paths to help files relative to the basic root paths listed on
     include_paths.

`String help_cmd'
     Comand for bringing up a help browser to read help file
     (typically html, netscape by default).  %s is subsituted with
     the help file produced from `help_file_tmplt'.


File: ta_css,  Node: gui-settings-xdef,  Prev: gui-settings-tamisc,  Up: gui-settings

XWindow Resources (Xdefaults)
-----------------------------

   The following XWindow resources can be set.  These are typically
placed in the user's `.Xdefaults' file in their home directory.

`PDP++*flat'
     The color of the buttons.  It is typically some kind of greyish
     color.  The default has a blueish tint: `#c0c4d3'

`PDP++*background'
     The color of various non-view background regions.  The default
     is an aquamarine color: `#70c0d8'.

`PDP++*name*flat'
     If you change the valueof background, you should change this one
     to match.  It makes the member names in the edit dialogs (*note
     gui-edit::) the same color as the background.

`PDP++*apply_button*flat'
     The color of the apply button (and other buttons) when they are
     the "suggested" choice.  It is a dusty-red by default: `#c090b0'.

`PDP++*FieldEditor*background'
     The color of the edit fields, default is white.

`PDP++*font'
     The generic font to use for buttons, etc:
     `*-helvetica-medium-r-*-*-10*'.

`PDP++*name*font'
     The font to use for member names: `*-helvetica-medium-r-*-*-10*'.

`PDP++*title*font'
     The font to use for titles of edit dialogs:
     `*-helvetica-bold-r-*-*-10*'.

`PDP++*small_menu*font'
     The font to use for small menus (e.g., those in edit dialogs):
     `*-helvetica-medium-r-*-10*'.

`PDP++*small_submenu*font'
     This font is used for menu items that contain sub-menus (these
     are also indicated by three dots after the name)
     `*-helvetica-medium-r-*-*-10*'.

`PDP++*big_menu*font'
     This font is used for big menus like those on the permanent
     object windows, default is `*-helvetica-medium-r-*-12*'.

`PDP++*big_submenu*font'
     For sub menus on big menus: `*-helvetica-medium-r-*-*-12*'.

`PDP++*big_menubar*font'
     For big menus, the name of the menu itself:
     `*-helvetica-bold-r-*-*-14*'.

`PDP++*big_italic_menubar*font'
     For big menus, name of italicized menu items (i.e. those that
     apply to the object and not to its sub-objects):
     `*-helvetica-bold-o-*-*-14*'.

`PDP++*double_buffered:'
     Double buffering makes the display smoother, but can use lots of
     display memory.  Default is "on".

`PDP++*FileChooser.width'
     The width of the file-chooser in pixels. Default is 100.

`PDP++*FileChooser.rows'
     The number of items to list in the file chooser, default is 20.

`PDP++*clickDelay'
     This is the number of milliseconds to count two clicks as a
     double-click.  The default is 250.

For MS Windows Users:
---------------------

   To set XResources under MS Windows, you need to create an
"application defaults" file that is formatted much like the
XResources.  There are two steps for creating this application
defaults file:

   1. Edit `C:\WINDOWS\WIN.INI', and add the following two lines:

     [InterViews]
     location = C:\PDP++

   Where the location should be the actual location where you
installed the software.

   2. Create a sub-directory under `C:\PDP++' (again, use the actual
location) called `app-defaults', and then create a file called
`InterViews' in that directory.  This file should contain resource
values you want to set.  For example, to change the amount of time to
detect a double-click, you would enter:

     *clickDelay: 400

   To change the overall size of the PDP++ windows (scaling):

     *mswin_scale: 1.25

