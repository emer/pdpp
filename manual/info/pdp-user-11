This is pdp-user, produced by makeinfo version 4.1 from pdp-user.texi.


File: pdp-user,  Node: env-env,  Next: env-event,  Prev: env,  Up: env

Environments
============

   The Environment is used by the processes to present inputs to the
Network, and to provide training values for the network as well.  At
appropriate intervals, the processes will ask the environment for an
Event. The event is a snapshot or instance of the environment at a
given time. It is up to the environment to generate the appropriate
event given an index presented by the processes. Typically, these
events are precomputed and the environment simply iterates over the a
list of events. Optionally, an environment can perform more
complicated event choosing operations and can even modify or generate
events on the fly if so desired (supported by the
InteractiveScriptEnv, *Note env-other::).

   Sometimes the events may need to be further organized into
subgroups of events in order to represent groups of events that
belong in a particular sequence (*note env-seq::). Specialized
processes like the SequenceEpoch and the SequenceProcess interact
with the Environment by asking it for one of these subgroups of
Events. The Sequence Epoch allows updating of weights and other
operations to occur after the entire "batch" of events in the Event
SubGroup has been presented (*note proc-special-seq::).

   In summary, there are three different interfaces to the
environment:

1.
     A flat list of events accessed by event index (supported by the
     standard EpochProcess).  `InitEvents()' is called at the start,
     and a ScriptEnv can render a batch of events for each epoch.

2.
     Groups of events accessed first by group index, then by index of
     event within group (supported by SequenceEpoch and
     SequenceProcess, *Note proc-special-seq::).  This allows for
     subsets of events to be grouped together as a sequence.  Again,
     `InitEvents()' is called at the start of the entire epoch.

3.
     An 'interactive' model that doesn't depend on indicies at all,
     supported by InteractiveEpoch (*note proc-special-inter::).  This
     allows for events to depend on what has just happened in the
     network.  `InitEvents()' is called at the start of an epoch, and
     `GetNextEvent()' is called for each new event until it returns a
     NULL.  In a IneractiveScriptEnv, `GetNextEvent()' calls the
     script, and returns the event in the `next_event' pointer (which
     needs to be set by the script) - see *Note env-other:: for
     details.

   In the generic Environment class there are two groups:

`Event_Group events'
     This is where the events are stored.

`BaseSpec_Group event_specs'
     This is where the EventSpec objects are stored.  Note that event
     specs, unlike other specs, reside in the environment, and not in
     the Project `.specs' group.  This makes environments
     self-contained so that they can be loaded and saved independent
     of the project.

   The following functions are defined on the Environment object.
Note that a given process will either use the Group model or the
Event model of the environment.  The group model is for sequences,
which are stored in subgroups, and the event model treats the
environment just like a flat list of events.  These functions are on
the Actions menu:

`InitEvents()'
     Initializes events for an epoch. Used for algorithmically
     generated events which are generated at the start of each epoch.
     This does nothing in the base class, but in a `ScriptEnv' it
     calls the script, which can then generate events.

`UpdateAllEvents()'
     Updates all events in accordance with their corresponding event
     specs.  This should happen automatically but things can get out
     of whack and this should clean everything up.

`UpdateAllEventSpecs()'
     Updates all events in accordance with their corresponding event
     specs.  This should happen automatically but things can get out
     of whack and this should clean everything up.

`EventCount()'
     Returns the number of events in the Environment.  This is used
     by the processes to determine how long an epoch should be.

`GroupCount()'
     Returns the number of event groups in the Environment, for
     sequence-based processing.  This determines how many sequences
     go in an epoch.

`GetNextEvent()'
     Returns the next event for processing (or NULL to signal the end
     of the epoch).  This is the interface for the interactive
     environment model (hook for generating new event based on
     current state).

`UnitNamesToNet(EventSpec* event_spec_with_names, Network* network)'
     Copies names from pattern spec `value_names' to corresponding
     units in the network.  Uses default event spec and network if
     NULL.  This is a convenient way to name units in the network -
     these names are otherwise lost when the network is rebuilt.

`AutoNameAllEvents(float act_thresh, int max_pat_nm, int max_val_nm)'
     Automatically name all events based on the pattern names and
     value (unit) names for those units with activations above
     act_thresh, e.g., `Inp:vl1_vl2,Out:vl1_vl2'.  There are also
     versions of this functionality in Events and Event specs.

   The following functions are defined in the Object menu and provide
additional input/output functionality:

`ReadText(ostream& strm, EventSpec* espec, TextFmt fmt)'
     Reads in an Environment from a text file which is in the format
     from the old PDP software, or other formats based on the fmt
     parameter.  This uses the given event spec which must correspond
     to the pattern file being read in.  See *Note env-import::.

`WriteText(istream& strm, int pat_no, TextFmt fmt)'
     Writes an Environment to a text file in the format from the old
     PDP software, or other formats.  See *Note env-import::.

`ReadBinary(ostream& strm, EventSpec* espec)'
     Reads in an Environment from a binary file, which must be just a
     continuous stream of floating point numbers that are applied in
     sequence to the patterns and events of the environment.  See
     *Note env-import::.

`WriteBinary(istreamm& strm, int pat_no=-1, TextFmt fmt = NAME_FIRST)'
     Writes an Environment to a binary file as a continuous stream of
     floating point numbers.  See *Note env-import::.

   The following are function interfaces used by processes to access
events:

`GetEvent(int event_number)'
     Returns a pointer to the Event corresponding to `event_number'.
     The event number should be between 0 and `EventCount()'.

`GetGroup(int group_number)'
     Returns a pointer to the Event group corresponding to
     `group_number', which should be between 0 and `GroupCount()'.


File: pdp-user,  Node: env-event,  Next: env-seq,  Prev: env-env,  Up: env

Events, Patterns and their Specs
================================

   Events are the snapshots of the Environment presented to the
Network.  They represent a single coherent set of stimuli drawn from
the environment.  They are comprised of a set of patterns, which hold
the information affecting the network on a layer by layer basis.

   The structure of an event is determined by its corresponding
EventSpec.  Any changes made in the event spec are automatically made
to all of the events that use that event spec.  Thus, there must be
one event spec for each different type of event created.  Event specs
reside in the environment itself, and not in the Project like other
specs.  The Event has a pointer to its spec, called `spec'.  This
works just like other spec pointers (*note obj-spec::).

   Both the Event and EventSpec objects are essentially just
containers for their constituent Pattern and PatternSpec objects,
which are also kept in one-to-one correspondence.  Thus, any new
pattern specs added in the `pattern' group in an event spec will
result in corresponding patterns in the `pattern' group on the event.
Different varieties of events will add event-level parameters like
frequency and time (*note env-freq::, *Note env-other::).

   A Pattern is simply a list of real numbers, which are kept in a
floating-point Array object called `value'. It can be "applied" to a
specified layer in the network.  Each element of the value array in
the Pattern corresponds to a Unit in the Layer.  In addition, one can
assign a flag to each value, which will alter how this value is
applied to the units in the network.  The `flag' member of a Pattern
holds the flags, which are only present if the `use_flags' field in
the corresponding pattern spec is set to `USE_PATTERN_FLAGS' or
`USE_PAT_THEN_GLOBAL_FLAGS'. All of the flags are independent of each
other and be either on or off. The meaning of the flag values are
given in the `PatFlags' enumerated type in the PatternSpec and listed
below.

`TARG_FLAG'
     unit's TARG flag is set

`EXT_FLAG'
     unit's EXT flag is set

`COMP_FLAG'
     unit's COMP flag is set

`TARG_VALUE'
     pattern value goes to the unit targ field

`EXT_VALUE'
     pattern value goes to the unit ext field

`NO_UNIT_FLAG'
     no unit flags are set, but value is set as normal

`NO_UNIT_VALUE'
     don't set the unit's value, but flag as normal

`NO_APPLY'
     don't apply this value to unit (no flags either)

   The options include the ability to control how the unit's external
input will be flagged, and where the value will be copied on the Unit
(i.e., to its `targ' or `ext' field).  This gives the user complete
control over how the pattern value is presented.

   Note that the `value' field is an `float_RArray' type, which has a
range associated with it (hence the RArray), and it also has a number
of other useful functions that enable the distance between two arrays
to be computed, or various statistics like the mean, variance, etc.
to be computed on a given array.  These functions may be useful in
creating and analyzing patterns.

   The PatternSpec has several fields which determine where its
corresponding pattern is presented, and what meaning it has to the
network:
`PatType type'
     The type of the pattern, which determines how the network will
     interpret its values.  This can be one of the following values:
    `INACTIVE:'
          The corresponding pattern is not presented to the network.

    `INPUT:'
          The corresponding pattern is presented to the network as
          external input activation: the value is copied to the `ext'
          variable of the corresponding Unit, and the `EXT' flag is
          set on the `ext_flags' of the unit (and the layer the unit
          is in).

    `TARGET:'
          The corresponding pattern is presented to the network as
          target activation: the value is copied to the `targ'
          variable of the corresponding Unit, and the `TARG' flag is
          set on the `ext_flags' of the unit (and the layer the unit
          is in).

    `COMPARE:'
          The corresponding pattern is presented to the network as
          comparison pattern, which does not affect activation states
          or learning, but can be used to compare output values to
          expected ones via error statistics (e.g., the SE_Stat). The
          value is copied to the `targ' variable of the corresponding
          Unit, and the `COMP' flag is set on the `ext_flags' of the
          unit (and the layer the unit is in).


`PatLayer to_layer'
     The network layer to present the Pattern to. This can be one of
     the following values:
    `FIRST:'
          Apply to the first layer in the network.

    `LAST:'
          Apply to the last layer in the network.

    `LAY_NAME:'
          Specify the Layer to apply to by name. The name should be
          set in the variable `layer_name'.

    `LAY_NUM:'
          Specify the Layer to apply to by layer number. The number
          should be set in the variable `layer_num'.


`String layer_name'
     Contains the name of the layer to apply to (used if `to_layer' is
     set to `LAY_NAME').

`Int layer_num'
     Contains the number of the layer to apply to (used if `to_layer'
     is set to `LAY_NUM').

`TypeDef* pattern_type'
     Determines the type of Pattern object that is created in events
     that use this pattern spec.  Changing this after events have
     already been created will _not_ cause them to change pattern
     types.  You have to remove the Events and start over if you want
     to change the types of patterns that are used.

`LayerFlags layer_flags'
     Determines how the layer's `ext_flags' will be set.  The
     `DEFAULT' is to set them according to the pattern `type' as
     described above, but they can be set to any of the possible
     combinations of flags (`TARG, EXT, COMP'), or to
     `NO_LAYER_FLAGS' at all.  This can be useful if you have an
     pattern which uses flags for different values (see `use_flags')
     so the layer actually receives multiple different kinds of
     external input.

`PatUseFlags use_flags'
     Determines how the `flag' field of the Pattern and the
     `global_flags' of this PatternSpec will be used when applying the
     Pattern to the network.  This can be one of the following values:
    `USE_NO_FLAGS:'
          Both pattern flags and global flags are ignored

    `USE_PATTERN_FLAGS:'
          Patterns flags are applied, global flags are ignored

    `USE_GLOBAL_FLAGS:'
          Global flags are applied, individual pattern flags are
          ignored

    `USE_PAT_THEN_GLOBAL_FLAGS:'
          If any flags are set on the pattern then use all the
          pattern's flag settings, otherwise apply the global flags
          for that pattern. Note that the choice of global versus
          pattern flags is not done individually by each flag on the
          pattern but rather as an all or nothing check on each
          pattern to determine if any of its flags are set.


`int n_vals'
     The number of values to create in the corresponding pattern.  It
     should be equivalent to the number of units in the corresponding
     layer.  If this value is set to 0, it will be filled in with the
     number of units on the corresponding layer of the default
     network in the current project, if the layer can be found.

`PosTDCoord geom'
     Determines the shape of the values as displayed in the
     EnviroView.  It should correspond to the geom of the
     corresponding layer, and is initialized as such if possible.

`PosTDCoord pos'
     The position of the start of the event in the EnviroView.  Any
     overlap of displayed patterns is detected automatically, and the
     `LinearLayout' action on the EventSpec can be called to arrange
     the events linearly across or down the display.

`float initial_val'
     The initial value that will be placed in newly created pattern
     `value' arrays.

`Random noise'
     This adds random noise of the given specification as the pattern
     is applied to the network.

`String_Array value_names'
     The elements in this array are in one-to-one correspondence with
     the values in the pattern, and can be used to label the patterns
     in the EnviroView (*note env-view::).  This is very useful

`int_Array global_flags'
     This contains flags that can apply (depending on `use_flags') to
     all of the patterns, determining how they are presented.

   Note: the following information should be useful to those who wish
to program in PDP++, but is not necessary for the average user to
understand.

* Menu:

* env-event-impl::               Implementational Details of Events and Patterns


File: pdp-user,  Node: env-event-impl,  Prev: env-event,  Up: env-event

Implementational Details of Events and Patterns
-----------------------------------------------

   Note that layer pointer in a pattern spec depends on which network
the environment is being applied to.  Thus, there is some checking
that takes place when an event is being applied to the network to
make sure that the layer pointers are up-to-date.  Along these same
lines, any time the events or patterns are edited, the layer pointers
are reset, with the idea being that they might have changed where the
patterns are being applied to.

   The basic set of functions can be found in the `src/pdp/enviro.h'
file.  They are fairly straightforward.


File: pdp-user,  Node: env-seq,  Next: env-view,  Prev: env-event,  Up: env

Representing Sequences of Events
================================

   Sequences of events are represented in PDP++ by creating subgroups
within the main `.events' group of an environment.  Each sub group
should contain a set of events that define one discrete sequence of
related events.  If the appropriate SequenceEpoch and Sequence
processes are used, they will access the `GroupCount' and `GetGroup'
functions on the environment (*note env-env::), which will allow the
epoch-level process to iterate over the groups (sequences) in the
environment, while the sequence process iterates over the events
within each group.  The sequence-based processes are discussed in
*Note proc-special-seq::.


File: pdp-user,  Node: env-view,  Next: env-import,  Prev: env-seq,  Up: env

The EnviroView
==============

   The EnviroView provides a graphical representation of the
Environment, allowing the user to view, create, and edit Events and
Patterns and their corresponding specs.  In addition the EnviroView
can be used to track the current Event presented to the network by
setting its updaters (*note gui-win-view::).

   There are two basic modes to the enviro view -- initially, it is in
Edit Events mode, where the Events and Patterns are displayed and can
be edited.  By hitting the Edit Specs button at the top of the
left-hand set of buttons, the display changes to editing the
EventSpecs and PatternSpecs.

* Menu:

* env-view-events::             Edit Events Mode
* env-view-specs::              Edit Specs Mode


File: pdp-user,  Node: env-view-events,  Next: env-view-specs,  Up: env-view

Edit Events in the EnviroView
=============================

   Figure of: <The Environment Viewer - Events> here

   Non-obvious actions you can perform on objects in the EnviroView
Single-click with left-mouse-button (LMB) on Event Button
     Will select event for display in the view area to the right.

Single-click with right-mouse-button (RMB) on Event Button
     Will bring up the edit dialog for the Event.

Shift-LMB or middle-mouse-button (MMB) on Event Button
     Extends the selection to include multiple events, and can remove
     an event from the display if performed on an already-selected
     event.

Click on alreadly selected Event Group Button
     Will select all the events within the group, and deselect the
     group button.

LMB on a pattern element of displayed event
     Will set the value of that pattern element according to
     highlighted drawing color (in color palette at bottom of
     display).

MMB on a pattern element of displayed event
     Will set the value of that pattern element to 0.

RMB on a label on the displayed event
     Will allow you to edit the value (e.g., change the event name,
     or its frequency if that is what is displayed).

Turning off the Disp checkbox at top prevents display of events
     This can be useful for manipulating large numbers of events
     using the event buttons - just turn off the Disp and then you
     can select all the events for setting specs or changing types,
     etc.

   All of the events in the Environment are listed sequentially from
top to bottom in a scrollable vertical list on the left side of the
EnviroView.  The index number of the event is shown on the left-hand
side of the label, and the first four characters of the sub-group
name if the event is in a sub-group.  Sub-groups have their own
button that preceeds the events that are within them, and are
indicated by the `>>' symbol on the left of the button.  Selecting
these group buttons twice (double clicking) will select all the
events within them.

   The following action buttons appear in the upper left of the
EnviroView:
`New Evt/Gp'
     This button provides a convenient method for creating events or
     sub-groups in the Environment. Pressing the New Evt/Gp button
     creates a "New" dialog which prompts the user for the number and
     type of events or groups to create. Each new event is modeled
     after the default (usually the first) EventSpec in the
     Environment. If there are no EventSpecs, a default EventSpec
     consisting of an input pattern for the `FIRST' layer and a
     target output pattern for the `LAST' layer is created for the
     new events.  If there are currently no events, the button will
     appear hi-lighted indicating that it is the suggested course of
     action.  If there is one sub-group selected, then this button
     will create events within that selected subgroup.

`Delete'
     The Delete button removes the currently selected Events or
     groups from the Environment.

`Xfer/Dupe, Xfer Event, Dupe Event, Dupe Group'
     If event(s) are selected, Dupe Event will duplicate them.  If
     sub-group(s) are selected, Dupe Group will duplicate them (and
     their associated sub-events).  If a group and some events are
     selected, then Xfer Event will transfer the events into the
     selected group.

`Set Spec/Type, Change Type'
     If event(s) are selected, Set Spec/Type will bring up a choice
     of either setting the spec for these events, or changing their
     type.  If sub-group(s) are selected, Change Type will change
     their type.

`Apply'
     The Apply button saves the changes made to the Patterns. It will
     appear hi-lighted if there are potentially changes which have
     not been saved.

`Init/Revert'
     The Init button refreshes the EnviroView to reflect the stored
     values of the currently displayed Events. Any un-applied changes
     to the patterns will be lost.

   At the bottom of the EnviroView is a painting ColorBar. This
colorbar differs from the colorbar in the scale region of the NetView
in that the different shades of color are selectable for use in
"painting" values into the patterns of the Events. In addition, four
custom value pads are provided for entering specific values. The
color corresponding to the value of the pad appears next to the value
and is selectable for use in painting just like to shades of the
colorbar. These pads appear above the ColorBar and have default
values of (-1.0, 0.0, 0.5, 1.0), which can be changed just by typing
in a new value. The minimum and maximum of the range of the ColorBar
may be independently specified or automatically scaled to the minimum
and maximum value of the currently displayed events if the "Auto
Range" toggle in the upper left corner of the EnviroView is selected.

   When an Event is selected for viewing, it appears in the
EnviroView as as set of name labels and colored blocks. The labels
and blocks are positioned according to `pos' and `geom' values of the
PatternSpecs for each Pattern in the Event (see *Note
env-view-specs:: for how to configure this interactively). The color
of the blocks corresponds to its value in the ColorBar at the bottom
of the EnviroView. If a pad or shade value is selected in the
ColorBar, the user may change the values of the Patterns by clicking
or dragging on the colored blocks. Pressing the left mouse button
changes the value of the block under the mouse pointer to be the
selected value in the ColorBar. Pressing the middle mouse button
changes the block's value to it previous value.

   In the upper left area of the EnviroView are several menus which
control certain features of each event which is displayed.  The first
menu called Val Txt determines what kind of textual information is
rendered along with the pattern values (could be `VALUES' or `NAMES'
(for the value_names) aor `BOTH').  The Disp Md: menu selects the way
in which the values are rendered - `COLOR', `AREA', or `LINEAR', just
as in the NetView (*note net-view::).

   The next two menus control what kinds of labels are shown along
with each event and each pattern.  Evt Label controls which propery of
the Event is shown in the Event Label region (bottom) of the displayed
events. Likewise, the Pat Label menu contols what pattern properties
are shown in the formatted pattern label section of the displayed
events (at the top of each pattern). If the displayed event and/pr
pattern does not have the propery which is selected, a "n/a" will be
displayed.

   The Pat Block menu controls which property of the pattern is being
displayed and edited when the user clicks on the pattern blocks
described above. By default this menu is set to "Pattern Values"
indicating that changes in the blocks colors reflect changes in the
actual values of the patterns. More complicated patterns which behave
in specialized ways can be created by changing the the "Pat Block"
menu to one of the other selections and editing a pattern's flags
(*note env-event::.) When editing pattern values a color value greater
than zero sets the flag on, and a colorvalue less than or equal to
zero sets the flag off. The user may also choose to edit the global
PatternSpec flags from this menu. In this case the global flags on the
displayed pattern's PatternSpec will be displayed and changed when the
"Apply" button is pressed. Note that if multiple Events are being
edited and more than one of those Events shares the same EventSpec
then the last selected Event's values will be applied when the
"Apply" button is pressed.

   The EnviroView provides the following variables for customizing the
display:
`EventLayout event_layout'
     Controls whether events are arranged `VERTICALLY' or
     `HORIZONTALLY' when multiple events are selected for viewing.

`bool auto_scale'
     Controls whether or not the ColorBar at the bottom off the
     EnviroView is automatically scaled to reflect the minimum and
     maximum pattern values of the Events currently displayed in the
     EnviroView.

`ValDispMode val_disp_mode'
     Controls how the values of the Patterns are displayed in the
     blocks. The `COLOR' setting fills the blocks with the colors
     from the colorbar, while the `AREA', and `LINEAR' settings draw
     size varying spirals in the blocks. The spirals are similar to
     the spirals available for viewing in the NetView and a described
     in more detail in that section. (*note net-view::).

`ColorScale* colorspec'
     The colorscale to use for the ColorBar at the bottom of the
     EnviroView (*note gui-colors::).

`ValTextMode val_text'
     Can be `VALUES' or `LABELS' or `BOTH' (same as Val Txt menu) -
     controls whether or not the names stored in PatternSpecs'
     `value_names' array are displayed on top of the blocks (LABELS),
     and/or the numerical value of the pattern is displayed (VALUES).

`bool no_border'
     If selected, this eliminates the black border around the pattern
     values.  This is useful for displaying picture-like stimuli.

`FontSpec view_font'
     The X11 specification for the font to use in drawing all of the
     basic text in the view.

`FontSpec value_font'
     The X11 specification for the font to use in drawing the pattern
     labels and values in the View Region (might want it smaller).

   In addition, the EnviroView provides the following functions:
`SelectEvents(int start=0, int n_events=-1)'
     This will automatically select a range of events for display in
     the view - saves on clicking.  start is the index of the event
     to start displaying, and n_events is the number to display (-1 =
     all).

`DeselectEvents(int start=0, int n_events=-1)'
     This is the de-selecting complement to SelectEvents.

`SetEventSpec(EventSpec* es)'
     Changes the EventSpec of all the currently displayed Events to
     `es'

`ChangeEventType(TypeDef* new_type)'
     Change event types for selected events

`ChangeEventGpType(TypeDef* new_type)'
     Change event group types for selected event groups

`DuplicateEvents()'
     Duplicate selected events

`DuplicateEventGps()'
     Duplicate selected event groups


File: pdp-user,  Node: env-view-specs,  Prev: env-view-events,  Up: env-view

Edit Specs in the EnviroView
============================

   Figure of: <The Environment Viewer - Specs> here

   Non-obvious actions you can perform on objects in the EnviroView
in this mode are:
Single-click with left-mouse-button (LMB) on EventSpec Button
     Will select event spec for display in the view area to the right.

Single-click with right-mouse-button (RMB) on EventSpec Button
     Will bring up the edit dialog for the EventSpec.

Shift-LMB or middle-mouse-button (MMB) on EventSpec Button
     Extends the selection to include multiple event specs, and can
     remove an event spec from the display if performed on an
     already-selected event spec.

RMB on text in the view area
     Will bring up an edit dialog for that text.

   As in the "Edit Events" mode, the "Edit Specs" mode displays event
specs in a scroll box along the bottom left-hand side of the window.
It differs in having a variety of different action buttons above
that, and in the way that the event specs and pattern specs are
displayed.

   When you click on an event spec, the event spec is displayed in
"skeleton" format in the viewer area.  By default, if there is only
one event spec, it is automatically selected.  The overall event spec
is represented by a box, within which there are one or more pattern
specs, represented by a grid of pattern elements.  At the lower-left
of the pattern spec is a display of four critical pieces of
information about how that pattern is to be presented to the network
(type, to_layer, layer_name, and layer_num, see *note env-event:: for
details).  The total number of values in a pattern is indicated by a
grey square with the "n_vals" label on it and a number indicating the
number of values.  This can be moved to change the total number of
values within the constraints of the overall pattern geometry.

   There are four mutually-exclusive tool selection buttons at the
top of the action area, which operate much like their counterparts in
the NetView:

`Select'
     Select mode makes clicking in the view area act to select items.
     In select mode, the entire event spec is selected upon the
     first click, and then the patternspec under the mouse is
     selected on the next click, and then any further sub-level of
     text is after that.   Some of the other action buttons will
     update based on what is currently selected.

`Move'
     Move mode enables moving of PatternSpecs within the event.  The
     patterns will be directly selected upon first mouse click, so
     just click and drag.  You can also determine the total number of
     values in an event by moving the grey square that has the
     "n_vals" label on it, which typically is located in the
     upper-right corner of each pattern spec.  You can also move the
     entire display by clicking on the background and dragging it
     around.

`ReShape'
     This allows you to reshape the geometry of the PatternSpecs.
     Simply click and drag to reshape the patternspec geometry.

`ReScale'
     This only works on the background, and serves to rescale the
     size of the entire display.

   Below that are four buttons that change character depending on
what is selected:

`New Spec, New Pattern, Set To Layer'
     If nothing is selected, New Spec will allow you to create a new
     Event Spec (if one is selected, use Dupe Spec to get a new one).
     If an EventSpec is selected, New Pattern will allow you to
     create a new PatternSpec within that EventSpec.  If a
     PatternSpec is selected, Set To Layer will prompt you for the
     name of a network Layer, and will configure the pattern to fit
     the geometry, etc of this layer (it will ensure that this
     pattern fits that layer and will be send to that layer when
     presented).  Set To Layer is the easiest and safest way to
     configure a pattern for a given network layer (see also Updt Fm
     Events)!.

`Rmv Spec(s), Pat(s)'
     Will remove (delete) selected EventSpecs or PatternSpecs.

`New Child, Edit Names'
     New Child makes a child spec of selected EventSpec - a child spec
     inherits all the properties of the parent, except those checked
     as being unique.  The only way to mark features as unique is to
     edit the pattern spec.  Edit Names of a selected Pattern Spec
     will pull up an editor for the `value_names' that label values
     with names.

`Layout/Updt'
     Pops up a dialog for selecting one of two actions: Linear Layout
     will arrange patterns in a line with a single space between them
     - useful for quickly arranging patterns that might be spread
     out.  Updt Fm Layers will go through each pattern and perform
     Set To Layer on that pattern, based on the current layer that
     each pattern is associated with.  This is a quick way to update
     the environment to any changes you have made to your network.

`Copy Fm Spec'
     Allows you to copy parameters from another event spec to
     selected one.

`Dupe Spec'
     Duplicates currently selected event spec.

`Edit Spec(s), Pat(s)'
     Will bring up an edit dialog for selected objects (note: can
     also use RMB).

`Init'
     Rebuilds the display - should not generally be necessary but use
     if you suspect display is not up-to-date.

   So, a typical session starting from scratch would be to do New
Spec, then click on each pattern spec in turn and do Set To Layer and
select the layer these patterns will go to.  Then, the patterns may
have to be moved around a bit, or new patterns created if there are
more than two that receive environmental input (or one removed, etc).
In general, everything should be managable within the interface.


File: pdp-user,  Node: env-import,  Next: env-gen,  Prev: env-view,  Up: env

Importing Environments from Text Files
======================================

   To aid in the conversion of environments from the old PDP software
to the format used in PDP++ (`.pat' files), and for generally
importing training and testing data represented in plain text files,
we have provided functions on the Environment that read and write text
files.  These functions are called `ReadText' and `WriteText'.

   There is also a FromFileEnv that reads event patterns from files
incrementally during processing (*note env-other::).

   The format that these functions read and write is very simple,
consisting of a sequence of numbers, with an (optional) event name at
the beginning or end of the line.  Note, you must specify using the
fmt parameter whether there will be a name associated with the events
or not.  Important: the name must be a contiguous string, without any
whitespace - it can however be a number or have any other ASCII
characters in it.  When reading in a file, ReadText simply reads in
numbers sequentially for each pattern in each event, so the layout of
the numbers is not critical.  If the optional name is to be used, it
must appear at the beginning of the line that starts a new event.

   For example, in the old PDP software, the "xor.pat" file for the
XOR example looks like this:

     p00 0 0 0
     p01 0 1 1
     p10 1 0 1
     p11 1 1 0

   It is critical that the EventSpec and its constitutent
PatternSpecs (*note env-event::) are configured in advance for the
correct number of values in the pattern file.  The event spec for the
above example would contain two PatternSpecs.  The PatternSpecs would
look like:
     PatternSpec[0] {
        type = INPUT;
        to_layer = FIRST;
        n_vals = 2;
     };
     
     PatternSpec[0] {
        type = TARGET;
        to_layer = LAST;
        n_vals = 1;
     };

   So that the first two values (n_vals = 2) will be read into the
first (input) pattern, and the third value (n_vals = 1) will be read
into the last (output) pattern.

   The `ReadText' function also allows comments in the .pat files, as
it skips over lines beginning with # or //.  Further, `ReadText'
allows input to be split on different lines, since it will read
numbers until it gets the right number for each pattern.

   There is a special comment you can use to control the creation and
organization of subgroups of events.  To start a new subgroup, put the
comment `# startgroup' before the pattern lines for the events in
your subgroup (note that the `# endgroup' comments from earlier
versions are no longer neccessary, as they are redundant with the
startgroup comments - they will be ignored).  For example, if you
wanted 2 groups of 3 events you might have a file that looked like
this:

     # startgroup
     p01 0 0 0
     p02 0 1 1
     p03 0 1 0
     # startgroup
     p11 1 0 1
     p12 1 1 0
     p13 1 1 1

   `WriteText' simply produces a file in the above format for all of
the events in the environment on which it is called.  This can be
useful for exporting to other programs, or for converting patterns
into a different type of environment, one which cannot be used with
the CopyTo or CopyFrom commands.  For example if events were created
originally in a TimeEnv environment, but you now want to use them in
a FreqEnv frequency environment, then you can use WriteText to save
the events to a file, and then use ReadText to read them into a
`FreqEnv' which will enable a frequency to be attached to them.

   For Environments that are more complicated than a simple list of
events, it is possible to use CSS to import text files of these
events.  Example code for reading events structured into subgroups is
included in the distribution as `css/include/read_event_gps.css', and
can be used as a starting point for reading various kinds of
different formats.  The key function which makes writing these kinds
of functions in CSS easy is `ReadLine', which reads one line of data
from a file and puts it into an array of strings, which can then be
manipulated, converted into numbers, etc.  This is much like the
`awk' utility.

   The `read_event_gps.css' example assumes that it will be read into
a `Script' object in a project, with three `s_args' values that
control the parameters of the expected format.  Note that these
parameters could instead be put in the top of the data file, and read
in from there at the start.

   The binary read/write functions (`ReadBinary', `WriteBinary')
simply read and write a stream of floating point numbers in native
binary format.  These files are not necessarily portable, but are
much more compact for large data sets.


File: pdp-user,  Node: env-gen,  Next: env-analyze,  Prev: env-import,  Up: env

Environment Generation Functions
================================

   The following functions are available on the Environment object (in
the Generate menu) for algorithmically creating events.  See
`demo/bp_misc/gen_rnd_prototypes.css' for a CSS script that creates
prototypes and random exemplars based on these prototypes using some
of the following functions.

`ReplicateEvents(int n_replicas, bool make_groups)'
     This will create n_replicas of all of the existing events in the
     environment.  If make_groups is set, then all events which are
     replicas of a given one will be placed into the same sub-group.
     Otherwise, the replicas appear right after the event they are
     replicas of.  This can be used to replicate a set of prototype
     events, and noise can be added (AddNoise, FlipBits) to create
     random distortions of these prototypes.

`PermutedBinary(int pat_no, int n_on)'
     This produces random (permuted) binary patterns of 1's and 0's
     over the existing events in the environment.  `pat_no'
     determines which pattern to use, and `n_on' specifies the number
     of 1's in each random pattern.

`PermutedBinary_MinDist(int pat_no, int n_on, float dist, bool max_correl)'
     This is like PermutedBinary, but it ensures that the hamming
     distance between any two patterns is at least `dist' (i.e., all
     patterns are separated by at least this minimum distance).  If
     max_correl is set, this ensures that the maximum correlation
     between patterns is below the `dist' value.

`FlipBits(int pat_no, int n_off, int n_on)'
     This switches exactly `n_off' values of a pattern from 1 to 0,
     and `n_on' from 0 to 1.  In other words, some values that were 1
     will now be 0, and some values that were 0 will now be 1.  This
     is a useful way of creating random distortions of prototypical
     patterns.

`FlipBits_MinMax(int pat_no, int n_off, int n_on, float min_dist, float max_dist, metric, norm, tol)'
     This does FlipBits, but if the new event that was just flipped is
     outside the distance limits set by min_ and max_dist, according
     to the metric supplied, then another pattern is tried.  There is
     a timeout and an error message will be reported if it takes too
     many retries to fit these criteria.

`Clear(int pat_no)'
     Simply clears out the pattern values to a specified value (e.g.,
     zero).

`AddNoise(int pat_no, Random rnd_spec)'
     This will add noise of the given specification to all events in
     pattern `pat_no'.

`TransformPats(int pat_no, PreProcessVals trans)'
     This will apply given transformation (simple math) operation to
     all events in pattern `pat_no'.


File: pdp-user,  Node: env-analyze,  Next: env-freq,  Prev: env-gen,  Up: env

Environment Analysis Functions
==============================

   The following functions are available on the Environment object
(in the Analyze menu) for analyzing the patterns in the environment.
Some of these functions can also be called from the Log objects in
their own Analyze menu (*note log-views-logview::), and by the
DispDataEnvProc process that automatically analyzes data collected in
an environment from a statistic (*note proc-special-misc::).

`DistMatrix(ostream& strm, int pat_no, metric, norm, tol, format, precision)'
     This produces a distance matrix between all events for given
     pattern to a file specified by strm.  The metric and associated
     parameters determine how distance is computed.  Norm is whether
     to normalize entire distance, and tol is a unit-wise tolerance,
     below which dist = 0.  The output format can be varied according
     to the format and precision parameters.

`DistMatrixGrid(GridLog* disp_log, metric, norm, tol)'
     This produces a distance matrix between all events for given
     pattern, and sends it to the given GridLog for immediate display
     (if NULL, a new GridLog is created).

`CmpDistMatrix(ostream& strm, int pat_no, Environment* cmp_env, int cmp_pat_no, metric, norm, tol, format)'
     This produces a distance matrix between all events across two
     different environments, for given pattern on each.

`CmpDistMatrixGrid(ostream& strm, int pat_no, Environment* cmp_env, int cmp_pat_no, metric, norm, tol, format)'
     This produces a distance matrix between all events across two
     different environments, for given pattern on each, and displays
     the results in a grid log.

`ClusterPlot(GraphLog* disp_log, int pat_no, metric, norm, tol)'
     This produces a cluster plot of the distance matrix between all
     events for given pattern, and sends it to the given GraphLog for
     immediate display.  The clusterplot recursively groups the most
     similar items together, and uses the average of the individual
     cluster element distances to compute the distance to a cluster,
     instead of computing an average vector for a cluster and using
     that to compute distances.  This makes the algorithm somewhat
     more computationally intensive, but also produces nicer results
     (the distance metric is cached so distances are only computed
     once, so it should handle relatively large numbers of events).

`CorrelMatrixGrid(GridLog* disp_log, int pat_no)'
     Generates a correlation matrix for all patterns in `pat_no' in
     the environment and plots the result in grid log (NULL = new
     log).  The correlation matrix is defined by taking a vector of
     each pattern value (e.g., the first element in the pattern)
     across all events, and computing the correlation of this vector
     of values with those of all the other such value vectors.  As
     such, it measures the degree to which the variation of one
     pattern value (across events) correlates with the variation of
     another pattern value (across events).

`PCAEigenGrid(GridLog* disp_log, int pat_no, bool print_eigen_vals)'
     Performs principal components analysis (PCA) of the correlations
     of patterns in `pat_no' across events, plotting all eigenvectors
     in the grid log (NULL = new log).  The eigenvectors are the
     orthogonal components of the correlations ordered in terms of
     how much variability they account for.  The first principal
     component (eigenvector) accounts for the greatest amount of
     variability in the correlation matrix, etc.  Note that the
     eigenvectors are arranged from left-to-right, bottom-to-top,
     such that the first component is at the bottom-left.

`PCAPrjnPlot(GraphLog* disp_log, int pat_no, int x_axis_component, int y_axis_component, bool print_eigen_vals)'
     Performs principal components analysis of the correlations of
     patterns in `pat_no' across events, and then plots projections
     of all the patterns onto two of the principal components in the
     graph log (NULL = new log).  This provides a means of
     representing the similarities of the different patterns with
     each other in a two-dimensional space.  The X-axis of the graph
     represents how similar the patterns are along the first selected
     component, and the Y-axis represents how similar they are along
     the second selected component.

`MDSPrjnPlot(GraphLog* disp_log, int pat_no, int x_axis_component, int y_axis_component, metric, norm, tol, bool print_eigen_vals)'
     Performs multidimensional scaling (MDS) on the distance matrix
     (computed according to metric, norm, tol parameters) of patterns
     in pat_no across events in the graph log (NULL = new log).
     Multidimensional scaling takes a set of dissimilarities and
     returns a set of points such that the distances between the
     points are approximately equal to the dissimilarities.  The
     results of this are typically very similar to PCA, even though
     the method is somewhat different, operating on the distance
     matrix instead of the correlation matrix.  The classical
     (metric) form of MDS is used, computed according to the
     algorithm developed by Torgerson, W. S. (1958).  Theory and
     Methods of Scaling. New York: Wiley, as extracted from the
     `cmdscale.R' function from the R statistical program.

`EventPrjnPlot(Event* x_axis_event, Event* y_axis_event, int pat_no, GraphLog* disp_log, metric, norm, tol)'
     Projects all events according to their smiliarity to the two
     specified events using given distance metrics.  This allows one
     to obtain a 2-d plot of the similarity of all events to two
     selected events.

`EnvToGrid(GridLog* disp_log, int pat_no, ev_x, y, pt_x, y)'
     This dumps the entire set of events worth of a given pattern
     into a grid log for more efficient viewing and for more control
     over the display layout.  The ev_x, ev_y parameters control the
     geometry of the events, and the pt_x, pt_y control the geometry
     of the pattern values within each event.

`PatFreqText(float act_thresh, bool proportion, ostream& strm)'
     Reports frequency (proportion) of pattern values greater than
     act_thresh across events, to a text output (this is most useful
     if pattern values are named in value_names).  This can be useful
     for verifying that an environment has expected probabilities of
     different inputs.

`PatFreqGrid(GridLog* disp_log, float act_thresh, bool proportion)'
     Reports frequency (proportion) of pattern values greater than
     act_thresh across events, to a grid log (if NULL, new log is
     made).

`PatAggText(Aggregate& agg, ostream& strm)'
     Reports aggregate (SUM, AVG, etc) of pattern values across
     events, to a text output (this is most useful if pattern values
     are named in value_names).  This can be useful for identifying
     the overall properties of events.

`PatAggGrid(GridLog* disp_log, float act_thresh, bool proportion)'
     Reports aggregate (SUM, AVG, etc) of pattern values across
     events, to a grid log (NULL = make a new log).  This can be
     useful for identifying the overall properties of events.

`EventFreqText(bool proportion, ostream& strm)'
     Reports frequency (proportion) of event names in the environment.
     Also useful for validating that the environment contains what you
     think it should.

