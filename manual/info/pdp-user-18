This is pdp-user, produced by makeinfo version 4.1 from pdp-user.texi.


File: pdp-user,  Node: prog,  Next: conceptindex,  Prev: leabra,  Up: Top

Programming in PDP++
********************

   This chapter contains some useful information for those who want
to add new functionality to the PDP++ software by compiling their own
executable.  By creating new subclasses of existing classes, and using
these new classes in your simulations, it should be possible to make
PDP++ do exactly what you want it to.

   Before taking this step, you should be reasonably comfortable with
the CSS language and using it to access objects in the simulator.
Further, you will need to know (or learn about) C++ in a bit more
detail than is covered in the CSS section of this manual.  There are
a number of good books on this subject available in most bookstores.

   This chapter describes how to set up the makefiles in your own
directory where you will compile your executable.  It then describes
various coding conventions and extensions to the basic C++ language
that we have added to facilitate programming in PDP++.  We have
established a standard way of dealing with creating, copying, and
deleting objects.  In addition, each object has special functions
that allow groups to manage them.  All of these "coding conventions"
are described in this chapter.

   We have developed a run-time-type-information (RTTI) system called
TypeAccess, which provides type information about most classes at
run-time.  This can be used to determine what kind of unit a Unit*
object _really_ is, for example (i.e., is it a BpUnit or a
MyWackyBpUnit?).

   The TypeAccess system requires a more complicated than normal set
of makefiles.  Fortunately, it is reasonably straightforward to use
the makefiles we have developed, so you won't have to deal with much
of this complexity.

   Most of the graphical interface (i.e., edit dialogs, menus, etc) is
generated automatically from the information provided by TypeAccess.
The same is true for the way you can transparently access hard-coded
types and objects through CSS.  Thus, you don't need to do anything
special to be able to use your newly defined classes exactly in the
way that you use the ones that come with the software.

   There are some special keywords that you can put in the comments
for your classes and class members and methods called "comment
directives".  These comment directives allow you to control various
aspects of how the GUI and CSS treat your objects.  These comment
directives are described in this chapter.

* Menu:

* prog-make::                   Makefiles and Directory Organization
* prog-typea::                  The TypeAccess System
* prog-comdir::                 Standard TypeAccess Comment Directives
* prog-coding::                 Coding Conventions and Standards


File: pdp-user,  Node: prog-make,  Next: prog-typea,  Prev: prog,  Up: prog

Makefiles and Directory Organization
====================================

   The PDP++ code should be installed in `/usr/local/pdp++', or some
such similar place.  This path will be referred to from here on out as
PDPDIR.  This directory contains a set of sub-directories, like
`demo' and `manual', etc. which contain different pieces of the
distribution.  See *Note inst-prog:: for instructions on how to
install and compile the source distribution of the PDP++ software.  In
order compile your own additions to the software, you must install and
compile the source code distribution!

   The critical directories from a programmer's perspective are the
`src', which contains the source code, `config', which contains the
Makefile configuration stuff, `include' which has links to the header
files, and `lib' which has links to the various libraries.

   Each sub-directory within the `src' directory contains code
relevant to some sub-component of the PDP++ software.  These
directories are as follows:
`ta_string'
     The basic String class used throughout the software.  It is a
     slightly modified version of the GNU String class that is
     distributed with the libg++ distribution (version 2.6.2).

`iv_misc'
     Contains a number of extra pieces of code that supplement the
     InterViews GUI toolkit.

`ta'
     Contains the TypeAccess system, which gives classes the ability
     to know all about themselves and other classes at run time.  The
     use of this software is what makes the largely automatic
     interface used in PDP++ possible.  It is described further in
     *Note prog-typea::.  This directory also contains a lot of basic
     objects, like Array (*Note obj-array::), List and Group (*Note
     obj-group::) objects.

`css'
     Contains the code for the CSS script language (*note css::).

`iv_graphic'
     Contains a set of objects which implement a graphical object
     manipulation environment that is used in the network viewer
     (*note net-view::) and the graph log (*note log-views-graph::).

`ta_misc'
     Contains a smorgasbord of various objects that might have
     general applicability, and are not specifically PDP objects.

`pdp'
     Where all of the specific pdp code is.

`bp'
     Implements bp and rbp.

`cs'
     Implements cs.

`so'
     Implements so.

`bpso'
     Implements the combined bp and so executable (just links the
     libraries).

`leabra'
     Implements the leabra algorithm.

   Each directory has a set of include files which can be accessed as
<xxx/yyy.h>, where xxx is one of the directory names given above.  In
addition, each directory has its own library, which is just
`libxxx.a', where xxx is the name of the directory (without any
underbars).  The bp, cs and so directories have a library name of
libpdp_xx.a, to indicate that they are part of the pdp software.

   All of the compilation results (e.g. object files) go in a
subdirectory named after the CPU type being used.  The user must set
the CPU environmental variable appropriately, as per the definitions
used in the InterViews system.  The ones that everything has been
tested and compiled on are listed in the installation guide (*note
inst::), and the INSTALL file.

   Other possibilities are listed in *Note inst-prog::.  This should
be the same as when the system was first installed.

   The include files and library are made in two stages.  The first
stage involves compiling the object files into the CPU subdirectory.
Then, if everything goes ok, the library is made, which is then
copied into a further subdirectory of the CPU subdirectory called
`lib_include'.  Also, all of the header files are compared with those
already in the `lib_include' subdirectory (if any), and those ones
that are different are copied over.  It is these header files in
`lib_include' that the `PDPDIR/include' directory makes links to, and
thus these are the ones that are included by other programs.  This
setup allows one to test out a set of code by making an executable in
a given directory and getting things working before installing the
new header files and library for the rest of the system to use.

   In order to add functionality to the software, one needs to create
a new directory, and then include various files from the above
directories, and link in their respective libraries.  This directory
can be located in the same master directory as the main distribution,
or it can be located in your own home directory somewhere.  This
latter option is the preferred one.

   We have developed a shell file that does all of the things
necessary to create your own directory.  The first step is to make a
master directory off of your home directory, typically called `pdp++'.

   Then, run the `PDPDIR/bin/mknewpdp' command from this new
`home/pdp++' directory with an argument which is the name of the
directory/executable that you want to make.  This will give you
step-by-step instructions.  In the end, you will end up with a
directory that contains some sample code in the form of a .h and .cc
file with the same name as the directory.

   The script will have installed a `Makefile' in your directory which
is the same as the one's found in the main PDP++ directories.  These
makefiles are constructed by concatenating together a bunch of pieces
of makefiles, some of which contain standard make actions, and others
which contain specific defaults for particular machines.  All of the
pieces are found in the `PDPDIR/config' directory.

   The makefiles named `Makefile.CPU.[CC|g++]' are the
machine-specific files that you should edit to make sure they have all
the right settings for your system.  This should have been done
already during the installation of the PDP++ source code
distribution, see *Note inst-prog:: for details.

   To these pieces is added the specific list of files that need to
be made in your directory. This is specified in the `Makefile.in'
file.  This is the only makefile you should edit. It can be used to
override any of the settings in the standard makefiles, simply by
redefining definitions or actions.  If you add files to your
directory, follow the example for the one already in your default
`Makefile.in' that was installed with the `mknewpdp' command.

   Note that there are a couple of compiler-specific "extra" files in
the directory.  These have the name of the directory plus a `_vt.cc'
or `_it.cc' suffix.  The `_vt' file is for virtual table
instantiation, which is controlled in cfront with the +e0/+e1
arguments.  It simply includes most of the header files in the
software.  We have found that by compiling everything except the
`_vt' file with +e0 that the executables are much smaller.  This is
even true in cfront versions where they had "fixed" this problem.
You can try doing the other way by leaving out the +e args and not
using the `_vt' file (see the definitions in
`PDPDIR/config/Makefile.defs' for how to do this: change your
`Makefile.CPU' file and recompile the entire distribution first..).

   The `_ti.cc' is the template instantiation file needed by gnu g++
version 2.6.3 (reportedly, it won't be needed in 2.7).  It contains
explicit instantiations of all of the templates used in each library.
For user directories, this probably isn't needed, but its there if you
do declare any templates and encounter link problems with g++.  Also,
the `Makefile.CPU.g++' show how this file gets included in the making
of a given project.

   New for 2.0: All of the makefile actions, as shown below, are now
available using a consistent syntax structure: all lower case, with
underbars separating different words.  This makes it much easier to
remember what command to type.  The old eclectic combinations of upper
and lower case words, etc are still available if you already know
them.

   The commonly-used actions that are defined in the makefile are as
follows:
`make bin, make opt_bin, make dbg_bin'
     Makes the binary from the files in this directory. Bin makes the
     default form specified in the make file, while opt and dbg make
     optimized and debug versions, respectively.

`make re_bin, make opt_re_bin, make dbg_re_bin'
     Same as above, except it first removes the executable before
     making.  This is useful if a library has changed but no header
     files from that library were changed.

`make lib, make opt_lib, make dbg_lib'
     Like the above, except it makes a library containing the
     relevant .o files.

`make new_makefile'
     This makes a new version of the `Makefile' file in the current
     directory.  This concatenates all of the different parts that
     together make up a single `Makefile'.  However, it does not make
     a `CPU' directory, which is necessary to actually compile (see
     `cpu_dir' next).

`make cpu_dir, make local_cpu_dir'
     This makes and configures a directory with the same name as the
     `CPU' environmental variable (reflecting the CPU type of the
     machine) suitable for compiling the object files into.  If
     `local_cpu_dir' is made first, then this directory is actually a
     symbolic link to a directory created on a disk local to the
     current machine, so that compilation will be faster than if the
     directory where the source is located is a networked (slow)
     directory (i.e., NFS).  The `cpu_dir' action copies the current
     `Makefile' into the directory, and configures the directory for
     compiling.  Note that these actions remove any existing
     dependency information, so that a `depend' action should be made
     following either of them.

`make depend'
     This automatically adds dependency information for the files in
     this directory onto the `CPU/Makefile' file.  This allows the
     make command to know when to compile these files after something
     they depend on has been touched (edited).

`make makefiles, make make_depend, make new_make_depend'
     These actions simply combine some of the above steps together
     into one action.  `makefiles' does a `new_makefile' and then a
     `cpu_dir', `make_depend' does a `cpu_dir' and then a `depend',
     and `new_make_depend' does all three of the necessary steps:
     `new_makefiles', `cpu_dir', and `depend'.  The only reason you
     should not use the latter all the time is if your `make' program
     has trouble using a new `Makefile' (i.e., as created by the
     `make new_makefiles' action) for calling the subsequent actions.
     In this case, you have to first do a `make new_makefiles' and
     then you can do a `make make_depend'.

`make force_ta'
     Forces a call to the TypeAccess scanning program `maketa'.


File: pdp-user,  Node: prog-typea,  Next: prog-comdir,  Prev: prog-make,  Up: prog

The TypeAccess System
=====================

   The TypeAccess system consists of a set of objects that can hold
type information about class objects.  This type information includes
the names and types of all the members and methods in a class, the
parents of the class, etc.  This information can be used by classes to
get information about themselves at run time.  In addition, the
TypeAccess system provides a set of type-aware base classes and macros
for defining derived versions of these that can be used to easily
incorporate run-time type information into any C++ system.

   In addition to being type-aware, the base classes can use their
own type information to save and load themselves automatically to and
from ASCII format text files.  Further, there is an extensible
graphical interface based on InterViews which can automatically build
editing dialogs for filling in member values and calling member
functions on arbitrary objects.  Finally, the type information can be
used to provide a transparent script-level interface to the objects
from the CSS script language.  This provides the benefits of compiled
C++ for fast execution, and the ability to perform arbitrary
interactive processing in an interpreter using the C++ language
supported by CSS.

   Many features of the interface and script level interface, as well
as various options that affect the way objects are saved and loaded,
can be specified in comments that follow the declaration of classes,
members, and methods.  These comment directives constitute a secondary
programming language of sorts, and they greatly increase the
flexibility of the interface.  They are documented in *Note
prog-comdir::.

   Thus, the PDP++ software gets much of its functionality from the
TypeAccess system.  It provides all of the basic interface and
file-level functionality so that the programmer only needs to worry
about defining classes that perform specific tasks.  These classes can
then be flexibly used and manipulated by the end user with the generic
TypeAccess based interface.

* Menu:

* prog-typea-files::            Scanning Type Information using `maketa'
* prog-typea-args::             Startup Arguments for `maketa'
* prog-typea-stru::             Structure of TypeAccess Type Data
* prog-typea-base::             The Type-Aware Base Class taBase
* prog-typea-dump::             The Dump-file Format for Saving/Loading


File: pdp-user,  Node: prog-typea-files,  Next: prog-typea-args,  Prev: prog-typea,  Up: prog-typea

Scanning Type Information using `maketa'
----------------------------------------

   Type information for TypeAccess is scanned from the header files
using a program called `maketa', which looks for `class' and
`typedef' definitions, and records what it finds.  It operates on all
the header files in a given directory at the same time, and it
produces three output files: `xxx_TA_type.h', `xxx_TA_inst.h', and
`xxx_TA.cc', where xxx is given by a "project name" argument.  The
first file contains a list of `extern' declarations of instances of
the TypeDef type, which is the basic object that records information
about types.  Each type that was defined with a `class' or `typedef',
or ones that are modifications of basic types, such as reference or
pointer types, are given their own TypeDef object, which is named
with the name of the type with a leading `TA_' prefix. Thus, a class
named MyClass would have corresponding TypeDef object named
TA_MyClass, which can be used directly in programs to obtain type
information about the MyClass object. a Pointers have a `_ptr'
suffix, and references have a `_ref' suffix.  Template instances are
represented by replacing the angle brackets with underbars.  The
`xxx_TA_type.h' file must be included in any header files which
reference their own type information.

   The `xxx_TA_inst.h' file contains declarations of "instance"
objects, which are pointers to a token of each of the classes for
which type information is available.  These instances are named `TAI_'
with the rest the same as the corresponding `TA_' name.  The
`-instances' argument to `maketa' determines if instances are made,
and this can be overridden with the `#NO_INSTANCE' and `#INSTANCE'
comment directives (*note prog-comdir::).  The TypeDef object can use
an instance object of one of the type-aware base classes to make a
new token of that object given only the name of the type to be
created.  This gives the system the power to create and delete
objects at will, which is necessary for the file saving and loading
system to work.

   Finally, the `xxx_TA.cc' file contains the actual definitions of
all the type information.  It must be compiled and linked in with the
project, and its `ta_Init_xxx' function must be called at the start
of the execution of the program before any type information is used.

   Note that while `maketa' does process complexities like `template'
and multiply inherited classes properly, it does not deal with
multiple versions of the same function which differ only in argument
type in the same way that C++ does.  Instead, the scanner just keeps
the last version of a given method defined on the class.  This makes
the type information compatible with the limitations of CSS in this
respect, since it does not know how to use argument types to select
the proper function to be called (*note css-c++-diff::).  This
limitation greatly simplifies the way that functions are called by
CSS.  It is recommended that you create methods which have some hint
as to what kinds of arguments they expect, in order to get around this
limitation.  The taList and taGroup classes, for example, contain
both overloaded and specific versions of the `Find' function, so the
C++ programmer can call `Find' with any of a number of different
argument types, while the CSS programmer can use the `FindName' or
`FindType' versions of the function.


File: pdp-user,  Node: prog-typea-args,  Next: prog-typea-stru,  Prev: prog-typea-files,  Up: prog-typea

Startup Arguments for `maketa'
------------------------------

   The type-scanning program `maketa' takes the following arguments:

`[-v<level>]'
     Verbosity level, 1-5, 1=results,2=more
     detail,3=trace,4=source,5=parse.

`[-hx | -nohx]'
     Generate .hx, .ccx files instead of .h, .cc.  This is used in
     conjunction with a makefile that compares the .hx with the .h
     version of a file and only updates the .h if it actually differs
     from the .hx version.  This prevents lots of needless
     recompiling when the type-scanned information is not actually
     different when a header file was touched.

`[-css]'
     Generate CSS stub functions.  The stub functions take cssEl*
     arguments, and call member functions on classes.  These must be
     present to use CSS to call member functions on classes, or to
     call functions from the edit dialog menus and buttons.

`[-instances]'
     Generate instance tokens of types.  Instances are needed to make
     tokens of class objects.

`[-class_only | -struct_union]'
     Only scan for `class' types (else `struct' and `union' too). The
     default is to only scan for `class' types because they are
     always used in the definition of a class object.  `struct' and
     `union' can be used to modify the type name in old-style C code,
     which can throw off the scanner since these don't amount to class
     definitions.

`[-I<include>]...'
     Path to include files (one path per -I).

`[-D<define>]...'
     Define a pre-processor macro.

`[-cpp=<cpp command>]'
     Explicit path for c-pre-processor.  The default is to use
     `/usr/lib/cpp', which doesn't work very well on C++ code, but its
     there.  It is recommended that you use cccp, which is the gnu
     preprocessor that comes with gcc.

`[-hash<size>]'
     Size of hash tables (default 2000), use -v1 to see actual sizes
     after parsing all the types.

`project'
     This is the stub project name (generates
     project_TA[.cc|_type.h|_inst.h]).

`files...'
     These are the header files to be processed.


File: pdp-user,  Node: prog-typea-stru,  Next: prog-typea-base,  Prev: prog-typea-args,  Up: prog-typea

Structure of TypeAccess Type Data
---------------------------------

   The classes used in storing type information in the TypeAccess
system are all defined in the `ta/typea.h' header file.  Basically,
there are a set of Space objects, which all derive from a basic form
of the `List' object (defined in `ta/ta_list.h', which represent type
spaces, member spaces, method spaces, etc.  These are just containers
of objects.  The spaces are: TypeSpace, MemberSpace, MethodSpace,
EnumSpace, TokenSpace.  Note that they contain functions for finding,
printing, and generally manipulating the objects they contain.

   There are corresponding TypeDef, MemberDef, MethodDef, and EnumDef
objects which hold specific information about the corresponding
aspect of type information.  The TypeDef contains the following
fields:

`String name'
     Holds the name of the type.

`String desc'
     A description which is obtained from the user's comment
     following the declaration of the type.

`uint size'
     The size of the object in bytes.

`int ptr'
     The number of pointers this type is from a basic non-pointer
     type.

`bool ref'
     True if this is a reference type.

`bool internal'
     True if this type information was automatically or internally
     generated.  This typically refers to pointer and reference types
     which were created when the scanner encountered their use in
     arguments or members of other classes that were being scanned.

`bool formal'
     True for basic level objects like `TA_class' and `TA_template'
     which are are formal parents (`par_formal') of types that users
     declare.  These provide a way of determining some basic features
     of the type.  Formal type objects are declared and installed
     automatically by the type scanning system.

`bool pre_parsed'
     True if this type was registered as previously parsed by the
     type scanning system (i.e., it encountered an `extern TypeDef
     TA_xxx' for this type, where xxx is the name of the type).
     These types don't get included in the list of types for this
     directory.  This makes it possible to do type scanning on a
     complex set of nested libraries.

`String_PArray inh_opts'
     These are the options (comment directives) that are inherited by
     this type (i.e., those declared with a `##' instead of a `#').

`String_PArray opts'
     These are all of the options (comment directives) for this type,
     including inherited and non-inherited ones.

`String_PArray lists'
     A list of the `#LIST_xxx' values declared for this type.

`TypeSpace parents'
     A list of parents of this type.  There are multiple parents for
     multiple-inheritance `class' types, and for `internal' types
     which are the combination of basic types, such as `unsigned
     long', etc.

`int_PArray par_off'
     A list of offsets from the start of memory occupied by this
     class where the parent object begins.  These are used for
     multiply inherited class types.  They are in a one-to-one
     correspondence with the `parents' entries.

`TypeSpace par_formal'
     A list of the formal parents of this type, including `TA_class',
     etc.

`TypeSpace par_cache'
     A special cache of frequently-queried type parents.  Currently
     if a type derives from taBase, then `TA_taBase' shows up here
     (because a lot of the TypeAccess code checks if something is
     derived from the basic type-aware type taBase).

`TypeSpace children'
     A list of all the types that are derived from this one.

`void** instance'
     A pointer to a pointer of an instance of this type, if it is
     kept.  The `GetInstance' function should be used to get the
     actual instance pointer.

`TokenSpace tokens'
     A list of the actual instances or tokens of this type that have
     been created by the user (the `TAI_xxx' instance object is not
     registered here).  These are not kept if the type does not
     record tokens (see the `#NO_TOKENS' comment directive, *Note
     comdir-objs::).

`taivType* iv'
     A pointer to an object which defines how a token of this type
     appears in a GUI edit dialog.  There is a "bidding" procedure
     which assigns these objects, allowing for the user to add new
     specialized representations which out-bid the standard ones.
     This bidding takes place when the gui stuff is initialized, and
     the results are stored here.

`taivEdit* ive'
     This is like the `iv' pointer, except it is the object which is
     used to generate the entire edit dialog for this object.  It also
     is the result of a bidding procedure.

`taBase_Group* defaults'
     These are pointers to different TypeDefault objects for this
     type.  Each TypeDefault object is for a different scope where
     these types can be created (i.e., a different Project in the
     PDP++ software).

`EnumSpace enum_vals'
     Contains the enum objects contained within a given `enum'
     declaration.

`TypeSpace sub_types'
     These are the sub-types declared with a `typedef', `enum', or as
     part of a template instantiation within a `class' object.

`MemberSpace members'
     These are the members of a `class' object.

`MethodSpace methods'
     These are the methods of a `class' object.

`TypeSpace templ_pars'
     These are the template parameters for template objects.  In the
     `template' itself, they are the formal parameters (i.e., `T'),
     but in the template instance they point to the actual types with
     which the template was instantiated.

   The most important functions on the TypeDef object are as follows:

`bool HasOption(const char* op)'
     Checks to see if the given option (comment directive) (don't
     include the `#') is present on this type.

`String OptionAfter(const char* op)'
     Returns the portion of the option (comment directive) after the
     given part.  This is used for things like `#MENU_ON_xxx' to
     obtain the xxx part.  If option is not present, an empty string
     is returned.

`InheritsFrom(TypeDef* tp)'
     Checks if this type inherits from the given one (versions that
     take a string and a reference to a TypeDef are also defined).
     Inheritance is defined only for classes, not for a pointer to a
     given class, for example.  Thus, both the argument and the type
     this is called on must be non-pointer, non-reference types.

`DerivesFrom(TypeDef* tp)'
     Simply checks if the given type appears anywhere in the list of
     parents for this type.  Thus, a pointer to a class derives from
     that class, but it does not inherit from it.

`String GetValStr(void* base, void* par=NULL, MemberDef* memb_def=NULL)'
     Uses the type-scanned information to obtain a string
     representation of the value of an instance of this type.  `base'
     is a pointer to the start of a token of this type, and `par' and
     `member_def' can be passed if it is known that this token is in
     a parent class at a particular member def.  This and the
     following function are used widely, including for saving and
     loading of objects, etc.

`SetValStr(const char* val, void* base, void* par=NULL, MemberDef* memb_def=NULL)'
     Takes a string representation of a type instance, and sets the
     value of the token accordingly (it is the inverse of
     `GetValStr').

`CopyFromSameType(void* trg_base, void* src_base, MemberDef* memb_def=NULL)'
     Uses the type-scanned information to copy from one type instance
     to the next.  Any class objects that are members are copied
     using that object's copy operator if one is defined (this is
     only known for derivatives of the taBase base class).

`Dump_Save(ostream& strm, void* base, void* par=NULL, int indent=0)'
     This will save the given type object to a file.  Files are saved
     in an ASCII format, and are capable of saving pointers to other
     objects when these objects derive from the taBase object.
     Special code is present for dealing with groups of objects
     stored in the taList or taGroup classes.  See *Note
     prog-typea-dump:: for more details.

`Dump_Load(istream& strm, void* base, void* par=NULL)'
     This will load a file saved by the `Dump_Save' command.

   The other Def objects are fairly straightforward.  Each includes a
`name' and `desc' field, and a list of `opts' (comment directives)
and `lists'.  Also, each contains an `iv' field which represents the
item in the GUI edit dialog, and is the result of a bidding process
(see the `iv' field in the TypeDef object above).  They all have the
`HasOption' and `OptionAfter' functions plus a number of other useful
functions (see the `ta/typea.h' for details).

   MemberDef objects contain the following additional fields. Note
that derived classes contain links (_not copies_) of the members and
methods they inherit from their parent, except when the class has
multiple parents, in which case copies are made for the derived class
because the offset information will no longer be the same for the
derived class.

`TypeDef* type'
     The type of the member.

`ta_memb_ptr off'
     The address or offset of this member relative to the start of
     the memory allocated for the class in which this member was
     declared.

`int base_off'
     The offset to add to the base address (address of the start of
     the class object) to obtain the start of the class this member
     was declared in.  This is for members of parents of
     multiply-inherited derived classes.

`bool is_static'
     True if the member was declared `static'.  Thus, it can be
     accessed without a `this' pointer.  The `addr' field contains
     its absolute address.

`void* addr'
     The absolute address (not relative to the class object) of a
     static member.

`bool fun_ptr'
     True if the member is actually a pointer to a function.

   The MethodDef object contains the following additional variables:

`TypeDef* type'
     The type of the method.

`bool is_static'
     True if the method was declared `static'.

`ta_void_fun addr'
     The address of a `static' method.  Non-static methods do not
     have their addresses recorded.  Methods are called via the
     `stubp' function, if the `-css' option was used during scanning.

`int fun_overld'
     The number of times this function was overloaded (i.e., a
     function of the same name was declared in the class or its
     parents).  TypeAccess does not perform name mangling on
     functions, so only one instance of a given method is recorded.
     It is the last one that the scanner encounters that is kept.

`int fun_argc'
     The number of arguments for this function.

`int fun_argd'
     The index where the arguments start having default values.
     Thus, the function can be called with a variable number of
     arguments from `fun_argd' to `fun_argc'.

`TypeSpace arg_types'
     These are the types of the arguments.

`String_PArray arg_names'
     These are the names of the arguements (in one-to-one
     correspondence with the types).

`css_fun_stub_ptr stubp'
     A pointer to a "stub" function which calls this method using
     cssEl objects as arguments.  This function is defined in the
     `xxx_TA.cc' file if the `-css' argument is given to `maketa'.
     The cssEl objects have conversion functions for most types of
     arguments, so that the function is called by casting the
     arguments into the types expected by the function.  Pointers to
     class objects are handled by `cssTA' objects which have a
     pointer and a corresponding `TypeDef' pointer, so they know what
     kind of object they point to, making conversion type-safe.
     These stubs return a cssEl object.  They also take a `void*' for
     the `this' object.  These stubs are used both by CSS and to call
     methods from the edit dialogs from menus and buttons.


File: pdp-user,  Node: prog-typea-base,  Next: prog-typea-dump,  Prev: prog-typea-stru,  Up: prog-typea

The Type-Aware Base Class taBase
--------------------------------

   There is a basic class type called taBase that uses the TypeAccess
type information to perform a number of special functions
automatically.  This object is aware of its own type information, and
can thus save and load itself, etc.  Special code has been written in
both the TypeAccess system and in CSS that takes advantage of the
interface provided by the taBase type.  Thus, it is recommended that
user's derive all of their types from this base type, and use special
macros to provide derived types with the hooks necessary to get their
own type information and use it effectively.  The type TAPtr is a
`typedef' for a pointer to a taBase object.  The definition of a
taBase object and the macros that are used with it are all in
`ta/ta_base.h'.

   All taBase objects have only one member, which is a reference
counter.  This provides a mechanism for determining when it is safe to
delete an object when the object is being referenced or pointed to in
various different places.  taBase provides a set of referencing and
pointer-management functions that simplify the use of a
reference-count based memory management system.  `Ref' increments the
reference count, `unRef' decrements it, `Done' checks if the refcount
is zero, and deletes the object if it is, and `unRefDone' does both.
`Own' both Ref's an object and sets its owner.  For pointers,
`SetPointer' unrefs any existing object that the pointer points to,
and sets it to point to the new object.  `DelPointer' does an
`unRefDone' on the object pointed to, and sets the pointer to NULL.
`OwnPointer' is like SetPointer except it also sets the owner of the
pointed-to object to the one given by the argument.  See *Note
coding-funs:: and `ta/ta_base.h' for more details.

   The one essential function that taBase provides is `GetTypeDef()',
which is a virtual function that returns a pointer to the `TypeDef'
type descriptor for this object. This function is defined as part of
the basic macro `TA_BASEFUNS', which must be included in all classes
derived from taBase.  This function makes it possible for a generic
pointer to a taBase object to find out what type of object is really
being pointed to.

   There are a number of functions defined on the taBase type that
simply call the corresponding function on the TypeDef pointer.  These
can be found in the `ta/ta_base.h' header file.  They just make it
easier to call these commonly-used functions, instead of requiring the
user to put in a `GetTypeDef' function in between.

   taBase also provides a simplified way of managing the construction,
deletion, and copying of an object.  Basically, construction is broken
down into a set of functions that `Initialize' the member variables,
`Register' the new token with the type if it is keeping track of
tokens, and it sets the default name of the object based on its type
name using `SetDefaultName'.  The `TA_BASEFUNS' macro defines a
default constructor that calls these three functions in that order.
The user thus needs to provide a `Initialize' function for every
class defined, which does the appropriate member initialization.
Note that if this function is not defined, the one on the parent class
will be called twice, so its more efficient to include a blank
Initialize function when there are no members that need to be
initialized.

   The destructor function is similar to the constructor.  A default
destructor is defined in `TA_BASEFUNS', which simply calls
`unRegister', and `Destroy'.  Thus, the user needs to provide a
`Destroy' function which frees any additional resources allocated by
the object, etc.  Like `Initialize', a blank `Destroy' should be
defined when there is nothing that needs to be done to prevent the
parent function from being called twice.

   Copying, cloning, and making a new token of the given type are also
supported in the taBase class.  The `Copy' function performs the
basic copy operations for both the copy constructor and the `='
operator.  This should replace the values of this class and any of its
existing sub-objects with those of the object passed to it, as it is
intended for assignment between two existing objects.  In general, the
`=' operator should be used for copying all members, except for the
case of `LINK_GROUP' groups and lists, which should use the
`BorrowUnique' function (since they do not own the items in the list,
just link them).  `Copy' must call the parent's `Copy' function as
well.  As a minor simplification of calling the parent (and to
provide a copy function for just the items in a given class), it is
conventional to define a `Copy_' function, which does everything
except for calling the parent copy function.  The macro `COPY_FUNS'
can be used to define a `Copy' function which calls the parent
function and then `Copy_'.  The macro `SIMPLE_COPY' defines a `Copy_'
function which uses the type-scanned information to do the copying.
It is slower than hand-coding things, so it probably shouldn't be
used on types which will have a lot of tokens or be copied often.

   A `Clone' function which returns a `TAPtr' to a new duplicate of
this object is defined in `TA_BASEFUNS', as well as an "unsafe"
version of `Copy' (`UnSafeCopy'), which takes a generic `TAPtr'
argument and casts it into their type.  The argument's type should
thus be tested before calling this function.  A safe interface to
this function is provided by the `CopyFrom' function, which does the
type checking.  Finally, the `MakeToken' function will create a new
token of the type.

   The taBase class also contains functions for creating and
manipulating a structure hierarchy of objects.  This is where certain
objects contain groups of other objects, which contain other objects,
etc.  For example, the PDP++ software has a structure hierarchy built
around a root object, which contains projects, which contain lots of
other objects like networks, projects, environments, etc.  Special
container objects like taList and taGroup play an important role in
representing and manipulating this structure (note that it is
possible to write other types of container objects which could play
the same role simply by overloading the same functions that these
objects do).

   When an object is "linked" into the object hierarchy, a function
called `InitLinks' is called.  This function should perform any kind
of initialization that depends on the object being situated in the
hierarchy, like being able to know what object "owns" this one.
taBase has functions for getting and setting the owner of an object.
For example, when a group (taList or taGroup creates a new object and
links it into its list of objects, it calls the `SetOwner' function
with a pointer to itself on this new object, and then it calls
`InitLinks'.  Similarly, when the object is removed from the group,
the `CutLinks' function is called, which should cut any links that
the object has with other objects.

   An object's location in the object hierarchy can be represented by
a _path_ to that object from a global root object.  A given
application is assumed to have a root object, which contains all other
objects.  A pointer to that object is kept in tabMisc::root, which is
used to anchor the path to any given object.  An object can find its
path with the `GetPath' function, and an object can be found from a
path with the `FindFromPath' function.

   Finally, a function for allowing an object to set the values of
certain members based on changes that might have been made in other
members after a user edits the object, called `UpdateAfterEdit', is
provided.  This function is called on most objects after they are
loaded from a save file (except those with the `#NO_UPDATE_AFTER'
comment directive), and on all objects after the user hits Apply or Ok
in an edit dialog, and after any member is set through a CSS assign
statement.  While the object does not know which members were changed
when `UpdateAfterEdit' is called, the object can buffer previous
state on its own to figure this out if it is needed.

   For a step-by-step guide to making a new class that derives from
taBase, see *Note prog-coding::.


File: pdp-user,  Node: prog-typea-dump,  Prev: prog-typea-base,  Up: prog-typea

The Dump-file Format for Saving/Loading
---------------------------------------

   The format used for dumping objects to files an loading them back
in involves two passes.  The first pass lists all of the objects to be
saved (i.e., the object that the `Save' function was called on, and
any sub-objects it owns.  This is done so that during loading, all
objects will have been created before pointers to these objects
attempt to be cashed out.  The second pass then saves all of the
values associated with the members in the object.  The format is a
name-value based one, so that files can be loaded back into objects
whose definition has changed.  It skips member names it can't find,
etc, so you can continue to modify your software and still load old
data.

   Paths (i.e., the `GetPath' function) figure heavily into the saving
of objects, especially pointers.  Pointers are saved by giving the
path to the object.  These saved paths are automatically corrected if
the objects are loaded into a different location than the one they
were saved in.  All pointers that are saved are assumed to be
reference-counter based.  Thus, the `SetPointer' function is used to
set the pointer.  Also note that it is impossible to save a pointer
to a non-taBase derived object, since there is no way to get the path
of such an object.


File: pdp-user,  Node: prog-comdir,  Next: prog-coding,  Prev: prog-typea,  Up: prog

Standard TypeAccess Comment Directives
======================================

   The following sections document comment directives that are
recognized by the standard TypeAccess GUI and script-language
interfaces.  These must be placed in comments immediately following
the definition of that which the apply to.  Thus, an object directive
should appear as

       class whatever : public something {  // #IGNORE comment goes here

   for members and methods, it should be as follows:
       class whatever : public something {  // #IGNORE comment goes here
         int         member_1;       // #HIDDEN comment goes here
         float       member_2;
         // #READ_ONLY or here
         float       get_real();     /* #USE_RVAL note that multi-line
            old-fashioned c-style comments are legal too! */

* Menu:

* comdir-objs::                 Object Directives
* comdir-membs::                Member Directives
* comdir-meths::                Method Directives
* comdir-funs::                 Top-Level Function Directives
* comdir-pdp::                  PDP++ Specific Directives


File: pdp-user,  Node: comdir-objs,  Next: comdir-membs,  Prev: prog-comdir,  Up: prog-comdir

Object Directives
-----------------

   If you add an extra "#" to the beginning of the comment directive,
it will automatically be inherited by any sub-classes of the given
object.  Otherwise, it only applies to the object on which it was
given.

`#IGNORE'
     Do not register this object in the list of types.

`#NO_TOKENS'
     Do not keep a record of the tokens of this object type.  Types
     can keep pointers to all instances or tokens of themselves.
     This can be expensive in terms of memory, but the interface uses
     "token menus" for arguements or methods which are pointers to
     objects of the given type.

`#NO_INSTANCE'
     Do not create a global instance (`TAI_xxx') of this object.  This
     will prevent tokens of this object from being made.

`#INSTANCE'
     If default is not to create instances, then create one anyway
     for this object.

`#NO_MEMBERS'
     Do not store the members (including member functions) of this
     class.  Only the type name will be registered.

`#NO_CSS'
     Do not create CSS stub functions for the member functions on
     this object.

`#INLINE'
     Causes this item to be edited in a single line in a dialog box
     (e.g. for geometry x,y,z) and affects saving/loading, etc.

`#EDIT_INLINE'
     Only causes this item to be edited in a single line in a dialog
     box, but in all other respects it is treated as a normal
     included class.  This is useful for certain complex objects such
     as arrays and lists that do not otherwise save/load well as
     INLINES.

`#BUTROWS_x'
     Set the number of button rows to be x, useful if default
     allocation of number of rows of buttons for edit dialog is not
     correct

`#EXT_xxx'
     Sets the default extension for saving/loading this type to xxx.

`#COMPRESS'
     store dump file's of this object compressed.  Since the save
     files are text, they can be large, so it is a good idea to
     auto-compress dump files for large objects.

`#MEMB_IN_GPMENU'
     This indicates that there is a group object as a member of this
     one who's objects should appear in menus where this object
     appears.

`#VIRT_BASE'
     This is a "virtual" base class: don't show in token menus for
     this object, etc.

`#NO_UPDATE_AFTER'
     Don't call UpdateAfterEdit when loading this object (and other
     places it might automatically get called).  Since a list of
     objects which should be updated after loading is made, small or
     numerous objects should not be added to this list if not
     necessary.

`#IMMEDIATE_UPDATE'
     Perform an immediate UpdateAfterEdit on this object after
     loading (i.e., it creates other objects..).  Normally, updating
     happens after all of the other objects have been loaded.

`#SCOPE_xxx'
     Type of object to use as a scope for this object.  The scope
     restricts token menus and other things to only those things that
     share a common parent token of the given scope type.

`#ARRAY_ALLOC'
     Specific to taList_impl derivatives: this list or group should
     have saved items created all together during loading (ie., like
     an array).  If actually using array-based memory allocation,
     this is essential, but otherwise it can only speed things up a
     little bit.

`#LINK_SAVE'
     Save the actual contents of this object even when it appears as
     a link in a list.  Usually just the link pointer is saved, and
     the object is saved later in the group that actually owns it.
     This overrides this and saves the information in both places -
     can be useful if info from the linked object is needed during
     loading.

`#NO_OK'
     Do not present an OK button on the edit dialog for this object.

`#NO_CANCEL'
     Do not present a CANCEL button on the edit dialog for this
     object.

